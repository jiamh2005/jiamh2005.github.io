<!DOCTYPE html>
<html lang=":lang">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="LAOJIA" />



<meta name="description" content="ForewordOver the years, my employer has trusted me enough to conduct interviews. If we’re looking for someone with skills in JavaScript, my first line of questioning… actually that’s not true, I first">
<meta property="og:type" content="article">
<meta property="og:title" content="Async&amp;Performence">
<meta property="og:url" content="https://jiamh2005.github.io/2018/02/27/Async-Performence/index.html">
<meta property="og:site_name" content="Spaces of Jia">
<meta property="og:description" content="ForewordOver the years, my employer has trusted me enough to conduct interviews. If we’re looking for someone with skills in JavaScript, my first line of questioning… actually that’s not true, I first">
<meta property="og:locale" content=":lang">
<meta property="og:updated_time" content="2018-04-15T06:20:50.988Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Async&amp;Performence">
<meta name="twitter:description" content="ForewordOver the years, my employer has trusted me enough to conduct interviews. If we’re looking for someone with skills in JavaScript, my first line of questioning… actually that’s not true, I first">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Spaces of Jia" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Async&amp;Performence | Spaces of Jia</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">LAOJIA</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:jia@jiamh.top" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZTE/">ZTE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健康/">健康</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/创业/">创业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/情感/">情感</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端、后端的新方案，向专业进发！</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <div class="body-wrap"><article id="post-Async-Performence" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/02/27/Async-Performence/" class="article-date">
      <time datetime="2018-02-27T10:35:27.000Z" itemprop="datePublished">2018-02-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Async&amp;Performence
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h1><p>Over the years, my employer has trusted me enough to conduct interviews. If we’re looking for someone with skills in JavaScript, my first line of questioning… actually that’s not true, I first check if the candidate needs the bathroom and/or a drink, because comfort is important, but once I’m past the bit about the candidate’s fluid in/out-take, I set about determining if the candidate knows JavaScript, or just jQuery.</p>
<p>Not that there’s anything wrong with jQuery. It lets you do a lot without really knowing JavaScript, and that’s a feature not a bug. But if the job calls for advanced skills in JavaScript performance and maintainability, you need someone who knows how libraries such as jQuery are put together. You need to be able to harness the core of JavaScript the same way they do.</p>
<p>If I want to get a picture of someone’s core JavaScript skill, I’m most interested in what they make of closures (you’ve read that book of this series already, right?) and how to get the most out of asynchronicity, which brings us to this book.</p>
<p>For starters, you’ll be taken through callbacks, the bread and butter of asynchronous programming. Of course, bread and butter does not make for a particularly satisfying meal, but the next course is full of tasty tasty promises!</p>
<p>If you don’t know promises, now is the time to learn. Promises are now the official way to provide async return values in both JavaScript and the DOM. All future async DOM APIs will use them, many already do, so be prepared! At the time of writing, Promises have shipped in most major browsers, with IE shipping soon. Once you’ve finished that, I hope you left room for the next course, Generators.</p>
<p>Generators snuck their way into stable versions of Chrome and Firefox without too much pomp and ceremony, because, frankly, they’re more complicated than they are interesting. Or, that’s what I thought until I saw them combined with promises. There, they become an important tool in readability and maintenance.</p>
<p>For dessert, well, I won’t spoil the surprise, but prepare to gaze into the future of JavaScript! Features that give you more and more control over concurrency and asynchronicity.</p>
<p>Well, I won’t block your enjoyment of the book any longer, on with the show! If you’ve already read part of the book before reading this Foreword, give yourself 10 asynchronous points! You deserve them!</p>
<p>Jake Archibald<br><br><a href="http://jakearchibald.com" target="_blank" rel="noopener">jakearchibald.com</a>, <a href="http://twitter.com/jaffathecake" target="_blank" rel="noopener">@jaffathecake</a><br><br>Developer Advocate at Google Chrome</p>
<h1 id="Chapter-1-Asynchrony-Now-amp-Later"><a href="#Chapter-1-Asynchrony-Now-amp-Later" class="headerlink" title="Chapter 1: Asynchrony: Now &amp; Later"></a>Chapter 1: Asynchrony: Now &amp; Later</h1><p>One of the most important and yet often misunderstood parts of programming in a language like JavaScript is how to express and manipulate program behavior spread out over a period of time.</p>
<p>This is not just about what happens from the beginning of a <code>for</code> loop to the end of a <code>for</code> loop, which of course takes <em>some time</em> (microseconds to milliseconds) to complete. It’s about what happens when part of your program runs <em>now</em>, and another part of your program runs <em>later</em> – there’s a gap between <em>now</em> and <em>later</em> where your program isn’t actively executing.</p>
<p>Practically all nontrivial programs ever written (especially in JS) have in some way or another had to manage this gap, whether that be in waiting for user input, requesting data from a database or file system, sending data across the network and waiting for a response, or performing a repeated task at a fixed interval of time (like animation). In all these various ways, your program has to manage state across the gap in time. As they famously say in London (of the chasm between the subway door and the platform): “mind the gap.”</p>
<p>In fact, the relationship between the <em>now</em> and <em>later</em> parts of your program is at the heart of asynchronous programming.</p>
<p>Asynchronous programming has been around since the beginning of JS, for sure. But most JS developers have never really carefully considered exactly how and why it crops up in their programs, or explored various <em>other</em> ways to handle it. The <em>good enough</em> approach has always been the humble callback function. Many to this day will insist that callbacks are more than sufficient.</p>
<p>But as JS continues to grow in both scope and complexity, to meet the ever-widening demands of a first-class programming language that runs in browsers and servers and every conceivable device in between, the pains by which we manage asynchrony are becoming increasingly crippling, and they cry out for approaches that are both more capable and more reason-able.</p>
<p>While this all may seem rather abstract right now, I assure you we’ll tackle it more completely and concretely as we go on through this book. We’ll explore a variety of emerging techniques for async JavaScript programming over the next several chapters.</p>
<p>But before we can get there, we’re going to have to understand much more deeply what asynchrony is and how it operates in JS.</p>
<h2 id="A-Program-in-Chunks"><a href="#A-Program-in-Chunks" class="headerlink" title="A Program in Chunks"></a>A Program in Chunks</h2><p>You may write your JS program in one <em>.js</em> file, but your program is almost certainly comprised of several chunks, only one of which is going to execute <em>now</em>, and the rest of which will execute <em>later</em>. The most common unit of <em>chunk</em> is the <code>function</code>.</p>
<p>The problem most developers new to JS seem to have is that <em>later</em> doesn’t happen strictly and immediately after <em>now</em>. In other words, tasks that cannot complete <em>now</em> are, by definition, going to complete asynchronously, and thus we will not have blocking behavior as you might intuitively expect or want.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line"><span class="keyword">var</span> data = ajax( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( data );</span><br><span class="line"><span class="comment">// Oops! `data` generally won't have the Ajax results</span></span><br></pre></td></tr></table></figure>
<p>You’re probably aware that standard Ajax requests don’t complete synchronously, which means the <code>ajax(..)</code> function does not yet have any value to return back to be assigned to <code>data</code> variable. If <code>ajax(..)</code> <em>could</em> block until the response came back, then the <code>data = ..</code> assignment would work fine.</p>
<p>But that’s not how we do Ajax. We make an asynchronous Ajax request <em>now</em>, and we won’t get the results back until <em>later</em>.</p>
<p>The simplest (but definitely not only, or necessarily even best!) way of “waiting” from <em>now</em> until <em>later</em> is to use a function, commonly called a callback function:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span> <span class="title">myCallbackFunction</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( data ); <span class="comment">// Yay, I gots me some `data`!</span></span><br><span class="line"></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Warning:</strong> You may have heard that it’s possible to make synchronous Ajax requests. While that’s technically true, you should never, ever do it, under any circumstances, because it locks the browser UI (buttons, menus, scrolling, etc.) and prevents any user interaction whatsoever. This is a terrible idea, and should always be avoided.</p>
<p>Before you protest in disagreement, no, your desire to avoid the mess of callbacks is <em>not</em> justification for blocking, synchronous Ajax.</p>
<p>For example, consider this code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">later</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	answer = answer * <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"Meaning of life:"</span>, answer );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> answer = now();</span><br><span class="line"></span><br><span class="line">setTimeout( later, <span class="number">1000</span> ); <span class="comment">// Meaning of life: 42</span></span><br></pre></td></tr></table></figure>
<p>There are two chunks to this program: the stuff that will run <em>now</em>, and the stuff that will run <em>later</em>. It should be fairly obvious what those two chunks are, but let’s be super explicit:</p>
<p>Now:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">later</span>(<span class="params"></span>) </span>&#123; .. &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> answer = now();</span><br><span class="line"></span><br><span class="line">setTimeout( later, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure></p>
<p>Later:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">answer = answer * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Meaning of life:"</span>, answer );</span><br></pre></td></tr></table></figure></p>
<p>The <em>now</em> chunk runs right away, as soon as you execute your program. But <code>setTimeout(..)</code> also sets up an event (a timeout) to happen <em>later</em>, so the contents of the <code>later()</code> function will be executed at a later time (1,000 milliseconds from now).</p>
<p>Any time you wrap a portion of code into a <code>function</code> and specify that it should be executed in response to some event (timer, mouse click, Ajax response, etc.), you are creating a <em>later</em> chunk of your code, and thus introducing asynchrony to your program.</p>
<h3 id="Async-Console"><a href="#Async-Console" class="headerlink" title="Async Console"></a>Async Console</h3><p>There is no specification or set of requirements around how the <code>console.*</code> methods work – they are not officially part of JavaScript, but are instead added to JS by the <em>hosting environment</em> (see the <em>Types &amp; Grammar</em> title of this book series).</p>
<p>So, different browsers and JS environments do as they please, which can sometimes lead to confusing behavior.</p>
<p>In particular, there are some browsers and some conditions that <code>console.log(..)</code> does not actually immediately output what it’s given. The main reason this may happen is because I/O is a very slow and blocking part of many programs (not just JS). So, it may perform better (from the page/UI perspective) for a browser to handle <code>console</code> I/O asynchronously in the background, without you perhaps even knowing that occurred.</p>
<p>A not terribly common, but possible, scenario where this could be <em>observable</em> (not from code itself but from the outside):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	index: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ??</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// even later</span></span><br><span class="line">a.index++;</span><br></pre></td></tr></table></figure>
<p>We’d normally expect to see the <code>a</code> object be snapshotted at the exact moment of the <code>console.log(..)</code> statement, printing something like <code>{ index: 1 }</code>, such that in the next statement when <code>a.index++</code> happens, it’s modifying something different than, or just strictly after, the output of <code>a</code>.</p>
<p>Most of the time, the preceding code will probably produce an object representation in your developer tools’ console that’s what you’d expect. But it’s possible this same code could run in a situation where the browser felt it needed to defer the console I/O to the background, in which case it’s <em>possible</em> that by the time the object is represented in the browser console, the <code>a.index++</code> has already happened, and it shows <code>{ index: 2 }</code>.</p>
<p>It’s a moving target under what conditions exactly <code>console</code> I/O will be deferred, or even whether it will be observable. Just be aware of this possible asynchronicity in I/O in case you ever run into issues in debugging where objects have been modified <em>after</em> a <code>console.log(..)</code> statement and yet you see the unexpected modifications show up.</p>
<p><strong>Note:</strong> If you run into this rare scenario, the best option is to use breakpoints in your JS debugger instead of relying on <code>console</code> output. The next best option would be to force a “snapshot” of the object in question by serializing it to a <code>string</code>, like with <code>JSON.stringify(..)</code>.</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>Let’s make a (perhaps shocking) claim: despite clearly allowing asynchronous JS code (like the timeout we just looked at), up until recently (ES6), JavaScript itself has actually never had any direct notion of asynchrony built into it.</p>
<p><strong>What!?</strong> That seems like a crazy claim, right? In fact, it’s quite true. The JS engine itself has never done anything more than execute a single chunk of your program at any given moment, when asked to.</p>
<p>“Asked to.” By whom? That’s the important part!</p>
<p>The JS engine doesn’t run in isolation. It runs inside a <em>hosting environment</em>, which is for most developers the typical web browser. Over the last several years (but by no means exclusively), JS has expanded beyond the browser into other environments, such as servers, via things like Node.js. In fact, JavaScript gets embedded into all kinds of devices these days, from robots to lightbulbs.</p>
<p>But the one common “thread” (that’s a not-so-subtle asynchronous joke, for what it’s worth) of all these environments is that they have a mechanism in them that handles executing multiple chunks of your program <em>over time</em>, at each moment invoking the JS engine, called the “event loop.”</p>
<p>In other words, the JS engine has had no innate sense of <em>time</em>, but has instead been an on-demand execution environment for any arbitrary snippet of JS. It’s the surrounding environment that has always <em>scheduled</em> “events” (JS code executions).</p>
<p>So, for example, when your JS program makes an Ajax request to fetch some data from a server, you set up the “response” code in a function (commonly called a “callback”), and the JS engine tells the hosting environment, “Hey, I’m going to suspend execution for now, but whenever you finish with that network request, and you have some data, please <em>call</em> this function <em>back</em>.”</p>
<p>The browser is then set up to listen for the response from the network, and when it has something to give you, it schedules the callback function to be executed by inserting it into the <em>event loop</em>.</p>
<p>So what is the <em>event loop</em>?</p>
<p>Let’s conceptualize it first through some fake-ish code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `eventLoop` is an array that acts as a queue (first-in, first-out)</span></span><br><span class="line"><span class="keyword">var</span> eventLoop = [ ];</span><br><span class="line"><span class="keyword">var</span> event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep going "forever"</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="comment">// perform a "tick"</span></span><br><span class="line">	<span class="keyword">if</span> (eventLoop.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// get the next event in the queue</span></span><br><span class="line">		event = eventLoop.shift();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// now, execute the next event</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			event();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">			reportError(err);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is, of course, vastly simplified pseudocode to illustrate the concepts. But it should be enough to help get a better understanding.</p>
<p>As you can see, there’s a continuously running loop represented by the <code>while</code> loop, and each iteration of this loop is called a “tick.” For each tick, if an event is waiting on the queue, it’s taken off and executed. These events are your function callbacks.</p>
<p>It’s important to note that <code>setTimeout(..)</code> doesn’t put your callback on the event loop queue. What it does is set up a timer; when the timer expires, the environment places your callback into the event loop, such that some future tick will pick it up and execute it.</p>
<p>What if there are already 20 items in the event loop at that moment? Your callback waits. It gets in line behind the others – there’s not normally a path for preempting the queue and skipping ahead in line. This explains why <code>setTimeout(..)</code> timers may not fire with perfect temporal accuracy. You’re guaranteed (roughly speaking) that your callback won’t fire <em>before</em> the time interval you specify, but it can happen at or after that time, depending on the state of the event queue.</p>
<p>So, in other words, your program is generally broken up into lots of small chunks, which happen one after the other in the event loop queue. And technically, other events not related directly to your program can be interleaved within the queue as well.</p>
<p><strong>Note:</strong> We mentioned “up until recently” in relation to ES6 changing the nature of where the event loop queue is managed. It’s mostly a formal technicality, but ES6 now specifies how the event loop works, which means technically it’s within the purview of the JS engine, rather than just the <em>hosting environment</em>. One main reason for this change is the introduction of ES6 Promises, which we’ll discuss in Chapter 3, because they require the ability to have direct, fine-grained control over scheduling operations on the event loop queue (see the discussion of <code>setTimeout(..0)</code> in the “Cooperation” section).</p>
<h2 id="Parallel-Threading"><a href="#Parallel-Threading" class="headerlink" title="Parallel Threading"></a>Parallel Threading</h2><p>It’s very common to conflate the terms “async” and “parallel,” but they are actually quite different. Remember, async is about the gap between <em>now</em> and <em>later</em>. But parallel is about things being able to occur simultaneously.</p>
<p>The most common tools for parallel computing are processes and threads. Processes and threads execute independently and may execute simultaneously: on separate processors, or even separate computers, but multiple threads can share the memory of a single process.</p>
<p>An event loop, by contrast, breaks its work into tasks and executes them in serial, disallowing parallel access and changes to shared memory. Parallelism and “serialism” can coexist in the form of cooperating event loops in separate threads.</p>
<p>The interleaving of parallel threads of execution and the interleaving of asynchronous events occur at very different levels of granularity.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">later</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	answer = answer * <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"Meaning of life:"</span>, answer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While the entire contents of <code>later()</code> would be regarded as a single event loop queue entry, when thinking about a thread this code would run on, there’s actually perhaps a dozen different low-level operations. For example, <code>answer = answer * 2</code> requires first loading the current value of <code>answer</code>, then putting <code>2</code> somewhere, then performing the multiplication, then taking the result and storing it back into <code>answer</code>.</p>
<p>In a single-threaded environment, it really doesn’t matter that the items in the thread queue are low-level operations, because nothing can interrupt the thread. But if you have a parallel system, where two different threads are operating in the same program, you could very likely have unpredictable behavior.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	a = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>
<p>In JavaScript’s single-threaded behavior, if <code>foo()</code> runs before <code>bar()</code>, the result is that <code>a</code> has <code>42</code>, but if <code>bar()</code> runs before <code>foo()</code> the result in <code>a</code> will be <code>41</code>.</p>
<p>If JS events sharing the same data executed in parallel, though, the problems would be much more subtle. Consider these two lists of pseudocode tasks as the threads that could respectively run the code in <code>foo()</code> and <code>bar()</code>, and consider what happens if they are running at exactly the same time:</p>
<p>Thread 1 (<code>X</code> and <code>Y</code> are temporary memory locations):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo():</span><br><span class="line">  a. load value of `a` in `X`</span><br><span class="line">  b. store `1` in `Y`</span><br><span class="line">  c. add `X` and `Y`, store result in `X`</span><br><span class="line">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>
<p>Thread 2 (<code>X</code> and <code>Y</code> are temporary memory locations):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bar():</span><br><span class="line">  a. load value of `a` in `X`</span><br><span class="line">  b. store `2` in `Y`</span><br><span class="line">  c. multiply `X` and `Y`, store result in `X`</span><br><span class="line">  d. store value of `X` in `a`</span><br></pre></td></tr></table></figure></p>
<p>Now, let’s say that the two threads are running truly in parallel. You can probably spot the problem, right? They use shared memory locations <code>X</code> and <code>Y</code> for their temporary steps.</p>
<p>What’s the end result in <code>a</code> if the steps happen like this?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class="line">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class="line">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class="line">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class="line">1c  (add `X` and `Y`, store result in `X`   ==&gt; `22`)</span><br><span class="line">1d  (store value of `X` in `a`   ==&gt; `22`)</span><br><span class="line">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `44`)</span><br><span class="line">2d  (store value of `X` in `a`   ==&gt; `44`)</span><br></pre></td></tr></table></figure>
<p>The result in <code>a</code> will be <code>44</code>. But what about this ordering?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class="line">2a  (load value of `a` in `X`   ==&gt; `20`)</span><br><span class="line">2b  (store `2` in `Y`   ==&gt; `2`)</span><br><span class="line">1b  (store `1` in `Y`   ==&gt; `1`)</span><br><span class="line">2c  (multiply `X` and `Y`, store result in `X`   ==&gt; `20`)</span><br><span class="line">1c  (add `X` and `Y`, store result in `X`   ==&gt; `21`)</span><br><span class="line">1d  (store value of `X` in `a`   ==&gt; `21`)</span><br><span class="line">2d  (store value of `X` in `a`   ==&gt; `21`)</span><br></pre></td></tr></table></figure>
<p>The result in <code>a</code> will be <code>21</code>.</p>
<p>So, threaded programming is very tricky, because if you don’t take special steps to prevent this kind of interruption/interleaving from happening, you can get very surprising, nondeterministic behavior that frequently leads to headaches.</p>
<p>JavaScript never shares data across threads, which means <em>that</em> level of nondeterminism isn’t a concern. But that doesn’t mean JS is always deterministic. Remember earlier, where the relative ordering of <code>foo()</code> and <code>bar()</code> produces two different results (<code>41</code> or <code>42</code>)?</p>
<p><strong>Note:</strong> It may not be obvious yet, but not all nondeterminism is bad. Sometimes it’s irrelevant, and sometimes it’s intentional. We’ll see more examples of that throughout this and the next few chapters.</p>
<h3 id="Run-to-Completion"><a href="#Run-to-Completion" class="headerlink" title="Run-to-Completion"></a>Run-to-Completion</h3><p>Because of JavaScript’s single-threading, the code inside of <code>foo()</code> (and <code>bar()</code>) is atomic, which means that once <code>foo()</code> starts running, the entirety of its code will finish before any of the code in <code>bar()</code> can run, or vice versa. This is called “run-to-completion” behavior.</p>
<p>In fact, the run-to-completion semantics are more obvious when <code>foo()</code> and <code>bar()</code> have more code in them, such as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	a++;</span><br><span class="line">	b = b * a;</span><br><span class="line">	a = b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	b--;</span><br><span class="line">	a = <span class="number">8</span> + b;</span><br><span class="line">	b = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>
<p>Because <code>foo()</code> can’t be interrupted by <code>bar()</code>, and <code>bar()</code> can’t be interrupted by <code>foo()</code>, this program only has two possible outcomes depending on which starts running first – if threading were present, and the individual statements in <code>foo()</code> and <code>bar()</code> could be interleaved, the number of possible outcomes would be greatly increased!</p>
<p>Chunk 1 is synchronous (happens <em>now</em>), but chunks 2 and 3 are asynchronous (happen <em>later</em>), which means their execution will be separated by a gap of time.</p>
<p>Chunk 1:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>Chunk 2 (<code>foo()</code>):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a++;</span><br><span class="line">b = b * a;</span><br><span class="line">a = b + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>Chunk 3 (<code>bar()</code>):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b--;</span><br><span class="line">a = <span class="number">8</span> + b;</span><br><span class="line">b = a * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>Chunks 2 and 3 may happen in either-first order, so there are two possible outcomes for this program, as illustrated here:</p>
<p>Outcome 1:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo()</span></span><br><span class="line">a++;</span><br><span class="line">b = b * a;</span><br><span class="line">a = b + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar()</span></span><br><span class="line">b--;</span><br><span class="line">a = <span class="number">8</span> + b;</span><br><span class="line">b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 11</span></span><br><span class="line">b; <span class="comment">// 22</span></span><br></pre></td></tr></table></figure></p>
<p>Outcome 2:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar()</span></span><br><span class="line">b--;</span><br><span class="line">a = <span class="number">8</span> + b;</span><br><span class="line">b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo()</span></span><br><span class="line">a++;</span><br><span class="line">b = b * a;</span><br><span class="line">a = b + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 183</span></span><br><span class="line">b; <span class="comment">// 180</span></span><br></pre></td></tr></table></figure></p>
<p>Two outcomes from the same code means we still have nondeterminism! But it’s at the function (event) ordering level, rather than at the statement ordering level (or, in fact, the expression operation ordering level) as it is with threads. In other words, it’s <em>more deterministic</em> than threads would have been.</p>
<p>As applied to JavaScript’s behavior, this function-ordering nondeterminism is the common term “race condition,” as <code>foo()</code> and <code>bar()</code> are racing against each other to see which runs first. Specifically, it’s a “race condition” because you cannot predict reliably how <code>a</code> and <code>b</code> will turn out.</p>
<p><strong>Note:</strong> If there was a function in JS that somehow did not have run-to-completion behavior, we could have many more possible outcomes, right? It turns out ES6 introduces just such a thing (see Chapter 4 “Generators”), but don’t worry right now, we’ll come back to that!</p>
<h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><p>Let’s imagine a site that displays a list of status updates (like a social network news feed) that progressively loads as the user scrolls down the list. To make such a feature work correctly, (at least) two separate “processes” will need to be executing <em>simultaneously</em> (i.e., during the same window of time, but not necessarily at the same instant).</p>
<p><strong>Note:</strong> We’re using “process” in quotes here because they aren’t true operating system–level processes in the computer science sense. They’re virtual processes, or tasks, that represent a logically connected, sequential series of operations. We’ll simply prefer “process” over “task” because terminology-wise, it will match the definitions of the concepts we’re exploring.</p>
<p>The first “process” will respond to <code>onscroll</code> events (making Ajax requests for new content) as they fire when the user has scrolled the page further down. The second “process” will receive Ajax responses back (to render content onto the page).</p>
<p>Obviously, if a user scrolls fast enough, you may see two or more <code>onscroll</code> events fired during the time it takes to get the first response back and process, and thus you’re going to have <code>onscroll</code> events and Ajax response events firing rapidly, interleaved with each other.</p>
<p>Concurrency is when two or more “processes” are executing simultaneously over the same period, regardless of whether their individual constituent operations happen <em>in parallel</em> (at the same instant on separate processors or cores) or not. You can think of concurrency then as “process”-level (or task-level) parallelism, as opposed to operation-level parallelism (separate-processor threads).</p>
<p><strong>Note:</strong> Concurrency also introduces an optional notion of these “processes” interacting with each other. We’ll come back to that later.</p>
<p>For a given window of time (a few seconds worth of a user scrolling), let’s visualize each independent “process” as a series of events/operations:</p>
<p>“Process” 1 (<code>onscroll</code> events):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onscroll, request 1</span><br><span class="line">onscroll, request 2</span><br><span class="line">onscroll, request 3</span><br><span class="line">onscroll, request 4</span><br><span class="line">onscroll, request 5</span><br><span class="line">onscroll, request 6</span><br><span class="line">onscroll, request 7</span><br></pre></td></tr></table></figure></p>
<p>“Process” 2 (Ajax response events):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">response 1</span><br><span class="line">response 2</span><br><span class="line">response 3</span><br><span class="line">response 4</span><br><span class="line">response 5</span><br><span class="line">response 6</span><br><span class="line">response 7</span><br></pre></td></tr></table></figure></p>
<p>It’s quite possible that an <code>onscroll</code> event and an Ajax response event could be ready to be processed at exactly the same <em>moment</em>. For example, let’s visualize these events in a timeline:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onscroll, request 1</span><br><span class="line">onscroll, request 2          response 1</span><br><span class="line">onscroll, request 3          response 2</span><br><span class="line">response 3</span><br><span class="line">onscroll, request 4</span><br><span class="line">onscroll, request 5</span><br><span class="line">onscroll, request 6          response 4</span><br><span class="line">onscroll, request 7</span><br><span class="line">response 6</span><br><span class="line">response 5</span><br><span class="line">response 7</span><br></pre></td></tr></table></figure>
<p>But, going back to our notion of the event loop from earlier in the chapter, JS is only going to be able to handle one event at a time, so either <code>onscroll, request 2</code> is going to happen first or <code>response 1</code> is going to happen first, but they cannot happen at literally the same moment. Just like kids at a school cafeteria, no matter what crowd they form outside the doors, they’ll have to merge into a single line to get their lunch!</p>
<p>Let’s visualize the interleaving of all these events onto the event loop queue.</p>
<p>Event Loop Queue:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onscroll, request 1   &lt;--- Process 1 starts</span><br><span class="line">onscroll, request 2</span><br><span class="line">response 1            &lt;--- Process 2 starts</span><br><span class="line">onscroll, request 3</span><br><span class="line">response 2</span><br><span class="line">response 3</span><br><span class="line">onscroll, request 4</span><br><span class="line">onscroll, request 5</span><br><span class="line">onscroll, request 6</span><br><span class="line">response 4</span><br><span class="line">onscroll, request 7   &lt;--- Process 1 finishes</span><br><span class="line">response 6</span><br><span class="line">response 5</span><br><span class="line">response 7            &lt;--- Process 2 finishes</span><br></pre></td></tr></table></figure></p>
<p>“Process 1” and “Process 2” run concurrently (task-level parallel), but their individual events run sequentially on the event loop queue.</p>
<p>By the way, notice how <code>response 6</code> and <code>response 5</code> came back out of expected order?</p>
<p>The single-threaded event loop is one expression of concurrency (there are certainly others, which we’ll come back to later).</p>
<h3 id="Noninteracting"><a href="#Noninteracting" class="headerlink" title="Noninteracting"></a>Noninteracting</h3><p>As two or more “processes” are interleaving their steps/events concurrently within the same program, they don’t necessarily need to interact with each other if the tasks are unrelated. <strong>If they don’t interact, nondeterminism is perfectly acceptable.</strong></p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">	res.foo = results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">	res.bar = results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>
<p><code>foo()</code> and <code>bar()</code> are two concurrent “processes,” and it’s nondeterminate which order they will be fired in. But we’ve constructed the program so it doesn’t matter what order they fire in, because they act independently and as such don’t need to interact.</p>
<p>This is not a “race condition” bug, as the code will always work correctly, regardless of the ordering.</p>
<h3 id="Interaction"><a href="#Interaction" class="headerlink" title="Interaction"></a>Interaction</h3><p>More commonly, concurrent “processes” will by necessity interact, indirectly through scope and/or the DOM. When such interaction will occur, you need to coordinate these interactions to prevent “race conditions,” as described earlier.</p>
<p>Here’s a simple example of two concurrent “processes” that interact because of implied ordering, which is only <em>sometimes broken</em>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	res.push( data );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, response );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, response );</span><br></pre></td></tr></table></figure>
<p>The concurrent “processes” are the two <code>response()</code> calls that will be made to handle the Ajax responses. They can happen in either-first order.</p>
<p>Let’s assume the expected behavior is that <code>res[0]</code> has the results of the <code>&quot;http://some.url.1&quot;</code> call, and <code>res[1]</code> has the results of the <code>&quot;http://some.url.2&quot;</code> call. Sometimes that will be the case, but sometimes they’ll be flipped, depending on which call finishes first. There’s a pretty good likelihood that this nondeterminism is a “race condition” bug.</p>
<p><strong>Note:</strong> Be extremely wary of assumptions you might tend to make in these situations. For example, it’s not uncommon for a developer to observe that <code>&quot;http://some.url.2&quot;</code> is “always” much slower to respond than <code>&quot;http://some.url.1&quot;</code>, perhaps by virtue of what tasks they’re doing (e.g., one performing a database task and the other just fetching a static file), so the observed ordering seems to always be as expected. Even if both requests go to the same server, and <em>it</em> intentionally responds in a certain order, there’s no <em>real</em> guarantee of what order the responses will arrive back in the browser.</p>
<p>So, to address such a race condition, you can coordinate ordering interaction:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data.url == <span class="string">"http://some.url.1"</span>) &#123;</span><br><span class="line">		res[<span class="number">0</span>] = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data.url == <span class="string">"http://some.url.2"</span>) &#123;</span><br><span class="line">		res[<span class="number">1</span>] = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, response );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, response );</span><br></pre></td></tr></table></figure>
<p>Regardless of which Ajax response comes back first, we inspect the <code>data.url</code> (assuming one is returned from the server, of course!) to figure out which position the response data should occupy in the <code>res</code> array. <code>res[0]</code> will always hold the <code>&quot;http://some.url.1&quot;</code> results and <code>res[1]</code> will always hold the <code>&quot;http://some.url.2&quot;</code> results. Through simple coordination, we eliminated the “race condition” nondeterminism.</p>
<p>The same reasoning from this scenario would apply if multiple concurrent function calls were interacting with each other through the shared DOM, like one updating the contents of a <code>&lt;div&gt;</code> and the other updating the style or attributes of the <code>&lt;div&gt;</code> (e.g., to make the DOM element visible once it has content). You probably wouldn’t want to show the DOM element before it had content, so the coordination must ensure proper ordering interaction.</p>
<p>Some concurrency scenarios are <em>always broken</em> (not just <em>sometimes</em>) without coordinated interaction. Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	a = x * <span class="number">2</span>;</span><br><span class="line">	baz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">	b = y * <span class="number">2</span>;</span><br><span class="line">	baz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>
<p>In this example, whether <code>foo()</code> or <code>bar()</code> fires first, it will always cause <code>baz()</code> to run too early (either <code>a</code> or <code>b</code> will still be <code>undefined</code>), but the second invocation of <code>baz()</code> will work, as both <code>a</code> and <code>b</code> will be available.</p>
<p>There are different ways to address such a condition. Here’s one simple way:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	a = x * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">		baz();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">	b = y * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">		baz();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>
<p>The <code>if (a &amp;&amp; b)</code> conditional around the <code>baz()</code> call is traditionally called a “gate,” because we’re not sure what order <code>a</code> and <code>b</code> will arrive, but we wait for both of them to get there before we proceed to open the gate (call <code>baz()</code>).</p>
<p>Another concurrency interaction condition you may run into is sometimes called a “race,” but more correctly called a “latch.” It’s characterized by “only the first one wins” behavior. Here, nondeterminism is acceptable, in that you are explicitly saying it’s OK for the “race” to the finish line to have only one winner.</p>
<p>Consider this broken code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	a = x * <span class="number">2</span>;</span><br><span class="line">	baz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	a = x / <span class="number">2</span>;</span><br><span class="line">	baz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>
<p>Whichever one (<code>foo()</code> or <code>bar()</code>) fires last will not only overwrite the assigned <code>a</code> value from the other, but it will also duplicate the call to <code>baz()</code> (likely undesired).</p>
<p>So, we can coordinate the interaction with a simple latch, to let only the first one through:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">undefined</span>) &#123;</span><br><span class="line">		a = x * <span class="number">2</span>;</span><br><span class="line">		baz();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="literal">undefined</span>) &#123;</span><br><span class="line">		a = x / <span class="number">2</span>;</span><br><span class="line">		baz();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, foo );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, bar );</span><br></pre></td></tr></table></figure>
<p>The <code>if (a == undefined)</code> conditional allows only the first of <code>foo()</code> or <code>bar()</code> through, and the second (and indeed any subsequent) calls would just be ignored. There’s just no virtue in coming in second place!</p>
<p><strong>Note:</strong> In all these scenarios, we’ve been using global variables for simplistic illustration purposes, but there’s nothing about our reasoning here that requires it. As long as the functions in question can access the variables (via scope), they’ll work as intended. Relying on lexically scoped variables (see the <em>Scope &amp; Closures</em> title of this book series), and in fact global variables as in these examples, is one obvious downside to these forms of concurrency coordination. As we go through the next few chapters, we’ll see other ways of coordination that are much cleaner in that respect.</p>
<h3 id="Cooperation"><a href="#Cooperation" class="headerlink" title="Cooperation"></a>Cooperation</h3><p>Another expression of concurrency coordination is called “cooperative concurrency.” Here, the focus isn’t so much on interacting via value sharing in scopes (though that’s obviously still allowed!). The goal is to take a long-running “process” and break it up into steps or batches so that other concurrent “processes” have a chance to interleave their operations into the event loop queue.</p>
<p>For example, consider an Ajax response handler that needs to run through a long list of results to transform the values. We’ll use <code>Array#map(..)</code> to keep the code shorter:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// `response(..)` receives array of results from the Ajax call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// add onto existing `res` array</span></span><br><span class="line">	res = res.concat(</span><br><span class="line">		<span class="comment">// make a new transformed array with all `data` values doubled</span></span><br><span class="line">		data.map( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">		&#125; )</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, response );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, response );</span><br></pre></td></tr></table></figure>
<p>If <code>&quot;http://some.url.1&quot;</code> gets its results back first, the entire list will be mapped into <code>res</code> all at once. If it’s a few thousand or less records, this is not generally a big deal. But if it’s say 10 million records, that can take a while to run (several seconds on a powerful laptop, much longer on a mobile device, etc.).</p>
<p>While such a “process” is running, nothing else in the page can happen, including no other <code>response(..)</code> calls, no UI updates, not even user events like scrolling, typing, button clicking, and the like. That’s pretty painful.</p>
<p>So, to make a more cooperatively concurrent system, one that’s friendlier and doesn’t hog the event loop queue, you can process these results in asynchronous batches, after each one “yielding” back to the event loop to let other waiting events happen.</p>
<p>Here’s a very simple approach:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// `response(..)` receives array of results from the Ajax call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// let's just do 1000 at a time</span></span><br><span class="line">	<span class="keyword">var</span> chunk = data.splice( <span class="number">0</span>, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add onto existing `res` array</span></span><br><span class="line">	res = res.concat(</span><br><span class="line">		<span class="comment">// make a new transformed array with all `chunk` values doubled</span></span><br><span class="line">		chunk.map( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> val * <span class="number">2</span>;</span><br><span class="line">		&#125; )</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// anything left to process?</span></span><br><span class="line">	<span class="keyword">if</span> (data.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// async schedule next batch</span></span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			response( data );</span><br><span class="line">		&#125;, <span class="number">0</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax(..) is some arbitrary Ajax function given by a library</span></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, response );</span><br><span class="line">ajax( <span class="string">"http://some.url.2"</span>, response );</span><br></pre></td></tr></table></figure>
<p>We process the data set in maximum-sized chunks of 1,000 items. By doing so, we ensure a short-running “process,” even if that means many more subsequent “processes,” as the interleaving onto the event loop queue will give us a much more responsive (performant) site/app.</p>
<p>Of course, we’re not interaction-coordinating the ordering of any of these “processes,” so the order of results in <code>res</code> won’t be predictable. If ordering was required, you’d need to use interaction techniques like those we discussed earlier, or ones we will cover in later chapters of this book.</p>
<p>We use the <code>setTimeout(..0)</code> (hack) for async scheduling, which basically just means “stick this function at the end of the current event loop queue.”</p>
<p><strong>Note:</strong> <code>setTimeout(..0)</code> is not technically inserting an item directly onto the event loop queue. The timer will insert the event at its next opportunity. For example, two subsequent <code>setTimeout(..0)</code> calls would not be strictly guaranteed to be processed in call order, so it <em>is</em> possible to see various conditions like timer drift where the ordering of such events isn’t predictable. In Node.js, a similar approach is <code>process.nextTick(..)</code>. Despite how convenient (and usually more performant) it would be, there’s not a single direct way (at least yet) across all environments to ensure async event ordering. We cover this topic in more detail in the next section.</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>As of ES6, there’s a new concept layered on top of the event loop queue, called the “Job queue.” The most likely exposure you’ll have to it is with the asynchronous behavior of Promises (see Chapter 3).</p>
<p>Unfortunately, at the moment it’s a mechanism without an exposed API, and thus demonstrating it is a bit more convoluted. So we’re going to have to just describe it conceptually, such that when we discuss async behavior with Promises in Chapter 3, you’ll understand how those actions are being scheduled and processed.</p>
<p>So, the best way to think about this that I’ve found is that the “Job queue” is a queue hanging off the end of every tick in the event loop queue. Certain async-implied actions that may occur during a tick of the event loop will not cause a whole new event to be added to the event loop queue, but will instead add an item (aka Job) to the end of the current tick’s Job queue.</p>
<p>It’s kinda like saying, “oh, here’s this other thing I need to do <em>later</em>, but make sure it happens right away before anything else can happen.”</p>
<p>Or, to use a metaphor: the event loop queue is like an amusement park ride, where once you finish the ride, you have to go to the back of the line to ride again. But the Job queue is like finishing the ride, but then cutting in line and getting right back on.</p>
<p>A Job can also cause more Jobs to be added to the end of the same queue. So, it’s theoretically possible that a Job “loop” (a Job that keeps adding another Job, etc.) could spin indefinitely, thus starving the program of the ability to move on to the next event loop tick. This would conceptually be almost the same as just expressing a long-running or infinite loop (like <code>while (true) ..</code>) in your code.</p>
<p>Jobs are kind of like the spirit of the <code>setTimeout(..0)</code> hack, but implemented in such a way as to have a much more well-defined and guaranteed ordering: <strong>later, but as soon as possible</strong>.</p>
<p>Let’s imagine an API for scheduling Jobs (directly, without hacks), and call it <code>schedule(..)</code>. Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="string">"A"</span> );</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"B"</span> );</span><br><span class="line">&#125;, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// theoretical "Job API"</span></span><br><span class="line">schedule( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"C"</span> );</span><br><span class="line"></span><br><span class="line">	schedule( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"D"</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>You might expect this to print out <code>A B C D</code>, but instead it would print out <code>A C D B</code>, because the Jobs happen at the end of the current event loop tick, and the timer fires to schedule for the <em>next</em> event loop tick (if available!).</p>
<p>In Chapter 3, we’ll see that the asynchronous behavior of Promises is based on Jobs, so it’s important to keep clear how that relates to event loop behavior.</p>
<h2 id="Statement-Ordering"><a href="#Statement-Ordering" class="headerlink" title="Statement Ordering"></a>Statement Ordering</h2><p>The order in which we express statements in our code is not necessarily the same order as the JS engine will execute them. That may seem like quite a strange assertion to make, so we’ll just briefly explore it.</p>
<p>But before we do, we should be crystal clear on something: the rules/grammar of the language (see the <em>Types &amp; Grammar</em> title of this book series) dictate a very predictable and reliable behavior for statement ordering from the program point of view. So what we’re about to discuss are <strong>not things you should ever be able to observe</strong> in your JS program.</p>
<p><strong>Warning:</strong> If you are ever able to <em>observe</em> compiler statement reordering like we’re about to illustrate, that’d be a clear violation of the specification, and it would unquestionably be due to a bug in the JS engine in question – one which should promptly be reported and fixed! But it’s vastly more common that you <em>suspect</em> something crazy is happening in the JS engine, when in fact it’s just a bug (probably a “race condition”!) in your own code – so look there first, and again and again. The JS debugger, using breakpoints and stepping through code line by line, will be your most powerful tool for sniffing out such bugs in <em>your code</em>.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">b = b + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a + b ); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>This code has no expressed asynchrony to it (other than the rare <code>console</code> async I/O discussed earlier!), so the most likely assumption is that it would process line by line in top-down fashion.</p>
<p>But it’s <em>possible</em> that the JS engine, after compiling this code (yes, JS is compiled – see the <em>Scope &amp; Closures</em> title of this book series!) might find opportunities to run your code faster by rearranging (safely) the order of these statements. Essentially, as long as you can’t observe the reordering, anything’s fair game.</p>
<p>For example, the engine might find it’s faster to actually execute the code like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a++;</span><br><span class="line"></span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line">b++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a + b ); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>Or this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line">b = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a + b ); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>Or even:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// because `a` and `b` aren't used anymore, we can</span></span><br><span class="line"><span class="comment">// inline and don't even need them!</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="number">42</span> ); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>In all these cases, the JS engine is performing safe optimizations during its compilation, as the end <em>observable</em> result will be the same.</p>
<p>But here’s a scenario where these specific optimizations would be unsafe and thus couldn’t be allowed (of course, not to say that it’s not optimized at all):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we need `a` and `b` in their preincremented state!</span></span><br><span class="line"><span class="built_in">console</span>.log( a * b ); <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">b = b + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a + b ); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>Other examples where the compiler reordering could create observable side effects (and thus must be disallowed) would include things like any function call with side effects (even and especially getter functions), or ES6 Proxy objects (see the <em>ES6 &amp; Beyond</em> title of this book series).</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( b );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5.1 getter literal syntax</span></span><br><span class="line">c = &#123;</span><br><span class="line">	get bar() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a );</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">a += foo();				<span class="comment">// 30</span></span><br><span class="line">b += c.bar;				<span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a + b );	<span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>If it weren’t for the <code>console.log(..)</code> statements in this snippet (just used as a convenient form of observable side effect for the illustration), the JS engine would likely have been free, if it wanted to (who knows if it would!?), to reorder the code to:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span> + foo();</span><br><span class="line">b = <span class="number">30</span> + c.bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>While JS semantics thankfully protect us from the <em>observable</em> nightmares that compiler statement reordering would seem to be in danger of, it’s still important to understand just how tenuous a link there is between the way source code is authored (in top-down fashion) and the way it runs after compilation.</p>
<p>Compiler statement reordering is almost a micro-metaphor for concurrency and interaction. As a general concept, such awareness can help you understand async JS code flow issues better.</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>A JavaScript program is (practically) always broken up into two or more chunks, where the first chunk runs <em>now</em> and the next chunk runs <em>later</em>, in response to an event. Even though the program is executed chunk-by-chunk, all of them share the same access to the program scope and state, so each modification to state is made on top of the previous state.</p>
<p>Whenever there are events to run, the <em>event loop</em> runs until the queue is empty. Each iteration of the event loop is a “tick.” User interaction, IO, and timers enqueue events on the event queue.</p>
<p>At any given moment, only one event can be processed from the queue at a time. While an event is executing, it can directly or indirectly cause one or more subsequent events.</p>
<p>Concurrency is when two or more chains of events interleave over time, such that from a high-level perspective, they appear to be running <em>simultaneously</em> (even though at any given moment only one event is being processed).</p>
<p>It’s often necessary to do some form of interaction coordination between these concurrent “processes” (as distinct from operating system processes), for instance to ensure ordering or to prevent “race conditions.” These “processes” can also <em>cooperate</em> by breaking themselves into smaller chunks and to allow other “process” interleaving.</p>
<h1 id="Chapter-2-Callbacks"><a href="#Chapter-2-Callbacks" class="headerlink" title="Chapter 2: Callbacks"></a>Chapter 2: Callbacks</h1><p>In Chapter 1, we explored the terminology and concepts around asynchronous programming in JavaScript. Our focus is on understanding the single-threaded (one-at-a-time) event loop queue that drives all “events” (async function invocations). We also explored various ways that concurrency patterns explain the relationships (if any!) between <em>simultaneously</em> running chains of events, or “processes” (tasks, function calls, etc.).</p>
<p>All our examples in Chapter 1 used the function as the individual, indivisible unit of operations, whereby inside the function, statements run in predictable order (above the compiler level!), but at the function-ordering level, events (aka async function invocations) can happen in a variety of orders.</p>
<p>In all these cases, the function is acting as a “callback,” because it serves as the target for the event loop to “call back into” the program, whenever that item in the queue is processed.</p>
<p>As you no doubt have observed, callbacks are by far the most common way that asynchrony in JS programs is expressed and managed. Indeed, the callback is the most fundamental async pattern in the language.</p>
<p>Countless JS programs, even very sophisticated and complex ones, have been written upon no other async foundation than the callback (with of course the concurrency interaction patterns we explored in Chapter 1). The callback function is the async work horse for JavaScript, and it does its job respectably.</p>
<p>Except… callbacks are not without their shortcomings. Many developers are excited by the <em>promise</em> (pun intended!) of better async patterns. But it’s impossible to effectively use any abstraction if you don’t understand what it’s abstracting, and why.</p>
<p>In this chapter, we will explore a couple of those in depth, as motivation for why more sophisticated async patterns (explored in subsequent chapters of this book) are necessary and desired.</p>
<h2 id="Continuations"><a href="#Continuations" class="headerlink" title="Continuations"></a>Continuations</h2><p>Let’s go back to the async callback example we started with in Chapter 1, but let me slightly modify it to illustrate a point:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">ajax( <span class="string">".."</span>, <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// C</span></span><br><span class="line">&#125; );</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<p><code>// A</code> and <code>// B</code> represent the first half of the program (aka the <em>now</em>), and <code>// C</code> marks the second half of the program (aka the <em>later</em>). The first half executes right away, and then there’s a “pause” of indeterminate length. At some future moment, if the Ajax call completes, then the program will pick up where it left off, and <em>continue</em> with the second half.</p>
<p>In other words, the callback function wraps or encapsulates the <em>continuation</em> of the program.</p>
<p>Let’s make the code even simpler:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// C</span></span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<p>Stop for a moment and ask yourself how you’d describe (to someone else less informed about how JS works) the way that program behaves. Go ahead, try it out loud. It’s a good exercise that will help my next points make more sense.</p>
<p>Most readers just now probably thought or said something to the effect of: “Do A, then set up a timeout to wait 1,000 milliseconds, then once that fires, do C.” How close was your rendition?</p>
<p>You might have caught yourself and self-edited to: “Do A, setup the timeout for 1,000 milliseconds, then do B, then after the timeout fires, do C.” That’s more accurate than the first version. Can you spot the difference?</p>
<p>Even though the second version is more accurate, both versions are deficient in explaining this code in a way that matches our brains to the code, and the code to the JS engine. The disconnect is both subtle and monumental, and is at the very heart of understanding the shortcomings of callbacks as async expression and management.</p>
<p>As soon as we introduce a single continuation (or several dozen as many programs do!) in the form of a callback function, we have allowed a divergence to form between how our brains work and the way the code will operate. Any time these two diverge (and this is by far not the only place that happens, as I’m sure you know!), we run into the inevitable fact that our code becomes harder to understand, reason about, debug, and maintain.</p>
<h2 id="Sequential-Brain"><a href="#Sequential-Brain" class="headerlink" title="Sequential Brain"></a>Sequential Brain</h2><p>I’m pretty sure most of you readers have heard someone say (even made the claim yourself), “I’m a multitasker.” The effects of trying to act as a multitasker range from humorous (e.g., the silly patting-head-rubbing-stomach kids’ game) to mundane (chewing gum while walking) to downright dangerous (texting while driving).</p>
<p>But are we multitaskers? Can we really do two conscious, intentional actions at once and think/reason about both of them at exactly the same moment? Does our highest level of brain functionality have parallel multithreading going on?</p>
<p>The answer may surprise you: <strong>probably not.</strong></p>
<p>That’s just not really how our brains appear to be set up. We’re much more single taskers than many of us (especially A-type personalities!) would like to admit. We can really only think about one thing at any given instant.</p>
<p>I’m not talking about all our involuntary, subconscious, automatic brain functions, such as heart beating, breathing, and eyelid blinking. Those are all vital tasks to our sustained life, but we don’t intentionally allocate any brain power to them. Thankfully, while we obsess about checking social network feeds for the 15th time in three minutes, our brain carries on in the background (threads!) with all those important tasks.</p>
<p>We’re instead talking about whatever task is at the forefront of our minds at the moment. For me, it’s writing the text in this book right now. Am I doing any other higher level brain function at exactly this same moment? Nope, not really. I get distracted quickly and easily – a few dozen times in these last couple of paragraphs!</p>
<p>When we <em>fake</em> multitasking, such as trying to type something at the same time we’re talking to a friend or family member on the phone, what we’re actually most likely doing is acting as fast context switchers. In other words, we switch back and forth between two or more tasks in rapid succession, <em>simultaneously</em> progressing on each task in tiny, fast little chunks. We do it so fast that to the outside world it appears as if we’re doing these things <em>in parallel</em>.</p>
<p>Does that sound suspiciously like async evented concurrency (like the sort that happens in JS) to you?! If not, go back and read Chapter 1 again!</p>
<p>In fact, one way of simplifying (i.e., abusing) the massively complex world of neurology into something I can remotely hope to discuss here is that our brains work kinda like the event loop queue.</p>
<p>If you think about every single letter (or word) I type as a single async event, in just this sentence alone there are several dozen opportunities for my brain to be interrupted by some other event, such as from my senses, or even just my random thoughts.</p>
<p>I don’t get interrupted and pulled to another “process” at every opportunity that I could be (thankfully – or this book would never be written!). But it happens often enough that I feel my own brain is nearly constantly switching to various different contexts (aka “processes”). And that’s an awful lot like how the JS engine would probably feel.</p>
<h3 id="Doing-Versus-Planning"><a href="#Doing-Versus-Planning" class="headerlink" title="Doing Versus Planning"></a>Doing Versus Planning</h3><p>OK, so our brains can be thought of as operating in single-threaded event loop queue like ways, as can the JS engine. That sounds like a good match.</p>
<p>But we need to be more nuanced than that in our analysis. There’s a big, observable difference between how we plan various tasks, and how our brains actually operate those tasks.</p>
<p>Again, back to the writing of this text as my metaphor. My rough mental outline plan here is to keep writing and writing, going sequentially through a set of points I have ordered in my thoughts. I don’t plan to have any interruptions or nonlinear activity in this writing. But yet, my brain is nevertheless switching around all the time.</p>
<p>Even though at an operational level our brains are async evented, we seem to plan out tasks in a sequential, synchronous way. “I need to go to the store, then buy some milk, then drop off my dry cleaning.”</p>
<p>You’ll notice that this higher level thinking (planning) doesn’t seem very async evented in its formulation. In fact, it’s kind of rare for us to deliberately think solely in terms of events. Instead, we plan things out carefully, sequentially (A then B then C), and we assume to an extent a sort of temporal blocking that forces B to wait on A, and C to wait on B.</p>
<p>When a developer writes code, they are planning out a set of actions to occur. If they’re any good at being a developer, they’re <strong>carefully planning</strong> it out. “I need to set <code>z</code> to the value of <code>x</code>, and then <code>x</code> to the value of <code>y</code>,” and so forth.</p>
<p>When we write out synchronous code, statement by statement, it works a lot like our errands to-do list:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap `x` and `y` (via temp variable `z`)</span></span><br><span class="line">z = x;</span><br><span class="line">x = y;</span><br><span class="line">y = z;</span><br></pre></td></tr></table></figure>
<p>These three assignment statements are synchronous, so <code>x = y</code> waits for <code>z = x</code> to finish, and <code>y = z</code> in turn waits for <code>x = y</code> to finish. Another way of saying it is that these three statements are temporally bound to execute in a certain order, one right after the other. Thankfully, we don’t need to be bothered with any async evented details here. If we did, the code gets a lot more complex, quickly!</p>
<p>So if synchronous brain planning maps well to synchronous code statements, how well do our brains do at planning out asynchronous code?</p>
<p>It turns out that how we express asynchrony (with callbacks) in our code doesn’t map very well at all to that synchronous brain planning behavior.</p>
<p>Can you actually imagine having a line of thinking that plans out your to-do errands like this?</p>
<blockquote>
<p>“I need to go to the store, but on the way I’m sure I’ll get a phone call, so ‘Hi, Mom’, and while she starts talking, I’ll be looking up the store address on GPS, but that’ll take a second to load, so I’ll turn down the radio so I can hear Mom better, then I’ll realize I forgot to put on a jacket and it’s cold outside, but no matter, keep driving and talking to Mom, and then the seatbelt ding reminds me to buckle up, so ‘Yes, Mom, I am wearing my seatbelt, I always do!’. Ah, finally the GPS got the directions, now…”</p>
</blockquote>
<p>As ridiculous as that sounds as a formulation for how we plan our day out and think about what to do and in what order, nonetheless it’s exactly how our brains operate at a functional level. Remember, that’s not multitasking, it’s just fast context switching.</p>
<p>The reason it’s difficult for us as developers to write async evented code, especially when all we have is the callback to do it, is that stream of consciousness thinking/planning is unnatural for most of us.</p>
<p>We think in step-by-step terms, but the tools (callbacks) available to us in code are not expressed in a step-by-step fashion once we move from synchronous to asynchronous.</p>
<p>And <strong>that</strong> is why it’s so hard to accurately author and reason about async JS code with callbacks: because it’s not how our brain planning works.</p>
<p><strong>Note:</strong> The only thing worse than not knowing why some code breaks is not knowing why it worked in the first place! It’s the classic “house of cards” mentality: “it works, but not sure why, so nobody touch it!” You may have heard, “Hell is other people” (Sartre), and the programmer meme twist, “Hell is other people’s code.” I believe truly: “Hell is not understanding my own code.” And callbacks are one main culprit.</p>
<h3 id="Nested-Chained-Callbacks"><a href="#Nested-Chained-Callbacks" class="headerlink" title="Nested/Chained Callbacks"></a>Nested/Chained Callbacks</h3><p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listen( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		ajax( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">				handler();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">				request();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125;, <span class="number">500</span>) ;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>There’s a good chance code like that is recognizable to you. We’ve got a chain of three functions nested together, each one representing a step in an asynchronous series (task, “process”).</p>
<p>This kind of code is often called “callback hell,” and sometimes also referred to as the “pyramid of doom” (for its sideways-facing triangular shape due to the nested indentation).</p>
<p>But “callback hell” actually has almost nothing to do with the nesting/indentation. It’s a far deeper problem than that. We’ll see how and why as we continue through the rest of this chapter.</p>
<p>First, we’re waiting for the “click” event, then we’re waiting for the timer to fire, then we’re waiting for the Ajax response to come back, at which point it might do it all again.</p>
<p>At first glance, this code may seem to map its asynchrony naturally to sequential brain planning.</p>
<p>First (<em>now</em>), we:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen( <span class="string">".."</span>, <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Then <em>later</em>, we:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;, <span class="number">500</span>) ;</span><br></pre></td></tr></table></figure>
<p>Then still <em>later</em>, we:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax( <span class="string">".."</span>, <span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>And finally (most <em>later</em>), we:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( .. ) &#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ..</span><br></pre></td></tr></table></figure>
<p>But there’s several problems with reasoning about this code linearly in such a fashion.</p>
<p>First, it’s an accident of the example that our steps are on subsequent lines (1, 2, 3, and 4…). In real async JS programs, there’s often a lot more noise cluttering things up, noise that we have to deftly maneuver past in our brains as we jump from one function to the next. Understanding the async flow in such callback-laden code is not impossible, but it’s certainly not natural or easy, even with lots of practice.</p>
<p>But also, there’s something deeper wrong, which isn’t evident just in that code example. Let me make up another scenario (pseudocode-ish) to illustrate it:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doA( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	doB();</span><br><span class="line"></span><br><span class="line">	doC( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		doD();</span><br><span class="line">	&#125; )</span><br><span class="line"></span><br><span class="line">	doE();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">doF();</span><br></pre></td></tr></table></figure>
<p>While the experienced among you will correctly identify the true order of operations here, I’m betting it is more than a little confusing at first glance, and takes some concerted mental cycles to arrive at. The operations will happen in this order:</p>
<ul>
<li><code>doA()</code></li>
<li><code>doF()</code></li>
<li><code>doB()</code></li>
<li><code>doC()</code></li>
<li><code>doE()</code></li>
<li><code>doD()</code></li>
</ul>
<p>Did you get that right the very first time you glanced at the code?</p>
<p>OK, some of you are thinking I was unfair in my function naming, to intentionally lead you astray. I swear I was just naming in top-down appearance order. But let me try again:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doA( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	doC();</span><br><span class="line"></span><br><span class="line">	doD( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		doF();</span><br><span class="line">	&#125; )</span><br><span class="line"></span><br><span class="line">	doE();</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">doB();</span><br></pre></td></tr></table></figure>
<p>Now, I’ve named them alphabetically in order of actual execution. But I still bet, even with experience now in this scenario, tracing through the <code>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F</code> order doesn’t come natural to many if any of you readers. Certainly, your eyes do an awful lot of jumping up and down the code snippet, right?</p>
<p>But even if that all comes natural to you, there’s still one more hazard that could wreak havoc. Can you spot what it is?</p>
<p>What if <code>doA(..)</code> or <code>doD(..)</code> aren’t actually async, the way we obviously assumed them to be? Uh oh, now the order is different. If they’re both sync (and maybe only sometimes, depending on the conditions of the program at the time), the order is now <code>A -&gt; C -&gt; D -&gt; F -&gt; E -&gt; B</code>.</p>
<p>That sound you just heard faintly in the background is the sighs of thousands of JS developers who just had a face-in-hands moment.</p>
<p>Is nesting the problem? Is that what makes it so hard to trace the async flow? That’s part of it, certainly.</p>
<p>But let me rewrite the previous nested event/timeout/Ajax example without using nesting:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">listen( <span class="string">"click"</span>, handler );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	setTimeout( request, <span class="number">500</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	ajax( <span class="string">"http://some.url.1"</span>, response );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (text == <span class="string">"hello"</span>) &#123;</span><br><span class="line">		handler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (text == <span class="string">"world"</span>) &#123;</span><br><span class="line">		request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This formulation of the code is not hardly as recognizable as having the nesting/indentation woes of its previous form, and yet it’s every bit as susceptible to “callback hell.” Why?</p>
<p>As we go to linearly (sequentially) reason about this code, we have to skip from one function, to the next, to the next, and bounce all around the code base to “see” the sequence flow. And remember, this is simplified code in sort of best-case fashion. We all know that real async JS program code bases are often fantastically more jumbled, which makes such reasoning orders of magnitude more difficult.</p>
<p>Another thing to notice: to get steps 2, 3, and 4 linked together so they happen in succession, the only affordance callbacks alone gives us is to hardcode step 2 into step 1, step 3 into step 2, step 4 into step 3, and so on. The hardcoding isn’t necessarily a bad thing, if it really is a fixed condition that step 2 should always lead to step 3.</p>
<p>But the hardcoding definitely makes the code a bit more brittle, as it doesn’t account for anything going wrong that might cause a deviation in the progression of steps. For example, if step 2 fails, step 3 never gets reached, nor does step 2 retry, or move to an alternate error handling flow, and so on.</p>
<p>All of these issues are things you <em>can</em> manually hardcode into each step, but that code is often very repetitive and not reusable in other steps or in other async flows in your program.</p>
<p>Even though our brains might plan out a series of tasks in a sequential type of way (this, then this, then this), the evented nature of our brain operation makes recovery/retry/forking of flow control almost effortless. If you’re out running errands, and you realize you left a shopping list at home, it doesn’t end the day because you didn’t plan that ahead of time. Your brain routes around this hiccup easily: you go home, get the list, then head right back out to the store.</p>
<p>But the brittle nature of manually hardcoded callbacks (even with hardcoded error handling) is often far less graceful. Once you end up specifying (aka pre-planning) all the various eventualities/paths, the code becomes so convoluted that it’s hard to ever maintain or update it.</p>
<p><strong>That</strong> is what “callback hell” is all about! The nesting/indentation are basically a side show, a red herring.</p>
<p>And as if all that’s not enough, we haven’t even touched what happens when two or more chains of these callback continuations are happening <em>simultaneously</em>, or when the third step branches out into “parallel” callbacks with gates or latches, or… OMG, my brain hurts, how about yours!?</p>
<p>Are you catching the notion here that our sequential, blocking brain planning behaviors just don’t map well onto callback-oriented async code? That’s the first major deficiency to articulate about callbacks: they express asynchrony in code in ways our brains have to fight just to keep in sync with (pun intended!).</p>
<h2 id="Trust-Issues"><a href="#Trust-Issues" class="headerlink" title="Trust Issues"></a>Trust Issues</h2><p>The mismatch between sequential brain planning and callback-driven async JS code is only part of the problem with callbacks. There’s something much deeper to be concerned about.</p>
<p>Let’s once again revisit the notion of a callback function as the continuation (aka the second half) of our program:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">ajax( <span class="string">".."</span>, <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// C</span></span><br><span class="line">&#125; );</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure>
<p><code>// A</code> and <code>// B</code> happen <em>now</em>, under the direct control of the main JS program. But <code>// C</code> gets deferred to happen <em>later</em>, and under the control of another party – in this case, the <code>ajax(..)</code> function. In a basic sense, that sort of hand-off of control doesn’t regularly cause lots of problems for programs.</p>
<p>But don’t be fooled by its infrequency that this control switch isn’t a big deal. In fact, it’s one of the worst (and yet most subtle) problems about callback-driven design. It revolves around the idea that sometimes <code>ajax(..)</code> (i.e., the “party” you hand your callback continuation to) is not a function that you wrote, or that you directly control. Many times, it’s a utility provided by some third party.</p>
<p>We call this “inversion of control,” when you take part of your program and give over control of its execution to another third party. There’s an unspoken “contract” that exists between your code and the third-party utility – a set of things you expect to be maintained.</p>
<h3 id="Tale-of-Five-Callbacks"><a href="#Tale-of-Five-Callbacks" class="headerlink" title="Tale of Five Callbacks"></a>Tale of Five Callbacks</h3><p>It might not be terribly obvious why this is such a big deal. Let me construct an exaggerated scenario to illustrate the hazards of trust at play.</p>
<p>Imagine you’re a developer tasked with building out an ecommerce checkout system for a site that sells expensive TVs. You already have all the various pages of the checkout system built out just fine. On the last page, when the user clicks “confirm” to buy the TV, you need to call a third-party function (provided say by some analytics tracking company) so that the sale can be tracked.</p>
<p>You notice that they’ve provided what looks like an async tracking utility, probably for the sake of performance best practices, which means you need to pass in a callback function. In this continuation that you pass in, you will have the final code that charges the customer’s credit card and displays the thank you page.</p>
<p>This code might look like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">analytics.trackPurchase( purchaseData, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	chargeCreditCard();</span><br><span class="line">	displayThankyouPage();</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Easy enough, right? You write the code, test it, everything works, and you deploy to production. Everyone’s happy!</p>
<p>Six months go by and no issues. You’ve almost forgotten you even wrote that code. One morning, you’re at a coffee shop before work, casually enjoying your latte, when you get a panicked call from your boss insisting you drop the coffee and rush into work right away.</p>
<p>When you arrive, you find out that a high-profile customer has had his credit card charged five times for the same TV, and he’s understandably upset. Customer service has already issued an apology and processed a refund. But your boss demands to know how this could possibly have happened. “Don’t we have tests for stuff like this!?”</p>
<p>You don’t even remember the code you wrote. But you dig back in and start trying to find out what could have gone awry.</p>
<p>After digging through some logs, you come to the conclusion that the only explanation is that the analytics utility somehow, for some reason, called your callback five times instead of once. Nothing in their documentation mentions anything about this.</p>
<p>Frustrated, you contact customer support, who of course is as astonished as you are. They agree to escalate it to their developers, and promise to get back to you. The next day, you receive a lengthy email explaining what they found, which you promptly forward to your boss.</p>
<p>Apparently, the developers at the analytics company had been working on some experimental code that, under certain conditions, would retry the provided callback once per second, for five seconds, before failing with a timeout. They had never intended to push that into production, but somehow they did, and they’re totally embarrassed and apologetic. They go into plenty of detail about how they’ve identified the breakdown and what they’ll do to ensure it never happens again. Yadda, yadda.</p>
<p>What’s next?</p>
<p>You talk it over with your boss, but he’s not feeling particularly comfortable with the state of things. He insists, and you reluctantly agree, that you can’t trust <em>them</em> anymore (that’s what bit you), and that you’ll need to figure out how to protect the checkout code from such a vulnerability again.</p>
<p>After some tinkering, you implement some simple ad hoc code like the following, which the team seems happy with:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tracked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">analytics.trackPurchase( purchaseData, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tracked) &#123;</span><br><span class="line">		tracked = <span class="literal">true</span>;</span><br><span class="line">		chargeCreditCard();</span><br><span class="line">		displayThankyouPage();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> This should look familiar to you from Chapter 1, because we’re essentially creating a latch to handle if there happen to be multiple concurrent invocations of our callback.</p>
<p>But then one of your QA engineers asks, “what happens if they never call the callback?” Oops. Neither of you had thought about that.</p>
<p>You begin to chase down the rabbit hole, and think of all the possible things that could go wrong with them calling your callback. Here’s roughly the list you come up with of ways the analytics utility could misbehave:</p>
<ul>
<li>Call the callback too early (before it’s been tracked)</li>
<li>Call the callback too late (or never)</li>
<li>Call the callback too few or too many times (like the problem you encountered!)</li>
<li>Fail to pass along any necessary environment/parameters to your callback</li>
<li>Swallow any errors/exceptions that may happen</li>
<li>…</li>
</ul>
<p>That should feel like a troubling list, because it is. You’re probably slowly starting to realize that you’re going to have to invent an awful lot of ad hoc logic <strong>in each and every single callback</strong> that’s passed to a utility you’re not positive you can trust.</p>
<p>Now you realize a bit more completely just how hellish “callback hell” is.</p>
<h3 id="Not-Just-Others’-Code"><a href="#Not-Just-Others’-Code" class="headerlink" title="Not Just Others’ Code"></a>Not Just Others’ Code</h3><p>Some of you may be skeptical at this point whether this is as big a deal as I’m making it out to be. Perhaps you don’t interact with truly third-party utilities much if at all. Perhaps you use versioned APIs or self-host such libraries, so that its behavior can’t be changed out from underneath you.</p>
<p>So, contemplate this: can you even <em>really</em> trust utilities that you do theoretically control (in your own code base)?</p>
<p>Think of it this way: most of us agree that at least to some extent we should build our own internal functions with some defensive checks on the input parameters, to reduce/prevent unexpected issues.</p>
<p>Overly trusting of input:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// + is overloaded with coercion to also be</span></span><br><span class="line">	<span class="comment">// string concatenation, so this operation</span></span><br><span class="line">	<span class="comment">// isn't strictly safe depending on what's</span></span><br><span class="line">	<span class="comment">// passed in.</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addNumbers( <span class="number">21</span>, <span class="number">21</span> );	<span class="comment">// 42</span></span><br><span class="line">addNumbers( <span class="number">21</span>, <span class="string">"21"</span> );	<span class="comment">// "2121"</span></span><br></pre></td></tr></table></figure></p>
<p>Defensive against untrusted input:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ensure numerical input</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> x != <span class="string">"number"</span> || <span class="keyword">typeof</span> y != <span class="string">"number"</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">Error</span>( <span class="string">"Bad parameters"</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if we get here, + will safely do numeric addition</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addNumbers( <span class="number">21</span>, <span class="number">21</span> );	<span class="comment">// 42</span></span><br><span class="line">addNumbers( <span class="number">21</span>, <span class="string">"21"</span> );	<span class="comment">// Error: "Bad parameters"</span></span><br></pre></td></tr></table></figure></p>
<p>Or perhaps still safe but friendlier:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ensure numerical input</span></span><br><span class="line">	x = <span class="built_in">Number</span>( x );</span><br><span class="line">	y = <span class="built_in">Number</span>( y );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// + will safely do numeric addition</span></span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addNumbers( <span class="number">21</span>, <span class="number">21</span> );	<span class="comment">// 42</span></span><br><span class="line">addNumbers( <span class="number">21</span>, <span class="string">"21"</span> );	<span class="comment">// 42</span></span><br></pre></td></tr></table></figure></p>
<p>However you go about it, these sorts of checks/normalizations are fairly common on function inputs, even with code we theoretically entirely trust. In a crude sort of way, it’s like the programming equivalent of the geopolitical principle of “Trust But Verify.”</p>
<p>So, doesn’t it stand to reason that we should do the same thing about composition of async function callbacks, not just with truly external code but even with code we know is generally “under our own control”? <strong>Of course we should.</strong></p>
<p>But callbacks don’t really offer anything to assist us. We have to construct all that machinery ourselves, and it often ends up being a lot of boilerplate/overhead that we repeat for every single async callback.</p>
<p>The most troublesome problem with callbacks is <em>inversion of control</em> leading to a complete breakdown along all those trust lines.</p>
<p>If you have code that uses callbacks, especially but not exclusively with third-party utilities, and you’re not already applying some sort of mitigation logic for all these <em>inversion of control</em> trust issues, your code <em>has</em> bugs in it right now even though they may not have bitten you yet. Latent bugs are still bugs.</p>
<p>Hell indeed.</p>
<h2 id="Trying-to-Save-Callbacks"><a href="#Trying-to-Save-Callbacks" class="headerlink" title="Trying to Save Callbacks"></a>Trying to Save Callbacks</h2><p>There are several variations of callback design that have attempted to address some (not all!) of the trust issues we’ve just looked at. It’s a valiant, but doomed, effort to save the callback pattern from imploding on itself.</p>
<p>For example, regarding more graceful error handling, some API designs provide for split callbacks (one for the success notification, one for the error notification):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( data );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">failure</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.error( err );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, success, failure );</span><br></pre></td></tr></table></figure>
<p>In APIs of this design, often the <code>failure()</code> error handler is optional, and if not provided it will be assumed you want the errors swallowed. Ugh.</p>
<p><strong>Note:</strong> This split-callback design is what the ES6 Promise API uses. We’ll cover ES6 Promises in much more detail in the next chapter.</p>
<p>Another common callback pattern is called “error-first style” (sometimes called “Node style,” as it’s also the convention used across nearly all Node.js APIs), where the first argument of a single callback is reserved for an error object (if any). If success, this argument will be empty/falsy (and any subsequent arguments will be the success data), but if an error result is being signaled, the first argument is set/truthy (and usually nothing else is passed):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// error?</span></span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// otherwise, assume success</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( data );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, response );</span><br></pre></td></tr></table></figure>
<p>In both of these cases, several things should be observed.</p>
<p>First, it has not really resolved the majority of trust issues like it may appear. There’s nothing about either callback that prevents or filters unwanted repeated invocations. Moreover, things are worse now, because you may get both success and error signals, or neither, and you still have to code around either of those conditions.</p>
<p>Also, don’t miss the fact that while it’s a standard pattern you can employ, it’s definitely more verbose and boilerplate-ish without much reuse, so you’re going to get weary of typing all that out for every single callback in your application.</p>
<p>What about the trust issue of never being called? If this is a concern (and it probably should be!), you likely will need to set up a timeout that cancels the event. You could make a utility (proof-of-concept only shown) to help you with that:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutify</span>(<span class="params">fn,delay</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> intv = setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			intv = <span class="literal">null</span>;</span><br><span class="line">			fn( <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">"Timeout!"</span> ) );</span><br><span class="line">		&#125;, delay )</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// timeout hasn't happened yet?</span></span><br><span class="line">		<span class="keyword">if</span> (intv) &#123;</span><br><span class="line">			clearTimeout( intv );</span><br><span class="line">			fn.apply( <span class="keyword">this</span>, [ <span class="literal">null</span> ].concat( [].slice.call( <span class="built_in">arguments</span> ) ) );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here’s how you use it:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using "error-first style" callback design</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( data );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax( <span class="string">"http://some.url.1"</span>, timeoutify( foo, <span class="number">500</span> ) );</span><br></pre></td></tr></table></figure>
<p>Another trust issue is being called “too early.” In application-specific terms, this may actually involve being called before some critical task is complete. But more generally, the problem is evident in utilities that can either invoke the callback you provide <em>now</em> (synchronously), or <em>later</em> (asynchronously).</p>
<p>This nondeterminism around the sync-or-async behavior is almost always going to lead to very difficult to track down bugs. In some circles, the fictional insanity-inducing monster named Zalgo is used to describe the sync/async nightmares. “Don’t release Zalgo!” is a common cry, and it leads to very sound advice: always invoke callbacks asynchronously, even if that’s “right away” on the next turn of the event loop, so that all callbacks are predictably async.</p>
<p><strong>Note:</strong> For more information on Zalgo, see Oren Golan’s “Don’t Release Zalgo!” (<a href="https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md" target="_blank" rel="noopener">https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md</a>) and Isaac Z. Schlueter’s “Designing APIs for Asynchrony” (<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)" target="_blank" rel="noopener">http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)</a>.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ajax( <span class="string">"..pre-cached-url.."</span>, result );</span><br><span class="line">a++;</span><br></pre></td></tr></table></figure>
<p>Will this code print <code>0</code> (sync callback invocation) or <code>1</code> (async callback invocation)? Depends… on the conditions.</p>
<p>You can see just how quickly the unpredictability of Zalgo can threaten any JS program. So the silly-sounding “never release Zalgo” is actually incredibly common and solid advice. Always be asyncing.</p>
<p>What if you don’t know whether the API in question will always execute async? You could invent a utility like this <code>asyncify(..)</code> proof-of-concept:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> orig_fn = fn,</span><br><span class="line">		intv = setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			intv = <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (fn) fn();</span><br><span class="line">		&#125;, <span class="number">0</span> )</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">	fn = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// firing too quickly, before `intv` timer has fired to</span></span><br><span class="line">		<span class="comment">// indicate async turn has passed?</span></span><br><span class="line">		<span class="keyword">if</span> (intv) &#123;</span><br><span class="line">			fn = orig_fn.bind.apply(</span><br><span class="line">				orig_fn,</span><br><span class="line">				<span class="comment">// add the wrapper's `this` to the `bind(..)`</span></span><br><span class="line">				<span class="comment">// call parameters, as well as currying any</span></span><br><span class="line">				<span class="comment">// passed in parameters</span></span><br><span class="line">				[<span class="keyword">this</span>].concat( [].slice.call( <span class="built_in">arguments</span> ) )</span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// already async</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// invoke original function</span></span><br><span class="line">			orig_fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You use <code>asyncify(..)</code> like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ajax( <span class="string">"..pre-cached-url.."</span>, asyncify( result ) );</span><br><span class="line">a++;</span><br></pre></td></tr></table></figure>
<p>Whether the Ajax request is in the cache and resolves to try to call the callback right away, or must be fetched over the wire and thus complete later asynchronously, this code will always output <code>1</code> instead of <code>0</code> – <code>result(..)</code> cannot help but be invoked asynchronously, which means the <code>a++</code> has a chance to run before <code>result(..)</code> does.</p>
<p>Yay, another trust issued “solved”! But it’s inefficient, and yet again more bloated boilerplate to weigh your project down.</p>
<p>That’s just the story, over and over again, with callbacks. They can do pretty much anything you want, but you have to be willing to work hard to get it, and oftentimes this effort is much more than you can or should spend on such code reasoning.</p>
<p>You might find yourself wishing for built-in APIs or other language mechanics to address these issues. Finally ES6 has arrived on the scene with some great answers, so keep reading!</p>
<h2 id="Review-1"><a href="#Review-1" class="headerlink" title="Review"></a>Review</h2><p>Callbacks are the fundamental unit of asynchrony in JS. But they’re not enough for the evolving landscape of async programming as JS matures.</p>
<p>First, our brains plan things out in sequential, blocking, single-threaded semantic ways, but callbacks express asynchronous flow in a rather nonlinear, nonsequential way, which makes reasoning properly about such code much harder. Bad to reason about code is bad code that leads to bad bugs.</p>
<p>We need a way to express asynchrony in a more synchronous, sequential, blocking manner, just like our brains do.</p>
<p>Second, and more importantly, callbacks suffer from <em>inversion of control</em> in that they implicitly give control over to another party (often a third-party utility not in your control!) to invoke the <em>continuation</em> of your program. This control transfer leads us to a troubling list of trust issues, such as whether the callback is called more times than we expect.</p>
<p>Inventing ad hoc logic to solve these trust issues is possible, but it’s more difficult than it should be, and it produces clunkier and harder to maintain code, as well as code that is likely insufficiently protected from these hazards until you get visibly bitten by the bugs.</p>
<p>We need a generalized solution to <strong>all of the trust issues</strong>, one that can be reused for as many callbacks as we create without all the extra boilerplate overhead.</p>
<p>We need something better than callbacks. They’ve served us well to this point, but the <em>future</em> of JavaScript demands more sophisticated and capable async patterns. The subsequent chapters in this book will dive into those emerging evolutions.</p>
<h1 id="Chapter-3-Promises"><a href="#Chapter-3-Promises" class="headerlink" title="Chapter 3: Promises"></a>Chapter 3: Promises</h1><p>In Chapter 2, we identified two major categories of deficiencies with using callbacks to express program asynchrony and manage concurrency: lack of sequentiality and lack of trustability. Now that we understand the problems more intimately, it’s time we turn our attention to patterns that can address them.</p>
<p>The issue we want to address first is the <em>inversion of control</em>, the trust that is so fragilely held and so easily lost.</p>
<p>Recall that we wrap up the <em>continuation</em> of our program in a callback function, and hand that callback over to another party (potentially even external code) and just cross our fingers that it will do the right thing with the invocation of the callback.</p>
<p>We do this because we want to say, “here’s what happens <em>later</em>, after the current step finishes.”</p>
<p>But what if we could uninvert that <em>inversion of control</em>? What if instead of handing the continuation of our program to another party, we could expect it to return us a capability to know when its task finishes, and then our code could decide what to do next?</p>
<p>This paradigm is called <strong>Promises</strong>.</p>
<p>Promises are starting to take the JS world by storm, as developers and specification writers alike desperately seek to untangle the insanity of callback hell in their code/design. In fact, most new async APIs being added to JS/DOM platform are being built on Promises. So it’s probably a good idea to dig in and learn them, don’t you think!?</p>
<p><strong>Note:</strong> The word “immediately” will be used frequently in this chapter, generally to refer to some Promise resolution action. However, in essentially all cases, “immediately” means in terms of the Job queue behavior (see Chapter 1), not in the strictly synchronous <em>now</em> sense.</p>
<h2 id="What-Is-a-Promise"><a href="#What-Is-a-Promise" class="headerlink" title="What Is a Promise?"></a>What Is a Promise?</h2><p>When developers decide to learn a new technology or pattern, usually their first step is “Show me the code!” It’s quite natural for us to just jump in feet first and learn as we go.</p>
<p>But it turns out that some abstractions get lost on the APIs alone. Promises are one of those tools where it can be painfully obvious from how someone uses it whether they understand what it’s for and about versus just learning and using the API.</p>
<p>So before I show the Promise code, I want to fully explain what a Promise really is conceptually. I hope this will then guide you better as you explore integrating Promise theory into your own async flow.</p>
<p>With that in mind, let’s look at two different analogies for what a Promise <em>is</em>.</p>
<h3 id="Future-Value"><a href="#Future-Value" class="headerlink" title="Future Value"></a>Future Value</h3><p>Imagine this scenario: I walk up to the counter at a fast-food restaurant, and place an order for a cheeseburger. I hand the cashier $1.47. By placing my order and paying for it, I’ve made a request for a <em>value</em> back (the cheeseburger). I’ve started a transaction.</p>
<p>But often, the cheeseburger is not immediately available for me. The cashier hands me something in place of my cheeseburger: a receipt with an order number on it. This order number is an IOU (“I owe you”) <em>promise</em> that ensures that eventually, I should receive my cheeseburger.</p>
<p>So I hold onto my receipt and order number. I know it represents my <em>future cheeseburger</em>, so I don’t need to worry about it anymore – aside from being hungry!</p>
<p>While I wait, I can do other things, like send a text message to a friend that says, “Hey, can you come join me for lunch? I’m going to eat a cheeseburger.”</p>
<p>I am reasoning about my <em>future cheeseburger</em> already, even though I don’t have it in my hands yet. My brain is able to do this because it’s treating the order number as a placeholder for the cheeseburger. The placeholder essentially makes the value <em>time independent</em>. It’s a <strong>future value</strong>.</p>
<p>Eventually, I hear, “Order 113!” and I gleefully walk back up to the counter with receipt in hand. I hand my receipt to the cashier, and I take my cheeseburger in return.</p>
<p>In other words, once my <em>future value</em> was ready, I exchanged my value-promise for the value itself.</p>
<p>But there’s another possible outcome. They call my order number, but when I go to retrieve my cheeseburger, the cashier regretfully informs me, “I’m sorry, but we appear to be all out of cheeseburgers.” Setting aside the customer frustration of this scenario for a moment, we can see an important characteristic of <em>future values</em>: they can either indicate a success or failure.</p>
<p>Every time I order a cheeseburger, I know that I’ll either get a cheeseburger eventually, or I’ll get the sad news of the cheeseburger shortage, and I’ll have to figure out something else to eat for lunch.</p>
<p><strong>Note:</strong> In code, things are not quite as simple, because metaphorically the order number may never be called, in which case we’re left indefinitely in an unresolved state. We’ll come back to dealing with that case later.</p>
<h4 id="Values-Now-and-Later"><a href="#Values-Now-and-Later" class="headerlink" title="Values Now and Later"></a>Values Now and Later</h4><p>This all might sound too mentally abstract to apply to your code. So let’s be more concrete.</p>
<p>However, before we can introduce how Promises work in this fashion, we’re going to derive in code that we already understand – callbacks! – how to handle these <em>future values</em>.</p>
<p>When you write code to reason about a value, such as performing math on a <code>number</code>, whether you realize it or not, you’ve been assuming something very fundamental about that value, which is that it’s a concrete <em>now</em> value already:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( x + y ); <span class="comment">// NaN  &lt;-- because `x` isn't set yet</span></span><br></pre></td></tr></table></figure>
<p>The <code>x + y</code> operation assumes both <code>x</code> and <code>y</code> are already set. In terms we’ll expound on shortly, we assume the <code>x</code> and <code>y</code> values are already <em>resolved</em>.</p>
<p>It would be nonsense to expect that the <code>+</code> operator by itself would somehow be magically capable of detecting and waiting around until both <code>x</code> and <code>y</code> are resolved (aka ready), only then to do the operation. That would cause chaos in the program if different statements finished <em>now</em> and others finished <em>later</em>, right?</p>
<p>How could you possibly reason about the relationships between two statements if either one (or both) of them might not be finished yet? If statement 2 relies on statement 1 being finished, there are just two outcomes: either statement 1 finished right <em>now</em> and everything proceeds fine, or statement 1 didn’t finish yet, and thus statement 2 is going to fail.</p>
<p>If this sort of thing sounds familiar from Chapter 1, good!</p>
<p>Let’s go back to our <code>x + y</code> math operation. Imagine if there was a way to say, “Add <code>x</code> and <code>y</code>, but if either of them isn’t ready yet, just wait until they are. Add them as soon as you can.”</p>
<p>Your brain might have just jumped to callbacks. OK, so…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">getX,getY,cb</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x, y;</span><br><span class="line">	getX( <span class="function"><span class="keyword">function</span>(<span class="params">xVal</span>)</span>&#123;</span><br><span class="line">		x = xVal;</span><br><span class="line">		<span class="comment">// both are ready?</span></span><br><span class="line">		<span class="keyword">if</span> (y != <span class="literal">undefined</span>) &#123;</span><br><span class="line">			cb( x + y );	<span class="comment">// send along sum</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; );</span><br><span class="line">	getY( <span class="function"><span class="keyword">function</span>(<span class="params">yVal</span>)</span>&#123;</span><br><span class="line">		y = yVal;</span><br><span class="line">		<span class="comment">// both are ready?</span></span><br><span class="line">		<span class="keyword">if</span> (x != <span class="literal">undefined</span>) &#123;</span><br><span class="line">			cb( x + y );	<span class="comment">// send along sum</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `fetchX()` and `fetchY()` are sync or async</span></span><br><span class="line"><span class="comment">// functions</span></span><br><span class="line">add( fetchX, fetchY, <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( sum ); <span class="comment">// that was easy, huh?</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Take just a moment to let the beauty (or lack thereof) of that snippet sink in (whistles patiently).</p>
<p>While the ugliness is undeniable, there’s something very important to notice about this async pattern.</p>
<p>In that snippet, we treated <code>x</code> and <code>y</code> as future values, and we express an operation <code>add(..)</code> that (from the outside) does not care whether <code>x</code> or <code>y</code> or both are available right away or not. In other words, it normalizes the <em>now</em> and <em>later</em>, such that we can rely on a predictable outcome of the <code>add(..)</code> operation.</p>
<p>By using an <code>add(..)</code> that is temporally consistent – it behaves the same across <em>now</em> and <em>later</em> times – the async code is much easier to reason about.</p>
<p>To put it more plainly: to consistently handle both <em>now</em> and <em>later</em>, we make both of them <em>later</em>: all operations become async.</p>
<p>Of course, this rough callbacks-based approach leaves much to be desired. It’s just a first tiny step toward realizing the benefits of reasoning about <em>future values</em> without worrying about the time aspect of when it’s available or not.</p>
<h4 id="Promise-Value"><a href="#Promise-Value" class="headerlink" title="Promise Value"></a>Promise Value</h4><p>We’ll definitely go into a lot more detail about Promises later in the chapter – so don’t worry if some of this is confusing – but let’s just briefly glimpse at how we can express the <code>x + y</code> example via <code>Promise</code>s:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">xPromise,yPromise</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// `Promise.all([ .. ])` takes an array of promises,</span></span><br><span class="line">	<span class="comment">// and returns a new promise that waits on them</span></span><br><span class="line">	<span class="comment">// all to finish</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.all( [xPromise, yPromise] )</span><br><span class="line"></span><br><span class="line">	<span class="comment">// when that promise is resolved, let's take the</span></span><br><span class="line">	<span class="comment">// received `X` and `Y` values and add them together.</span></span><br><span class="line">	.then( <span class="function"><span class="keyword">function</span>(<span class="params">values</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// `values` is an array of the messages from the</span></span><br><span class="line">		<span class="comment">// previously resolved promises</span></span><br><span class="line">		<span class="keyword">return</span> values[<span class="number">0</span>] + values[<span class="number">1</span>];</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `fetchX()` and `fetchY()` return promises for</span></span><br><span class="line"><span class="comment">// their respective values, which may be ready</span></span><br><span class="line"><span class="comment">// *now* or *later*.</span></span><br><span class="line">add( fetchX(), fetchY() )</span><br><span class="line"></span><br><span class="line"><span class="comment">// we get a promise back for the sum of those</span></span><br><span class="line"><span class="comment">// two numbers.</span></span><br><span class="line"><span class="comment">// now we chain-call `then(..)` to wait for the</span></span><br><span class="line"><span class="comment">// resolution of that returned promise.</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( sum ); <span class="comment">// that was easier!</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>There are two layers of Promises in this snippet.</p>
<p><code>fetchX()</code> and <code>fetchY()</code> are called directly, and the values they return (promises!) are passed into <code>add(..)</code>. The underlying values those promises represent may be ready <em>now</em> or <em>later</em>, but each promise normalizes the behavior to be the same regardless. We reason about <code>X</code> and <code>Y</code> values in a time-independent way. They are <em>future values</em>.</p>
<p>The second layer is the promise that <code>add(..)</code> creates (via <code>Promise.all([ .. ])</code>) and returns, which we wait on by calling <code>then(..)</code>. When the <code>add(..)</code> operation completes, our <code>sum</code> <em>future value</em> is ready and we can print it out. We hide inside of <code>add(..)</code> the logic for waiting on the <code>X</code> and <code>Y</code> <em>future values</em>.</p>
<p><strong>Note:</strong> Inside <code>add(..)</code>, the <code>Promise.all([ .. ])</code> call creates a promise (which is waiting on <code>promiseX</code> and <code>promiseY</code> to resolve). The chained call to <code>.then(..)</code> creates another promise, which the <code>return values[0] + values[1]</code> line immediately resolves (with the result of the addition). Thus, the <code>then(..)</code> call we chain off the end of the <code>add(..)</code> call – at the end of the snippet – is actually operating on that second promise returned, rather than the first one created by <code>Promise.all([ .. ])</code>. Also, though we are not chaining off the end of that second <code>then(..)</code>, it too has created another promise, had we chosen to observe/use it. This Promise chaining stuff will be explained in much greater detail later in this chapter.</p>
<p>Just like with cheeseburger orders, it’s possible that the resolution of a Promise is rejection instead of fulfillment. Unlike a fulfilled Promise, where the value is always programmatic, a rejection value – commonly called a “rejection reason” – can either be set directly by the program logic, or it can result implicitly from a runtime exception.</p>
<p>With Promises, the <code>then(..)</code> call can actually take two functions, the first for fulfillment (as shown earlier), and the second for rejection:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add( fetchX(), fetchY() )</span><br><span class="line">.then(</span><br><span class="line">	<span class="comment">// fullfillment handler</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( sum );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// rejection handler</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err ); <span class="comment">// bummer!</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>If something went wrong getting <code>X</code> or <code>Y</code>, or something somehow failed during the addition, the promise that <code>add(..)</code> returns is rejected, and the second callback error handler passed to <code>then(..)</code> will receive the rejection value from the promise.</p>
<p>Because Promises encapsulate the time-dependent state – waiting on the fulfillment or rejection of the underlying value – from the outside, the Promise itself is time-independent, and thus Promises can be composed (combined) in predictable ways regardless of the timing or outcome underneath.</p>
<p>Moreover, once a Promise is resolved, it stays that way forever – it becomes an <em>immutable value</em> at that point – and can then be <em>observed</em> as many times as necessary.</p>
<p><strong>Note:</strong> Because a Promise is externally immutable once resolved, it’s now safe to pass that value around to any party and know that it cannot be modified accidentally or maliciously. This is especially true in relation to multiple parties observing the resolution of a Promise. It is not possible for one party to affect another party’s ability to observe Promise resolution. Immutability may sound like an academic topic, but it’s actually one of the most fundamental and important aspects of Promise design, and shouldn’t be casually passed over.</p>
<p>That’s one of the most powerful and important concepts to understand about Promises. With a fair amount of work, you could ad hoc create the same effects with nothing but ugly callback composition, but that’s not really an effective strategy, especially because you have to do it over and over again.</p>
<p>Promises are an easily repeatable mechanism for encapsulating and composing <em>future values</em>.</p>
<h3 id="Completion-Event"><a href="#Completion-Event" class="headerlink" title="Completion Event"></a>Completion Event</h3><p>As we just saw, an individual Promise behaves as a <em>future value</em>. But there’s another way to think of the resolution of a Promise: as a flow-control mechanism – a temporal this-then-that – for two or more steps in an asynchronous task.</p>
<p>Let’s imagine calling a function <code>foo(..)</code> to perform some task. We don’t know about any of its details, nor do we care. It may complete the task right away, or it may take a while.</p>
<p>We just simply need to know when <code>foo(..)</code> finishes so that we can move on to our next task. In other words, we’d like a way to be notified of <code>foo(..)</code>‘s completion so that we can <em>continue</em>.</p>
<p>In typical JavaScript fashion, if you need to listen for a notification, you’d likely think of that in terms of events. So we could reframe our need for notification as a need to listen for a <em>completion</em> (or <em>continuation</em>) event emitted by <code>foo(..)</code>.</p>
<p><strong>Note:</strong> Whether you call it a “completion event” or a “continuation event” depends on your perspective. Is the focus more on what happens with <code>foo(..)</code>, or what happens <em>after</em> <code>foo(..)</code> finishes? Both perspectives are accurate and useful. The event notification tells us that <code>foo(..)</code> has <em>completed</em>, but also that it’s OK to <em>continue</em> with the next step. Indeed, the callback you pass to be called for the event notification is itself what we’ve previously called a <em>continuation</em>. Because <em>completion event</em> is a bit more focused on the <code>foo(..)</code>, which more has our attention at present, we slightly favor <em>completion event</em> for the rest of this text.</p>
<p>With callbacks, the “notification” would be our callback invoked by the task (<code>foo(..)</code>). But with Promises, we turn the relationship around, and expect that we can listen for an event from <code>foo(..)</code>, and when notified, proceed accordingly.</p>
<p>First, consider some pseudocode:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(x) &#123;</span><br><span class="line">	<span class="comment">// start doing something that could take a while</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">42</span> )</span><br><span class="line"></span><br><span class="line">on (foo <span class="string">"completion"</span>) &#123;</span><br><span class="line">	<span class="comment">// now we can do the next step!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">on (foo <span class="string">"error"</span>) &#123;</span><br><span class="line">	<span class="comment">// oops, something went wrong in `foo(..)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We call <code>foo(..)</code> and then we set up two event listeners, one for <code>&quot;completion&quot;</code> and one for <code>&quot;error&quot;</code> – the two possible <em>final</em> outcomes of the <code>foo(..)</code> call. In essence, <code>foo(..)</code> doesn’t even appear to be aware that the calling code has subscribed to these events, which makes for a very nice <em>separation of concerns</em>.</p>
<p>Unfortunately, such code would require some “magic” of the JS environment that doesn’t exist (and would likely be a bit impractical). Here’s the more natural way we could express that in JS:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// start doing something that could take a while</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// make a `listener` event notification</span></span><br><span class="line">	<span class="comment">// capability to return</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> evt = foo( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">evt.on( <span class="string">"completion"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// now we can do the next step!</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">evt.on( <span class="string">"failure"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// oops, something went wrong in `foo(..)`</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>foo(..)</code> expressly creates an event subscription capability to return back, and the calling code receives and registers the two event handlers against it.</p>
<p>The inversion from normal callback-oriented code should be obvious, and it’s intentional. Instead of passing the callbacks to <code>foo(..)</code>, it returns an event capability we call <code>evt</code>, which receives the callbacks.</p>
<p>But if you recall from Chapter 2, callbacks themselves represent an <em>inversion of control</em>. So inverting the callback pattern is actually an <em>inversion of inversion</em>, or an <em>uninversion of control</em> – restoring control back to the calling code where we wanted it to be in the first place.</p>
<p>One important benefit is that multiple separate parts of the code can be given the event listening capability, and they can all independently be notified of when <code>foo(..)</code> completes to perform subsequent steps after its completion:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = foo( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// let `bar(..)` listen to `foo(..)`'s completion</span></span><br><span class="line">bar( evt );</span><br><span class="line"></span><br><span class="line"><span class="comment">// also, let `baz(..)` listen to `foo(..)`'s completion</span></span><br><span class="line">baz( evt );</span><br></pre></td></tr></table></figure>
<p><em>Uninversion of control</em> enables a nicer <em>separation of concerns</em>, where <code>bar(..)</code> and <code>baz(..)</code> don’t need to be involved in how <code>foo(..)</code> is called. Similarly, <code>foo(..)</code> doesn’t need to know or care that <code>bar(..)</code> and <code>baz(..)</code> exist or are waiting to be notified when <code>foo(..)</code> completes.</p>
<p>Essentially, this <code>evt</code> object is a neutral third-party negotiation between the separate concerns.</p>
<h4 id="Promise-“Events”"><a href="#Promise-“Events”" class="headerlink" title="Promise “Events”"></a>Promise “Events”</h4><p>As you may have guessed by now, the <code>evt</code> event listening capability is an analogy for a Promise.</p>
<p>In a Promise-based approach, the previous snippet would have <code>foo(..)</code> creating and returning a <code>Promise</code> instance, and that promise would then be passed to <code>bar(..)</code> and <code>baz(..)</code>.</p>
<p><strong>Note:</strong> The Promise resolution “events” we listen for aren’t strictly events (though they certainly behave like events for these purposes), and they’re not typically called <code>&quot;completion&quot;</code> or <code>&quot;error&quot;</code>. Instead, we use <code>then(..)</code> to register a <code>&quot;then&quot;</code> event. Or perhaps more precisely, <code>then(..)</code> registers <code>&quot;fulfillment&quot;</code> and/or <code>&quot;rejection&quot;</code> event(s), though we don’t see those terms used explicitly in the code.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// start doing something that could take a while</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct and return a promise</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// eventually, call `resolve(..)` or `reject(..)`,</span></span><br><span class="line">		<span class="comment">// which are the resolution callbacks for</span></span><br><span class="line">		<span class="comment">// the promise.</span></span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = foo( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">bar( p );</span><br><span class="line"></span><br><span class="line">baz( p );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> The pattern shown with <code>new Promise( function(..){ .. } )</code> is generally called the <a href="http://domenic.me/2014/02/13/the-revealing-constructor-pattern/" target="_blank" rel="noopener">“revealing constructor”</a>. The function passed in is executed immediately (not async deferred, as callbacks to <code>then(..)</code> are), and it’s provided two parameters, which in this case we’ve named <code>resolve</code> and <code>reject</code>. These are the resolution functions for the promise. <code>resolve(..)</code> generally signals fulfillment, and <code>reject(..)</code> signals rejection.</p>
<p>You can probably guess what the internals of <code>bar(..)</code> and <code>baz(..)</code> might look like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fooPromise</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// listen for `foo(..)` to complete</span></span><br><span class="line">	fooPromise.then(</span><br><span class="line">		<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="comment">// `foo(..)` has now finished, so</span></span><br><span class="line">			<span class="comment">// do `bar(..)`'s task</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="comment">// oops, something went wrong in `foo(..)`</span></span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ditto for `baz(..)`</span></span><br></pre></td></tr></table></figure>
<p>Promise resolution doesn’t necessarily need to involve sending along a message, as it did when we were examining Promises as <em>future values</em>. It can just be a flow-control signal, as used in the previous snippet.</p>
<p>Another way to approach this is:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// `foo(..)` has definitely finished, so</span></span><br><span class="line">	<span class="comment">// do `bar(..)`'s task</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oopsBar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// oops, something went wrong in `foo(..)`,</span></span><br><span class="line">	<span class="comment">// so `bar(..)` didn't run</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ditto for `baz()` and `oopsBaz()`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = foo( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then( bar, oopsBar );</span><br><span class="line"></span><br><span class="line">p.then( baz, oopsBaz );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> If you’ve seen Promise-based coding before, you might be tempted to believe that the last two lines of that code could be written as <code>p.then( .. ).then( .. )</code>, using chaining, rather than <code>p.then(..); p.then(..)</code>. That would have an entirely different behavior, so be careful! The difference might not be clear right now, but it’s actually a different async pattern than we’ve seen thus far: splitting/forking. Don’t worry! We’ll come back to this point later in this chapter.</p>
<p>Instead of passing the <code>p</code> promise to <code>bar(..)</code> and <code>baz(..)</code>, we use the promise to control when <code>bar(..)</code> and <code>baz(..)</code> will get executed, if ever. The primary difference is in the error handling.</p>
<p>In the first snippet’s approach, <code>bar(..)</code> is called regardless of whether <code>foo(..)</code> succeeds or fails, and it handles its own fallback logic if it’s notified that <code>foo(..)</code> failed. The same is true for <code>baz(..)</code>, obviously.</p>
<p>In the second snippet, <code>bar(..)</code> only gets called if <code>foo(..)</code> succeeds, and otherwise <code>oopsBar(..)</code> gets called. Ditto for <code>baz(..)</code>.</p>
<p>Neither approach is <em>correct</em> per se. There will be cases where one is preferred over the other.</p>
<p>In either case, the promise <code>p</code> that comes back from <code>foo(..)</code> is used to control what happens next.</p>
<p>Moreover, the fact that both snippets end up calling <code>then(..)</code> twice against the same promise <code>p</code> illustrates the point made earlier, which is that Promises (once resolved) retain their same resolution (fulfillment or rejection) forever, and can subsequently be observed as many times as necessary.</p>
<p>Whenever <code>p</code> is resolved, the next step will always be the same, both <em>now</em> and <em>later</em>.</p>
<h2 id="Thenable-Duck-Typing"><a href="#Thenable-Duck-Typing" class="headerlink" title="Thenable Duck Typing"></a>Thenable Duck Typing</h2><p>In Promises-land, an important detail is how to know for sure if some value is a genuine Promise or not. Or more directly, is it a value that will behave like a Promise?</p>
<p>Given that Promises are constructed by the <code>new Promise(..)</code> syntax, you might think that <code>p instanceof Promise</code> would be an acceptable check. But unfortunately, there are a number of reasons that’s not totally sufficient.</p>
<p>Mainly, you can receive a Promise value from another browser window (iframe, etc.), which would have its own Promise different from the one in the current window/frame, and that check would fail to identify the Promise instance.</p>
<p>Moreover, a library or framework may choose to vend its own Promises and not use the native ES6 <code>Promise</code> implementation to do so. In fact, you may very well be using Promises with libraries in older browsers that have no Promise at all.</p>
<p>When we discuss Promise resolution processes later in this chapter, it will become more obvious why a non-genuine-but-Promise-like value would still be very important to be able to recognize and assimilate. But for now, just take my word for it that it’s a critical piece of the puzzle.</p>
<p>As such, it was decided that the way to recognize a Promise (or something that behaves like a Promise) would be to define something called a “thenable” as any object or function which has a <code>then(..)</code> method on it. It is assumed that any such value is a Promise-conforming thenable.</p>
<p>The general term for “type checks” that make assumptions about a value’s “type” based on its shape (what properties are present) is called “duck typing” – “If it looks like a duck, and quacks like a duck, it must be a duck” (see the <em>Types &amp; Grammar</em> title of this book series). So the duck typing check for a thenable would roughly be:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">	p !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">	(</span><br><span class="line">		<span class="keyword">typeof</span> p === <span class="string">"object"</span> ||</span><br><span class="line">		<span class="keyword">typeof</span> p === <span class="string">"function"</span></span><br><span class="line">	) &amp;&amp;</span><br><span class="line">	<span class="keyword">typeof</span> p.then === <span class="string">"function"</span></span><br><span class="line">) &#123;</span><br><span class="line">	<span class="comment">// assume it's a thenable!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// not a thenable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Yuck! Setting aside the fact that this logic is a bit ugly to implement in various places, there’s something deeper and more troubling going on.</p>
<p>If you try to fulfill a Promise with any object/function value that happens to have a <code>then(..)</code> function on it, but you weren’t intending it to be treated as a Promise/thenable, you’re out of luck, because it will automatically be recognized as thenable and treated with special rules (see later in the chapter).</p>
<p>This is even true if you didn’t realize the value has a <code>then(..)</code> on it. For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make `v` be `[[Prototype]]`-linked to `o`</span></span><br><span class="line"><span class="keyword">var</span> v = <span class="built_in">Object</span>.create( o );</span><br><span class="line"></span><br><span class="line">v.someStuff = <span class="string">"cool"</span>;</span><br><span class="line">v.otherStuff = <span class="string">"not so cool"</span>;</span><br><span class="line"></span><br><span class="line">v.hasOwnProperty( <span class="string">"then"</span> );		<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>v</code> doesn’t look like a Promise or thenable at all. It’s just a plain object with some properties on it. You’re probably just intending to send that value around like any other object.</p>
<p>But unknown to you, <code>v</code> is also <code>[[Prototype]]</code>-linked (see the <em>this &amp; Object Prototypes</em> title of this book series) to another object <code>o</code>, which happens to have a <code>then(..)</code> on it. So the thenable duck typing checks will think and assume <code>v</code> is a thenable. Uh oh.</p>
<p>It doesn’t even need to be something as directly intentional as that:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v1 = &#123; <span class="attr">hello</span>: <span class="string">"world"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> v2 = [ <span class="string">"Hello"</span>, <span class="string">"World"</span> ];</span><br></pre></td></tr></table></figure>
<p>Both <code>v1</code> and <code>v2</code> will be assumed to be thenables. You can’t control or predict if any other code accidentally or maliciously adds <code>then(..)</code> to <code>Object.prototype</code>, <code>Array.prototype</code>, or any of the other native prototypes. And if what’s specified is a function that doesn’t call either of its parameters as callbacks, then any Promise resolved with such a value will just silently hang forever! Crazy.</p>
<p>Sound implausible or unlikely? Perhaps.</p>
<p>But keep in mind that there were several well-known non-Promise libraries preexisting in the community prior to ES6 that happened to already have a method on them called <code>then(..)</code>. Some of those libraries chose to rename their own methods to avoid collision (that sucks!). Others have simply been relegated to the unfortunate status of “incompatible with Promise-based coding” in reward for their inability to change to get out of the way.</p>
<p>The standards decision to hijack the previously nonreserved – and completely general-purpose sounding – <code>then</code> property name means that no value (or any of its delegates), either past, present, or future, can have a <code>then(..)</code> function present, either on purpose or by accident, or that value will be confused for a thenable in Promises systems, which will probably create bugs that are really hard to track down.</p>
<p><strong>Warning:</strong> I do not like how we ended up with duck typing of thenables for Promise recognition. There were other options, such as “branding” or even “anti-branding”; what we got seems like a worst-case compromise. But it’s not all doom and gloom. Thenable duck typing can be helpful, as we’ll see later. Just beware that thenable duck typing can be hazardous if it incorrectly identifies something as a Promise that isn’t.</p>
<h2 id="Promise-Trust"><a href="#Promise-Trust" class="headerlink" title="Promise Trust"></a>Promise Trust</h2><p>We’ve now seen two strong analogies that explain different aspects of what Promises can do for our async code. But if we stop there, we’ve missed perhaps the single most important characteristic that the Promise pattern establishes: trust.</p>
<p>Whereas the <em>future values</em> and <em>completion events</em> analogies play out explicitly in the code patterns we’ve explored, it won’t be entirely obvious why or how Promises are designed to solve all of the <em>inversion of control</em> trust issues we laid out in the “Trust Issues” section of Chapter 2. But with a little digging, we can uncover some important guarantees that restore the confidence in async coding that Chapter 2 tore down!</p>
<p>Let’s start by reviewing the trust issues with callbacks-only coding. When you pass a callback to a utility <code>foo(..)</code>, it might:</p>
<ul>
<li>Call the callback too early</li>
<li>Call the callback too late (or never)</li>
<li>Call the callback too few or too many times</li>
<li>Fail to pass along any necessary environment/parameters</li>
<li>Swallow any errors/exceptions that may happen</li>
</ul>
<p>The characteristics of Promises are intentionally designed to provide useful, repeatable answers to all these concerns.</p>
<h3 id="Calling-Too-Early"><a href="#Calling-Too-Early" class="headerlink" title="Calling Too Early"></a>Calling Too Early</h3><p>Primarily, this is a concern of whether code can introduce Zalgo-like effects (see Chapter 2), where sometimes a task finishes synchronously and sometimes asynchronously, which can lead to race conditions.</p>
<p>Promises by definition cannot be susceptible to this concern, because even an immediately fulfilled Promise (like <code>new Promise(function(resolve){ resolve(42); })</code>) cannot be <em>observed</em> synchronously.</p>
<p>That is, when you call <code>then(..)</code> on a Promise, even if that Promise was already resolved, the callback you provide to <code>then(..)</code> will <strong>always</strong> be called asynchronously (for more on this, refer back to “Jobs” in Chapter 1).</p>
<p>No more need to insert your own <code>setTimeout(..,0)</code> hacks. Promises prevent Zalgo automatically.</p>
<h3 id="Calling-Too-Late"><a href="#Calling-Too-Late" class="headerlink" title="Calling Too Late"></a>Calling Too Late</h3><p>Similar to the previous point, a Promise’s <code>then(..)</code> registered observation callbacks are automatically scheduled when either <code>resolve(..)</code> or <code>reject(..)</code> are called by the Promise creation capability. Those scheduled callbacks will predictably be fired at the next asynchronous moment (see “Jobs” in Chapter 1).</p>
<p>It’s not possible for synchronous observation, so it’s not possible for a synchronous chain of tasks to run in such a way to in effect “delay” another callback from happening as expected. That is, when a Promise is resolved, all <code>then(..)</code> registered callbacks on it will be called, in order, immediately at the next asynchronous opportunity (again, see “Jobs” in Chapter 1), and nothing that happens inside of one of those callbacks can affect/delay the calling of the other callbacks.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	p.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"C"</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"A"</span> );</span><br><span class="line">&#125; );</span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"B"</span> );</span><br><span class="line">&#125; );</span><br><span class="line"><span class="comment">// A B C</span></span><br></pre></td></tr></table></figure>
<p>Here, <code>&quot;C&quot;</code> cannot interrupt and precede <code>&quot;B&quot;</code>, by virtue of how Promises are defined to operate.</p>
<h4 id="Promise-Scheduling-Quirks"><a href="#Promise-Scheduling-Quirks" class="headerlink" title="Promise Scheduling Quirks"></a>Promise Scheduling Quirks</h4><p>It’s important to note, though, that there are lots of nuances of scheduling where the relative ordering between callbacks chained off two separate Promises is not reliably predictable.</p>
<p>If two promises <code>p1</code> and <code>p2</code> are both already resolved, it should be true that <code>p1.then(..); p2.then(..)</code> would end up calling the callback(s) for <code>p1</code> before the ones for <code>p2</code>. But there are subtle cases where that might not be true, such as the following:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	resolve( <span class="string">"B"</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	resolve( p3 );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	resolve( <span class="string">"A"</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p1.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p2.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// A B  &lt;-- not  B A  as you might expect</span></span><br></pre></td></tr></table></figure>
<p>We’ll cover this more later, but as you can see, <code>p1</code> is resolved not with an immediate value, but with another promise <code>p3</code> which is itself resolved with the value <code>&quot;B&quot;</code>. The specified behavior is to <em>unwrap</em> <code>p3</code> into <code>p1</code>, but asynchronously, so <code>p1</code>‘s callback(s) are <em>behind</em> <code>p2</code>‘s callback(s) in the asynchronous Job queue (see Chapter 1).</p>
<p>To avoid such nuanced nightmares, you should never rely on anything about the ordering/scheduling of callbacks across Promises. In fact, a good practice is not to code in such a way where the ordering of multiple callbacks matters at all. Avoid that if you can.</p>
<h3 id="Never-Calling-the-Callback"><a href="#Never-Calling-the-Callback" class="headerlink" title="Never Calling the Callback"></a>Never Calling the Callback</h3><p>This is a very common concern. It’s addressable in several ways with Promises.</p>
<p>First, nothing (not even a JS error) can prevent a Promise from notifying you of its resolution (if it’s resolved). If you register both fulfillment and rejection callbacks for a Promise, and the Promise gets resolved, one of the two callbacks will always be called.</p>
<p>Of course, if your callbacks themselves have JS errors, you may not see the outcome you expect, but the callback will in fact have been called. We’ll cover later how to be notified of an error in your callback, because even those don’t get swallowed.</p>
<p>But what if the Promise itself never gets resolved either way? Even that is a condition that Promises provide an answer for, using a higher level abstraction called a “race”:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a utility for timing out a Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			reject( <span class="string">"Timeout!"</span> );</span><br><span class="line">		&#125;, delay );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup a timeout for `foo()`</span></span><br><span class="line"><span class="built_in">Promise</span>.race( [</span><br><span class="line">	foo(),					<span class="comment">// attempt `foo()`</span></span><br><span class="line">	timeoutPromise( <span class="number">3000</span> )	<span class="comment">// give it 3 seconds</span></span><br><span class="line">] )</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// `foo(..)` fulfilled in time!</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// either `foo()` rejected, or it just</span></span><br><span class="line">		<span class="comment">// didn't finish in time, so inspect</span></span><br><span class="line">		<span class="comment">// `err` to know which</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>There are more details to consider with this Promise timeout pattern, but we’ll come back to it later.</p>
<p>Importantly, we can ensure a signal as to the outcome of <code>foo()</code>, to prevent it from hanging our program indefinitely.</p>
<h3 id="Calling-Too-Few-or-Too-Many-Times"><a href="#Calling-Too-Few-or-Too-Many-Times" class="headerlink" title="Calling Too Few or Too Many Times"></a>Calling Too Few or Too Many Times</h3><p>By definition, <em>one</em> is the appropriate number of times for the callback to be called. The “too few” case would be zero calls, which is the same as the “never” case we just examined.</p>
<p>The “too many” case is easy to explain. Promises are defined so that they can only be resolved once. If for some reason the Promise creation code tries to call <code>resolve(..)</code> or <code>reject(..)</code> multiple times, or tries to call both, the Promise will accept only the first resolution, and will silently ignore any subsequent attempts.</p>
<p>Because a Promise can only be resolved once, any <code>then(..)</code> registered callbacks will only ever be called once (each).</p>
<p>Of course, if you register the same callback more than once, (e.g., <code>p.then(f); p.then(f);</code>), it’ll be called as many times as it was registered.  The guarantee that a response function is called only once does not prevent you from shooting yourself in the foot.</p>
<h3 id="Failing-to-Pass-Along-Any-Parameters-Environment"><a href="#Failing-to-Pass-Along-Any-Parameters-Environment" class="headerlink" title="Failing to Pass Along Any Parameters/Environment"></a>Failing to Pass Along Any Parameters/Environment</h3><p>Promises can have, at most, one resolution value (fulfillment or rejection).</p>
<p>If you don’t explicitly resolve with a value either way, the value is <code>undefined</code>, as is typical in JS. But whatever the value, it will always be passed to all registered (and appropriate: fulfillment or rejection) callbacks, either <em>now</em> or in the future.</p>
<p>Something to be aware of: If you call <code>resolve(..)</code> or <code>reject(..)</code> with multiple parameters, all subsequent parameters beyond the first will be silently ignored. Although that might seem a violation of the guarantee we just described, it’s not exactly, because it constitutes an invalid usage of the Promise mechanism. Other invalid usages of the API (such as calling <code>resolve(..)</code> multiple times) are similarly <em>protected</em>, so the Promise behavior here is consistent (if not a tiny bit frustrating).</p>
<p>If you want to pass along multiple values, you must wrap them in another single value that you pass, such as an <code>array</code> or an <code>object</code>.</p>
<p>As for environment, functions in JS always retain their closure of the scope in which they’re defined (see the <em>Scope &amp; Closures</em> title of this series), so they of course would continue to have access to whatever surrounding state you provide. Of course, the same is true of callbacks-only design, so this isn’t a specific augmentation of benefit from Promises – but it’s a guarantee we can rely on nonetheless.</p>
<h3 id="Swallowing-Any-Errors-Exceptions"><a href="#Swallowing-Any-Errors-Exceptions" class="headerlink" title="Swallowing Any Errors/Exceptions"></a>Swallowing Any Errors/Exceptions</h3><p>In the base sense, this is a restatement of the previous point. If you reject a Promise with a <em>reason</em> (aka error message), that value is passed to the rejection callback(s).</p>
<p>But there’s something much bigger at play here. If at any point in the creation of a Promise, or in the observation of its resolution, a JS exception error occurs, such as a <code>TypeError</code> or <code>ReferenceError</code>, that exception will be caught, and it will force the Promise in question to become rejected.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	foo.bar();	<span class="comment">// `foo` is not defined, so error!</span></span><br><span class="line">	resolve( <span class="number">42</span> );	<span class="comment">// never gets here :(</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here :(</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// `err` will be a `TypeError` exception object</span></span><br><span class="line">		<span class="comment">// from the `foo.bar()` line.</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>The JS exception that occurs from <code>foo.bar()</code> becomes a Promise rejection that you can catch and respond to.</p>
<p>This is an important detail, because it effectively solves another potential Zalgo moment, which is that errors could create a synchronous reaction whereas nonerrors would be asynchronous. Promises turn even JS exceptions into asynchronous behavior, thereby reducing the race condition chances greatly.</p>
<p>But what happens if a Promise is fulfilled, but there’s a JS exception error during the observation (in a <code>then(..)</code> registered callback)? Even those aren’t lost, but you may find how they’re handled a bit surprising, until you dig in a little deeper:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	resolve( <span class="number">42</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">		foo.bar();</span><br><span class="line">		<span class="built_in">console</span>.log( msg );	<span class="comment">// never gets here :(</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here either :(</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Wait, that makes it seem like the exception from <code>foo.bar()</code> really did get swallowed. Never fear, it didn’t. But something deeper is wrong, which is that we’ve failed to listen for it. The <code>p.then(..)</code> call itself returns another promise, and it’s <em>that</em> promise that will be rejected with the <code>TypeError</code> exception.</p>
<p>Why couldn’t it just call the error handler we have defined there? Seems like a logical behavior on the surface. But it would violate the fundamental principle that Promises are <strong>immutable</strong> once resolved. <code>p</code> was already fulfilled to the value <code>42</code>, so it can’t later be changed to a rejection just because there’s an error in observing <code>p</code>‘s resolution.</p>
<p>Besides the principle violation, such behavior could wreak havoc, if say there were multiple <code>then(..)</code> registered callbacks on the promise <code>p</code>, because some would get called and others wouldn’t, and it would be very opaque as to why.</p>
<h3 id="Trustable-Promise"><a href="#Trustable-Promise" class="headerlink" title="Trustable Promise?"></a>Trustable Promise?</h3><p>There’s one last detail to examine to establish trust based on the Promise pattern.</p>
<p>You’ve no doubt noticed that Promises don’t get rid of callbacks at all. They just change where the callback is passed to. Instead of passing a callback to <code>foo(..)</code>, we get <em>something</em> (ostensibly a genuine Promise) back from <code>foo(..)</code>, and we pass the callback to that <em>something</em> instead.</p>
<p>But why would this be any more trustable than just callbacks alone? How can we be sure the <em>something</em> we get back is in fact a trustable Promise? Isn’t it basically all just a house of cards where we can trust only because we already trusted?</p>
<p>One of the most important, but often overlooked, details of Promises is that they have a solution to this issue as well. Included with the native ES6 <code>Promise</code> implementation is <code>Promise.resolve(..)</code>.</p>
<p>If you pass an immediate, non-Promise, non-thenable value to <code>Promise.resolve(..)</code>, you get a promise that’s fulfilled with that value. In other words, these two promises <code>p1</code> and <code>p2</code> will behave basically identically:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	resolve( <span class="number">42</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br></pre></td></tr></table></figure>
<p>But if you pass a genuine Promise to <code>Promise.resolve(..)</code>, you just get the same promise back:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</span><br><span class="line"></span><br><span class="line">p1 === p2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>Even more importantly, if you pass a non-Promise thenable value to <code>Promise.resolve(..)</code>, it will attempt to unwrap that value, and the unwrapping will keep going until a concrete final non-Promise-like value is extracted.</p>
<p>Recall our previous discussion of thenables?</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">		cb( <span class="number">42</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this works OK, but only by good fortune</span></span><br><span class="line">p</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( val ); <span class="comment">// 42</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>This <code>p</code> is a thenable, but it’s not a genuine Promise. Luckily, it’s reasonable, as most will be. But what if you got back instead something that looked like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">cb,errcb</span>) </span>&#123;</span><br><span class="line">		cb( <span class="number">42</span> );</span><br><span class="line">		errcb( <span class="string">"evil laugh"</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( val ); <span class="comment">// 42</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// oops, shouldn't have run</span></span><br><span class="line">		<span class="built_in">console</span>.log( err ); <span class="comment">// evil laugh</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>This <code>p</code> is a thenable but it’s not so well behaved of a promise. Is it malicious? Or is it just ignorant of how Promises should work? It doesn’t really matter, to be honest. In either case, it’s not trustable as is.</p>
<p>Nonetheless, we can pass either of these versions of <code>p</code> to <code>Promise.resolve(..)</code>, and we’ll get the normalized, safe result we’d expect:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve( p )</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( val ); <span class="comment">// 42</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve(..)</code> will accept any thenable, and will unwrap it to its non-thenable value. But you get back from <code>Promise.resolve(..)</code> a real, genuine Promise in its place, <strong>one that you can trust</strong>. If what you passed in is already a genuine Promise, you just get it right back, so there’s no downside at all to filtering through <code>Promise.resolve(..)</code> to gain trust.</p>
<p>So let’s say we’re calling a <code>foo(..)</code> utility and we’re not sure we can trust its return value to be a well-behaving Promise, but we know it’s at least a thenable. <code>Promise.resolve(..)</code> will give us a trustable Promise wrapper to chain off of:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// don't just do this:</span></span><br><span class="line">foo( <span class="number">42</span> )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// instead, do this:</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve( foo( <span class="number">42</span> ) )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Another beneficial side effect of wrapping <code>Promise.resolve(..)</code> around any function’s return value (thenable or not) is that it’s an easy way to normalize that function call into a well-behaving async task. If <code>foo(42)</code> returns an immediate value sometimes, or a Promise other times, <code>Promise.resolve( foo(42) )</code> makes sure it’s always a Promise result. And avoiding Zalgo makes for much better code.</p>
<h3 id="Trust-Built"><a href="#Trust-Built" class="headerlink" title="Trust Built"></a>Trust Built</h3><p>Hopefully the previous discussion now fully “resolves” (pun intended) in your mind why the Promise is trustable, and more importantly, why that trust is so critical in building robust, maintainable software.</p>
<p>Can you write async code in JS without trust? Of course you can. We JS developers have been coding async with nothing but callbacks for nearly two decades.</p>
<p>But once you start questioning just how much you can trust the mechanisms you build upon to actually be predictable and reliable, you start to realize callbacks have a pretty shaky trust foundation.</p>
<p>Promises are a pattern that augments callbacks with trustable semantics, so that the behavior is more reason-able and more reliable. By uninverting the <em>inversion of control</em> of callbacks, we place the control with a trustable system (Promises) that was designed specifically to bring sanity to our async.</p>
<h2 id="Chain-Flow"><a href="#Chain-Flow" class="headerlink" title="Chain Flow"></a>Chain Flow</h2><p>We’ve hinted at this a couple of times already, but Promises are not just a mechanism for a single-step <em>this-then-that</em> sort of operation. That’s the building block, of course, but it turns out we can string multiple Promises together to represent a sequence of async steps.</p>
<p>The key to making this work is built on two behaviors intrinsic to Promises:</p>
<ul>
<li>Every time you call <code>then(..)</code> on a Promise, it creates and returns a new Promise, which we can <em>chain</em> with.</li>
<li>Whatever value you return from the <code>then(..)</code> call’s fulfillment callback (the first parameter) is automatically set as the fulfillment of the <em>chained</em> Promise (from the first point).</li>
</ul>
<p>Let’s first illustrate what that means, and <em>then</em> we’ll derive how that helps us create async sequences of flow control. Consider the following:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">21</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = p.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// fulfill `p2` with value `42`</span></span><br><span class="line">	<span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain off `p2`</span></span><br><span class="line">p2.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>By returning <code>v * 2</code> (i.e., <code>42</code>), we fulfill the <code>p2</code> promise that the first <code>then(..)</code> call created and returned. When <code>p2</code>‘s <code>then(..)</code> call runs, it’s receiving the fulfillment from the <code>return v * 2</code> statement. Of course, <code>p2.then(..)</code> creates yet another promise, which we could have stored in a <code>p3</code> variable.</p>
<p>But it’s a little annoying to have to create an intermediate variable <code>p2</code> (or <code>p3</code>, etc.). Thankfully, we can easily just chain these together:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">21</span> );</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// fulfill the chained promise with value `42`</span></span><br><span class="line">	<span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// here's the chained promise</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>So now the first <code>then(..)</code> is the first step in an async sequence, and the second <code>then(..)</code> is the second step. This could keep going for as long as you needed it to extend. Just keep chaining off a previous <code>then(..)</code> with each automatically created Promise.</p>
<p>But there’s something missing here. What if we want step 2 to wait for step 1 to do something asynchronous? We’re using an immediate <code>return</code> statement, which immediately fulfills the chained promise.</p>
<p>The key to making a Promise sequence truly async capable at every step is to recall how <code>Promise.resolve(..)</code> operates when what you pass to it is a Promise or thenable instead of a final value. <code>Promise.resolve(..)</code> directly returns a received genuine Promise, or it unwraps the value of a received thenable – and keeps going recursively while it keeps unwrapping thenables.</p>
<p>The same sort of unwrapping happens if you <code>return</code> a thenable or Promise from the fulfillment (or rejection) handler. Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">21</span> );</span><br><span class="line"></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a promise and return it</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// fulfill with value `42`</span></span><br><span class="line">		resolve( v * <span class="number">2</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Even though we wrapped <code>42</code> up in a promise that we returned, it still got unwrapped and ended up as the resolution of the chained promise, such that the second <code>then(..)</code> still received <code>42</code>. If we introduce asynchrony to that wrapping promise, everything still nicely works the same:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">21</span> );</span><br><span class="line"></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a promise to return</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// introduce asynchrony!</span></span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="comment">// fulfill with value `42`</span></span><br><span class="line">			resolve( v * <span class="number">2</span> );</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// runs after the 100ms delay in the previous step</span></span><br><span class="line">	<span class="built_in">console</span>.log( v );	<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>That’s incredibly powerful! Now we can construct a sequence of however many async steps we want, and each step can delay the next step (or not!), as necessary.</p>
<p>Of course, the value passing from step to step in these examples is optional. If you don’t return an explicit value, an implicit <code>undefined</code> is assumed, and the promises still chain together the same way. Each Promise resolution is thus just a signal to proceed to the next step.</p>
<p>To further the chain illustration, let’s generalize a delay-Promise creation (without resolution messages) into a utility we can reuse for multiple steps:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout( resolve, time );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay( <span class="number">100</span> ) <span class="comment">// step 1</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"step 2 (after 100ms)"</span> );</span><br><span class="line">	<span class="keyword">return</span> delay( <span class="number">200</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"step 3 (after another 200ms)"</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"step 4 (next Job)"</span> );</span><br><span class="line">	<span class="keyword">return</span> delay( <span class="number">50</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP5</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"step 5 (after another 50ms)"</span> );</span><br><span class="line">&#125; )</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Calling <code>delay(200)</code> creates a promise that will fulfill in 200ms, and then we return that from the first <code>then(..)</code> fulfillment callback, which causes the second <code>then(..)</code>‘s promise to wait on that 200ms promise.</p>
<p><strong>Note:</strong> As described, technically there are two promises in that interchange: the 200ms-delay promise and the chained promise that the second <code>then(..)</code> chains from. But you may find it easier to mentally combine these two promises together, because the Promise mechanism automatically merges their states for you. In that respect, you could think of <code>return delay(200)</code> as creating a promise that replaces the earlier-returned chained promise.</p>
<p>To be honest, though, sequences of delays with no message passing isn’t a terribly useful example of Promise flow control. Let’s look at a scenario that’s a little more practical.</p>
<p>Instead of timers, let’s consider making Ajax requests:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume an `ajax( &#123;url&#125;, &#123;callback&#125; )` utility</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise-aware ajax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// the `ajax(..)` callback should be our</span></span><br><span class="line">		<span class="comment">// promise's `resolve(..)` function</span></span><br><span class="line">		ajax( url, resolve );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We first define a <code>request(..)</code> utility that constructs a promise to represent the completion of the <code>ajax(..)</code> call:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request( <span class="string">"http://some.url.1/"</span> )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">response1</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> request( <span class="string">"http://some.url.2/?v="</span> + response1 );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">response2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( response2 );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Developers commonly encounter situations in which they want to do Promise-aware async flow control with utilities that are not themselves Promise-enabled (like <code>ajax(..)</code> here, which expects a callback). Although the native ES6 <code>Promise</code> mechanism doesn’t automatically solve this pattern for us, practically all Promise libraries <em>do</em>. They usually call this process “lifting” or “promisifying” or some variation thereof. We’ll come back to this technique later.</p>
<p>Using the Promise-returning <code>request(..)</code>, we create the first step in our chain implicitly by calling it with the first URL, and chain off that returned promise with the first <code>then(..)</code>.</p>
<p>Once <code>response1</code> comes back, we use that value to construct a second URL, and make a second <code>request(..)</code> call. That second <code>request(..)</code> promise is <code>return</code>ed so that the third step in our async flow control waits for that Ajax call to complete. Finally, we print <code>response2</code> once it returns.</p>
<p>The Promise chain we construct is not only a flow control that expresses a multistep async sequence, but it also acts as a message channel to propagate messages from step to step.</p>
<p>What if something went wrong in one of the steps of the Promise chain? An error/exception is on a per-Promise basis, which means it’s possible to catch such an error at any point in the chain, and that catching acts to sort of “reset” the chain back to normal operation at that point:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1:</span></span><br><span class="line">request( <span class="string">"http://some.url.1/"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2:</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">response1</span>)</span>&#123;</span><br><span class="line">	foo.bar(); <span class="comment">// undefined, error!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// never gets here</span></span><br><span class="line">	<span class="keyword">return</span> request( <span class="string">"http://some.url.2/?v="</span> + response1 );</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3:</span></span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">response2</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// rejection handler to catch the error</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( err );	<span class="comment">// `TypeError` from `foo.bar()` error</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 4:</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>When the error occurs in step 2, the rejection handler in step 3 catches it. The return value (<code>42</code> in this snippet), if any, from that rejection handler fulfills the promise for the next step (4), such that the chain is now back in a fulfillment state.</p>
<p><strong>Note:</strong> As we discussed earlier, when returning a promise from a fulfillment handler, it’s unwrapped and can delay the next step. That’s also true for returning promises from rejection handlers, such that if the <code>return 42</code> in step 3 instead returned a promise, that promise could delay step 4. A thrown exception inside either the fulfillment or rejection handler of a <code>then(..)</code> call causes the next (chained) promise to be immediately rejected with that exception.</p>
<p>If you call <code>then(..)</code> on a promise, and you only pass a fulfillment handler to it, an assumed rejection handler is substituted:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	reject( <span class="string">"Oops"</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// assumed rejection handler, if omitted or</span></span><br><span class="line">	<span class="comment">// any other non-function value passed</span></span><br><span class="line">	<span class="comment">// function(err) &#123;</span></span><br><span class="line">	<span class="comment">//     throw err;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>As you can see, the assumed rejection handler simply rethrows the error, which ends up forcing <code>p2</code> (the chained promise) to reject with the same error reason. In essence, this allows the error to continue propagating along a Promise chain until an explicitly defined rejection handler is encountered.</p>
<p><strong>Note:</strong> We’ll cover more details of error handling with Promises a little later, because there are other nuanced details to be concerned about.</p>
<p>If a proper valid function is not passed as the fulfillment handler parameter to <code>then(..)</code>, there’s also a default handler substituted:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	<span class="comment">// assumed fulfillment handler, if omitted or</span></span><br><span class="line">	<span class="comment">// any other non-function value passed</span></span><br><span class="line">	<span class="comment">// function(v) &#123;</span></span><br><span class="line">	<span class="comment">//     return v;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="literal">null</span>,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>As you can see, the default fulfillment handler simply passes whatever value it receives along to the next step (Promise).</p>
<p><strong>Note:</strong> The <code>then(null,function(err){ .. })</code> pattern – only handling rejections (if any) but letting fulfillments pass through – has a shortcut in the API: <code>catch(function(err){ .. })</code>. We’ll cover <code>catch(..)</code> more fully in the next section.</p>
<p>Let’s review briefly the intrinsic behaviors of Promises that enable chaining flow control:</p>
<ul>
<li>A <code>then(..)</code> call against one Promise automatically produces a new Promise to return from the call.</li>
<li>Inside the fulfillment/rejection handlers, if you return a value or an exception is thrown, the new returned (chainable) Promise is resolved accordingly.</li>
<li>If the fulfillment or rejection handler returns a Promise, it is unwrapped, so that whatever its resolution is will become the resolution of the chained Promise returned from the current <code>then(..)</code>.</li>
</ul>
<p>While chaining flow control is helpful, it’s probably most accurate to think of it as a side benefit of how Promises compose (combine) together, rather than the main intent. As we’ve discussed in detail several times already, Promises normalize asynchrony and encapsulate time-dependent value state, and <em>that</em> is what lets us chain them together in this useful way.</p>
<p>Certainly, the sequential expressiveness of the chain (this-then-this-then-this…) is a big improvement over the tangled mess of callbacks as we identified in Chapter 2. But there’s still a fair amount of boilerplate (<code>then(..)</code> and <code>function(){ .. }</code>) to wade through. In the next chapter, we’ll see a significantly nicer pattern for sequential flow control expressivity, with generators.</p>
<h3 id="Terminology-Resolve-Fulfill-and-Reject"><a href="#Terminology-Resolve-Fulfill-and-Reject" class="headerlink" title="Terminology: Resolve, Fulfill, and Reject"></a>Terminology: Resolve, Fulfill, and Reject</h3><p>There’s some slight confusion around the terms “resolve,” “fulfill,” and “reject” that we need to clear up, before you get too much deeper into learning about Promises. Let’s first consider the <code>Promise(..)</code> constructor:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">X,Y</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// X() for fulfillment</span></span><br><span class="line">	<span class="comment">// Y() for rejection</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>As you can see, two callbacks (here labeled <code>X</code> and <code>Y</code>) are provided. The first is <em>usually</em> used to mark the Promise as fulfilled, and the second <em>always</em> marks the Promise as rejected. But what’s the “usually” about, and what does that imply about accurately naming those parameters?</p>
<p>Ultimately, it’s just your user code and the identifier names aren’t interpreted by the engine to mean anything, so it doesn’t <em>technically</em> matter; <code>foo(..)</code> and <code>bar(..)</code> are equally functional. But the words you use can affect not only how you are thinking about the code, but how other developers on your team will think about it. Thinking wrongly about carefully orchestrated async code is almost surely going to be worse than the spaghetti-callback alternatives.</p>
<p>So it actually does kind of matter what you call them.</p>
<p>The second parameter is easy to decide. Almost all literature uses <code>reject(..)</code> as its name, and because that’s exactly (and only!) what it does, that’s a very good choice for the name. I’d strongly recommend you always use <code>reject(..)</code>.</p>
<p>But there’s a little more ambiguity around the first parameter, which in Promise literature is often labeled <code>resolve(..)</code>. That word is obviously related to “resolution,” which is what’s used across the literature (including this book) to describe setting a final value/state to a Promise. We’ve already used “resolve the Promise” several times to mean either fulfilling or rejecting the Promise.</p>
<p>But if this parameter seems to be used to specifically fulfill the Promise, why shouldn’t we call it <code>fulfill(..)</code> instead of <code>resolve(..)</code> to be more accurate? To answer that question, let’s also take a look at two of the <code>Promise</code> API methods:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fulfilledPr = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rejectedPr = <span class="built_in">Promise</span>.reject( <span class="string">"Oops"</span> );</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve(..)</code> creates a Promise that’s resolved to the value given to it. In this example, <code>42</code> is a normal, non-Promise, non-thenable value, so the fulfilled promise <code>fulfilledPr</code> is created for the value <code>42</code>. <code>Promise.reject(&quot;Oops&quot;)</code> creates the rejected promise <code>rejectedPr</code> for the reason <code>&quot;Oops&quot;</code>.</p>
<p>Let’s now illustrate why the word “resolve” (such as in <code>Promise.resolve(..)</code>) is unambiguous and indeed more accurate, if used explicitly in a context that could result in either fulfillment or rejection:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rejectedTh = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">resolved,rejected</span>) </span>&#123;</span><br><span class="line">		rejected( <span class="string">"Oops"</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rejectedPr = <span class="built_in">Promise</span>.resolve( rejectedTh );</span><br></pre></td></tr></table></figure>
<p>As we discussed earlier in this chapter, <code>Promise.resolve(..)</code> will return a received genuine Promise directly, or unwrap a received thenable. If that thenable unwrapping reveals a rejected state, the Promise returned from <code>Promise.resolve(..)</code> is in fact in that same rejected state.</p>
<p>So <code>Promise.resolve(..)</code> is a good, accurate name for the API method, because it can actually result in either fulfillment or rejection.</p>
<p>The first callback parameter of the <code>Promise(..)</code> constructor will unwrap either a thenable (identically to <code>Promise.resolve(..)</code>) or a genuine Promise:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rejectedPr = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// resolve this promise with a rejected promise</span></span><br><span class="line">	resolve( <span class="built_in">Promise</span>.reject( <span class="string">"Oops"</span> ) );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">rejectedPr.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( err );	<span class="comment">// "Oops"</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>It should be clear now that <code>resolve(..)</code> is the appropriate name for the first callback parameter of the <code>Promise(..)</code> constructor.</p>
<p><strong>Warning:</strong> The previously mentioned <code>reject(..)</code> does <strong>not</strong> do the unwrapping that <code>resolve(..)</code> does. If you pass a Promise/thenable value to <code>reject(..)</code>, that untouched value will be set as the rejection reason. A subsequent rejection handler would receive the actual Promise/thenable you passed to <code>reject(..)</code>, not its underlying immediate value.</p>
<p>But now let’s turn our attention to the callbacks provided to <code>then(..)</code>. What should they be called (both in literature and in code)? I would suggest <code>fulfilled(..)</code> and <code>rejected(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.error( err );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	fulfilled,</span><br><span class="line">	rejected</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>In the case of the first parameter to <code>then(..)</code>, it’s unambiguously always the fulfillment case, so there’s no need for the duality of “resolve” terminology. As a side note, the ES6 specification uses <code>onFulfilled(..)</code> and <code>onRejected(..)</code> to label these two callbacks, so they are accurate terms.</p>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>We’ve already seen several examples of how Promise rejection – either intentional through calling <code>reject(..)</code> or accidental through JS exceptions – allows saner error handling in asynchronous programming. Let’s circle back though and be explicit about some of the details that we glossed over.</p>
<p>The most natural form of error handling for most developers is the synchronous <code>try..catch</code> construct. Unfortunately, it’s synchronous-only, so it fails to help in async code patterns:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		baz.bar();</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	foo();</span><br><span class="line">	<span class="comment">// later throws global error from `baz.bar()`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="comment">// never gets here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>try..catch</code> would certainly be nice to have, but it doesn’t work across async operations. That is, unless there’s some additional environmental support, which we’ll come back to with generators in Chapter 4.</p>
<p>In callbacks, some standards have emerged for patterned error handling, most notably the “error-first callback” style:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> x = baz.bar();</span><br><span class="line">			cb( <span class="literal">null</span>, x ); <span class="comment">// success!</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">			cb( err );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="function"><span class="keyword">function</span>(<span class="params">err,val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err ); <span class="comment">// bummer :(</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( val );</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> The <code>try..catch</code> here works only from the perspective that the <code>baz.bar()</code> call will either succeed or fail immediately, synchronously. If <code>baz.bar()</code> was itself its own async completing function, any async errors inside it would not be catchable.</p>
<p>The callback we pass to <code>foo(..)</code> expects to receive a signal of an error by the reserved first parameter <code>err</code>. If present, error is assumed. If not, success is assumed.</p>
<p>This sort of error handling is technically <em>async capable</em>, but it doesn’t compose well at all. Multiple levels of error-first callbacks woven together with these ubiquitous <code>if</code> statement checks inevitably will lead you to the perils of callback hell (see Chapter 2).</p>
<p>So we come back to error handling in Promises, with the rejection handler passed to <code>then(..)</code>. Promises don’t use the popular “error-first callback” design style, but instead use “split callbacks” style; there’s one callback for fulfillment and one for rejection:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject( <span class="string">"Oops"</span> );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( err ); <span class="comment">// "Oops"</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>While this pattern of error handling makes fine sense on the surface, the nuances of Promise error handling are often a fair bit more difficult to fully grasp.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// numbers don't have string functions,</span></span><br><span class="line">		<span class="comment">// so will throw an error</span></span><br><span class="line">		<span class="built_in">console</span>.log( msg.toLowerCase() );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// never gets here</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>If the <code>msg.toLowerCase()</code> legitimately throws an error (it does!), why doesn’t our error handler get notified? As we explained earlier, it’s because <em>that</em> error handler is for the <code>p</code> promise, which has already been fulfilled with value <code>42</code>. The <code>p</code> promise is immutable, so the only promise that can be notified of the error is the one returned from <code>p.then(..)</code>, which in this case we don’t capture.</p>
<p>That should paint a clear picture of why error handling with Promises is error-prone (pun intended). It’s far too easy to have errors swallowed, as this is very rarely what you’d intend.</p>
<p><strong>Warning:</strong> If you use the Promise API in an invalid way and an error occurs that prevents proper Promise construction, the result will be an immediately thrown exception, <strong>not a rejected Promise</strong>. Some examples of incorrect usage that fail Promise construction: <code>new Promise(null)</code>, <code>Promise.all()</code>, <code>Promise.race(42)</code>, and so on. You can’t get a rejected Promise if you don’t use the Promise API validly enough to actually construct a Promise in the first place!</p>
<h3 id="Pit-of-Despair"><a href="#Pit-of-Despair" class="headerlink" title="Pit of Despair"></a>Pit of Despair</h3><p>Jeff Atwood noted years ago: programming languages are often set up in such a way that by default, developers fall into the “pit of despair” (<a href="http://blog.codinghorror.com/falling-into-the-pit-of-success/" target="_blank" rel="noopener">http://blog.codinghorror.com/falling-into-the-pit-of-success/</a>) – where accidents are punished – and that you have to try harder to get it right. He implored us to instead create a “pit of success,” where by default you fall into expected (successful) action, and thus would have to try hard to fail.</p>
<p>Promise error handling is unquestionably “pit of despair” design. By default, it assumes that you want any error to be swallowed by the Promise state, and if you forget to observe that state, the error silently languishes/dies in obscurity – usually despair.</p>
<p>To avoid losing an error to the silence of a forgotten/discarded Promise, some developers have claimed that a “best practice” for Promise chains is to always end your chain with a final <code>catch(..)</code>, like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// numbers don't have string functions,</span></span><br><span class="line">		<span class="comment">// so will throw an error</span></span><br><span class="line">		<span class="built_in">console</span>.log( msg.toLowerCase() );</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">.catch( handleErrors );</span><br></pre></td></tr></table></figure>
<p>Because we didn’t pass a rejection handler to the <code>then(..)</code>, the default handler was substituted, which simply propagates the error to the next promise in the chain. As such, both errors that come into <code>p</code>, and errors that come <em>after</em> <code>p</code> in its resolution (like the <code>msg.toLowerCase()</code> one) will filter down to the final <code>handleErrors(..)</code>.</p>
<p>Problem solved, right? Not so fast!</p>
<p>What happens if <code>handleErrors(..)</code> itself also has an error in it? Who catches that? There’s still yet another unattended promise: the one <code>catch(..)</code> returns, which we don’t capture and don’t register a rejection handler for.</p>
<p>You can’t just stick another <code>catch(..)</code> on the end of that chain, because it too could fail. The last step in any Promise chain, whatever it is, always has the possibility, even decreasingly so, of dangling with an uncaught error stuck inside an unobserved Promise.</p>
<p>Sound like an impossible conundrum yet?</p>
<h3 id="Uncaught-Handling"><a href="#Uncaught-Handling" class="headerlink" title="Uncaught Handling"></a>Uncaught Handling</h3><p>It’s not exactly an easy problem to solve completely. There are other ways to approach it which many would say are <em>better</em>.</p>
<p>Some Promise libraries have added methods for registering something like a “global unhandled rejection” handler, which would be called instead of a globally thrown error. But their solution for how to identify an error as “uncaught” is to have an arbitrary-length timer, say 3 seconds, running from time of rejection. If a Promise is rejected but no error handler is registered before the timer fires, then it’s assumed that you won’t ever be registering a handler, so it’s “uncaught.”</p>
<p>In practice, this has worked well for many libraries, as most usage patterns don’t typically call for significant delay between Promise rejection and observation of that rejection. But this pattern is troublesome because 3 seconds is so arbitrary (even if empirical), and also because there are indeed some cases where you want a Promise to hold on to its rejectedness for some indefinite period of time, and you don’t really want to have your “uncaught” handler called for all those false positives (not-yet-handled “uncaught errors”).</p>
<p>Another more common suggestion is that Promises should have a <code>done(..)</code> added to them, which essentially marks the Promise chain as “done.” <code>done(..)</code> doesn’t create and return a Promise, so the callbacks passed to <code>done(..)</code> are obviously not wired up to report problems to a chained Promise that doesn’t exist.</p>
<p>So what happens instead? It’s treated as you might usually expect in uncaught error conditions: any exception inside a <code>done(..)</code> rejection handler would be thrown as a global uncaught error (in the developer console, basically):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// numbers don't have string functions,</span></span><br><span class="line">		<span class="comment">// so will throw an error</span></span><br><span class="line">		<span class="built_in">console</span>.log( msg.toLowerCase() );</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">.done( <span class="literal">null</span>, handleErrors );</span><br><span class="line"></span><br><span class="line"><span class="comment">// if `handleErrors(..)` caused its own exception, it would</span></span><br><span class="line"><span class="comment">// be thrown globally here</span></span><br></pre></td></tr></table></figure>
<p>This might sound more attractive than the never-ending chain or the arbitrary timeouts. But the biggest problem is that it’s not part of the ES6 standard, so no matter how good it sounds, at best it’s a lot longer way off from being a reliable and ubiquitous solution.</p>
<p>Are we just stuck, then? Not entirely.</p>
<p>Browsers have a unique capability that our code does not have: they can track and know for sure when any object gets thrown away and garbage collected. So, browsers can track Promise objects, and whenever they get garbage collected, if they have a rejection in them, the browser knows for sure this was a legitimate “uncaught error,” and can thus confidently know it should report it to the developer console.</p>
<p><strong>Note:</strong> At the time of this writing, both Chrome and Firefox have early attempts at that sort of “uncaught rejection” capability, though support is incomplete at best.</p>
<p>However, if a Promise doesn’t get garbage collected – it’s exceedingly easy for that to accidentally happen through lots of different coding patterns – the browser’s garbage collection sniffing won’t help you know and diagnose that you have a silently rejected Promise laying around.</p>
<p>Is there any other alternative? Yes.</p>
<h3 id="Pit-of-Success"><a href="#Pit-of-Success" class="headerlink" title="Pit of Success"></a>Pit of Success</h3><p>The following is just theoretical, how Promises <em>could</em> be someday changed to behave. I believe it would be far superior to what we currently have. And I think this change would be possible even post-ES6 because I don’t think it would break web compatibility with ES6 Promises. Moreover, it can be polyfilled/prollyfilled in, if you’re careful. Let’s take a look:</p>
<ul>
<li>Promises could default to reporting (to the developer console) any rejection, on the next Job or event loop tick, if at that exact moment no error handler has been registered for the Promise.</li>
<li>For the cases where you want a rejected Promise to hold onto its rejected state for an indefinite amount of time before observing, you could call <code>defer()</code>, which suppresses automatic error reporting on that Promise.</li>
</ul>
<p>If a Promise is rejected, it defaults to noisily reporting that fact to the developer console (instead of defaulting to silence). You can opt out of that reporting either implicitly (by registering an error handler before rejection), or explicitly (with <code>defer()</code>). In either case, <em>you</em> control the false positives.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject( <span class="string">"Oops"</span> ).defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo(..)` is Promise-aware</span></span><br><span class="line">foo( <span class="number">42</span> )</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// handle `foo(..)` error</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>When we create <code>p</code>, we know we’re going to wait a while to use/observe its rejection, so we call <code>defer()</code> – thus no global reporting. <code>defer()</code> simply returns the same promise, for chaining purposes.</p>
<p>The promise returned from <code>foo(..)</code> gets an error handler attached <em>right away</em>, so it’s implicitly opted out and no global reporting for it occurs either.</p>
<p>But the promise returned from the <code>then(..)</code> call has no <code>defer()</code> or error handler attached, so if it rejects (from inside either resolution handler), then <em>it</em> will be reported to the developer console as an uncaught error.</p>
<p><strong>This design is a pit of success.</strong> By default, all errors are either handled or reported – what almost all developers in almost all cases would expect. You either have to register a handler or you have to intentionally opt out, and indicate you intend to defer error handling until <em>later</em>; you’re opting for the extra responsibility in just that specific case.</p>
<p>The only real danger in this approach is if you <code>defer()</code> a Promise but then fail to actually ever observe/handle its rejection.</p>
<p>But you had to intentionally call <code>defer()</code> to opt into that pit of despair – the default was the pit of success – so there’s not much else we could do to save you from your own mistakes.</p>
<p>I think there’s still hope for Promise error handling (post-ES6). I hope the powers that be will rethink the situation and consider this alternative. In the meantime, you can implement this yourself (a challenging exercise for the reader!), or use a <em>smarter</em> Promise library that does so for you!</p>
<p><strong>Note:</strong> This exact model for error handling/reporting is implemented in my <em>asynquence</em> Promise abstraction library, which will be discussed in Appendix A of this book.</p>
<h2 id="Promise-Patterns"><a href="#Promise-Patterns" class="headerlink" title="Promise Patterns"></a>Promise Patterns</h2><p>We’ve already implicitly seen the sequence pattern with Promise chains (this-then-this-then-that flow control) but there are lots of variations on asynchronous patterns that we can build as abstractions on top of Promises. These patterns serve to simplify the expression of async flow control – which helps make our code more reason-able and more maintainable – even in the most complex parts of our programs.</p>
<p>Two such patterns are codified directly into the native ES6 <code>Promise</code> implementation, so we get them for free, to use as building blocks for other patterns.</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([ .. ])"></a>Promise.all([ .. ])</h3><p>In an async sequence (Promise chain), only one async task is being coordinated at any given moment – step 2 strictly follows step 1, and step 3 strictly follows step 2. But what about doing two or more steps concurrently (aka “in parallel”)?</p>
<p>In classic programming terminology, a “gate” is a mechanism that waits on two or more parallel/concurrent tasks to complete before continuing. It doesn’t matter what order they finish in, just that all of them have to complete for the gate to open and let the flow control through.</p>
<p>In the Promise API, we call this pattern <code>all([ .. ])</code>.</p>
<p>Say you wanted to make two Ajax requests at the same time, and wait for both to finish, regardless of their order, before making a third Ajax request. Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility,</span></span><br><span class="line"><span class="comment">// like we defined earlier in the chapter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = request( <span class="string">"http://some.url.1/"</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = request( <span class="string">"http://some.url.2/"</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all( [p1,p2] )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// both `p1` and `p2` fulfill and pass in</span></span><br><span class="line">	<span class="comment">// their messages here</span></span><br><span class="line">	<span class="keyword">return</span> request(</span><br><span class="line">		<span class="string">"http://some.url.3/?v="</span> + msgs.join(<span class="string">","</span>)</span><br><span class="line">	);</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>Promise.all([ .. ])</code> expects a single argument, an <code>array</code>, consisting generally of Promise instances. The promise returned from the <code>Promise.all([ .. ])</code> call will receive a fulfillment message (<code>msgs</code> in this snippet) that is an <code>array</code> of all the fulfillment messages from the passed in promises, in the same order as specified (regardless of fulfillment order).</p>
<p><strong>Note:</strong> Technically, the <code>array</code> of values passed into <code>Promise.all([ .. ])</code> can include Promises, thenables, or even immediate values. Each value in the list is essentially passed through <code>Promise.resolve(..)</code> to make sure it’s a genuine Promise to be waited on, so an immediate value will just be normalized into a Promise for that value. If the <code>array</code> is empty, the main Promise is immediately fulfilled.</p>
<p>The main promise returned from <code>Promise.all([ .. ])</code> will only be fulfilled if and when all its constituent promises are fulfilled. If any one of those promises instead is rejected, the main <code>Promise.all([ .. ])</code> promise is immediately rejected, discarding all results from any other promises.</p>
<p>Remember to always attach a rejection/error handler to every promise, even and especially the one that comes back from <code>Promise.all([ .. ])</code>.</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race([ .. ])"></a>Promise.race([ .. ])</h3><p>While <code>Promise.all([ .. ])</code> coordinates multiple Promises concurrently and assumes all are needed for fulfillment, sometimes you only want to respond to the “first Promise to cross the finish line,” letting the other Promises fall away.</p>
<p>This pattern is classically called a “latch,” but in Promises it’s called a “race.”</p>
<p><strong>Warning:</strong> While the metaphor of “only the first across the finish line wins” fits the behavior well, unfortunately “race” is kind of a loaded term, because “race conditions” are generally taken as bugs in programs (see Chapter 1). Don’t confuse <code>Promise.race([ .. ])</code> with “race condition.”</p>
<p><code>Promise.race([ .. ])</code> also expects a single <code>array</code> argument, containing one or more Promises, thenables, or immediate values. It doesn’t make much practical sense to have a race with immediate values, because the first one listed will obviously win – like a foot race where one runner starts at the finish line!</p>
<p>Similar to <code>Promise.all([ .. ])</code>, <code>Promise.race([ .. ])</code> will fulfill if and when any Promise resolution is a fulfillment, and it will reject if and when any Promise resolution is a rejection.</p>
<p><strong>Warning:</strong> A “race” requires at least one “runner,” so if you pass an empty <code>array</code>, instead of immediately resolving, the main <code>race([..])</code> Promise will never resolve. This is a footgun! ES6 should have specified that it either fulfills, rejects, or just throws some sort of synchronous error. Unfortunately, because of precedence in Promise libraries predating ES6 <code>Promise</code>, they had to leave this gotcha in there, so be careful never to send in an empty <code>array</code>.</p>
<p>Let’s revisit our previous concurrent Ajax example, but in the context of a race between <code>p1</code> and <code>p2</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility,</span></span><br><span class="line"><span class="comment">// like we defined earlier in the chapter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = request( <span class="string">"http://some.url.1/"</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = request( <span class="string">"http://some.url.2/"</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race( [p1,p2] )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// either `p1` or `p2` will win the race</span></span><br><span class="line">	<span class="keyword">return</span> request(</span><br><span class="line">		<span class="string">"http://some.url.3/?v="</span> + msg</span><br><span class="line">	);</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Because only one promise wins, the fulfillment value is a single message, not an <code>array</code> as it was for <code>Promise.all([ .. ])</code>.</p>
<h4 id="Timeout-Race"><a href="#Timeout-Race" class="headerlink" title="Timeout Race"></a>Timeout Race</h4><p>We saw this example earlier, illustrating how <code>Promise.race([ .. ])</code> can be used to express the “promise timeout” pattern:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `foo()` is a Promise-aware function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `timeoutPromise(..)`, defined ealier, returns</span></span><br><span class="line"><span class="comment">// a Promise that rejects after a specified delay</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setup a timeout for `foo()`</span></span><br><span class="line"><span class="built_in">Promise</span>.race( [</span><br><span class="line">	foo(),					<span class="comment">// attempt `foo()`</span></span><br><span class="line">	timeoutPromise( <span class="number">3000</span> )	<span class="comment">// give it 3 seconds</span></span><br><span class="line">] )</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// `foo(..)` fulfilled in time!</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// either `foo()` rejected, or it just</span></span><br><span class="line">		<span class="comment">// didn't finish in time, so inspect</span></span><br><span class="line">		<span class="comment">// `err` to know which</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>This timeout pattern works well in most cases. But there are some nuances to consider, and frankly they apply to both <code>Promise.race([ .. ])</code> and <code>Promise.all([ .. ])</code> equally.</p>
<h4 id="“Finally”"><a href="#“Finally”" class="headerlink" title="“Finally”"></a>“Finally”</h4><p>The key question to ask is, “What happens to the promises that get discarded/ignored?” We’re not asking that question from the performance perspective – they would typically end up garbage collection eligible – but from the behavioral perspective (side effects, etc.). Promises cannot be canceled – and shouldn’t be as that would destroy the external immutability trust discussed in the “Promise Uncancelable” section later in this chapter – so they can only be silently ignored.</p>
<p>But what if <code>foo()</code> in the previous example is reserving some sort of resource for usage, but the timeout fires first and causes that promise to be ignored? Is there anything in this pattern that proactively frees the reserved resource after the timeout, or otherwise cancels any side effects it may have had? What if all you wanted was to log the fact that <code>foo()</code> timed out?</p>
<p>Some developers have proposed that Promises need a <code>finally(..)</code> callback registration, which is always called when a Promise resolves, and allows you to specify any cleanup that may be necessary. This doesn’t exist in the specification at the moment, but it may come in ES7+. We’ll have to wait and see.</p>
<p>It might look like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then( something )</span><br><span class="line">.finally( cleanup )</span><br><span class="line">.then( another )</span><br><span class="line">.finally( cleanup );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> In various Promise libraries, <code>finally(..)</code> still creates and returns a new Promise (to keep the chain going). If the <code>cleanup(..)</code> function were to return a Promise, it would be linked into the chain, which means you could still have the unhandled rejection issues we discussed earlier.</p>
<p>In the meantime, we could make a static helper utility that lets us observe (without interfering) the resolution of a Promise:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polyfill-safe guard check</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Promise</span>.observe) &#123;</span><br><span class="line">	<span class="built_in">Promise</span>.observe = <span class="function"><span class="keyword">function</span>(<span class="params">pr,cb</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// side-observe `pr`'s resolution</span></span><br><span class="line">		pr.then(</span><br><span class="line">			<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">				<span class="comment">// schedule callback async (as Job)</span></span><br><span class="line">				<span class="built_in">Promise</span>.resolve( msg ).then( cb );</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">				<span class="comment">// schedule callback async (as Job)</span></span><br><span class="line">				<span class="built_in">Promise</span>.resolve( err ).then( cb );</span><br><span class="line">			&#125;</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// return original promise</span></span><br><span class="line">		<span class="keyword">return</span> pr;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here’s how we’d use it in the timeout example from before:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race( [</span><br><span class="line">	<span class="built_in">Promise</span>.observe(</span><br><span class="line">		foo(),					<span class="comment">// attempt `foo()`</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">			<span class="comment">// clean up after `foo()`, even if it</span></span><br><span class="line">			<span class="comment">// didn't finish before the timeout</span></span><br><span class="line">		&#125;</span><br><span class="line">	),</span><br><span class="line">	timeoutPromise( <span class="number">3000</span> )	<span class="comment">// give it 3 seconds</span></span><br><span class="line">] )</span><br></pre></td></tr></table></figure>
<p>This <code>Promise.observe(..)</code> helper is just an illustration of how you could observe the completions of Promises without interfering with them. Other Promise libraries have their own solutions. Regardless of how you do it, you’ll likely have places where you want to make sure your Promises aren’t <em>just</em> silently ignored by accident.</p>
<h3 id="Variations-on-all-and-race"><a href="#Variations-on-all-and-race" class="headerlink" title="Variations on all([ .. ]) and race([ .. ])"></a>Variations on all([ .. ]) and race([ .. ])</h3><p>While native ES6 Promises come with built-in <code>Promise.all([ .. ])</code> and <code>Promise.race([ .. ])</code>, there are several other commonly used patterns with variations on those semantics:</p>
<ul>
<li><code>none([ .. ])</code> is like <code>all([ .. ])</code>, but fulfillments and rejections are transposed. All Promises need to be rejected – rejections become the fulfillment values and vice versa.</li>
<li><code>any([ .. ])</code> is like <code>all([ .. ])</code>, but it ignores any rejections, so only one needs to fulfill instead of <em>all</em> of them.</li>
<li><code>first([ .. ])</code> is like a race with <code>any([ .. ])</code>, which is that it ignores any rejections and fulfills as soon as the first Promise fulfills.</li>
<li><code>last([ .. ])</code> is like <code>first([ .. ])</code>, but only the latest fulfillment wins.</li>
</ul>
<p>Some Promise abstraction libraries provide these, but you could also define them yourself using the mechanics of Promises, <code>race([ .. ])</code> and <code>all([ .. ])</code>.</p>
<p>For example, here’s how we could define <code>first([ .. ])</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polyfill-safe guard check</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Promise</span>.first) &#123;</span><br><span class="line">	<span class="built_in">Promise</span>.first = <span class="function"><span class="keyword">function</span>(<span class="params">prs</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">			<span class="comment">// loop through all promises</span></span><br><span class="line">			prs.forEach( <span class="function"><span class="keyword">function</span>(<span class="params">pr</span>)</span>&#123;</span><br><span class="line">				<span class="comment">// normalize the value</span></span><br><span class="line">				<span class="built_in">Promise</span>.resolve( pr )</span><br><span class="line">				<span class="comment">// whichever one fulfills first wins, and</span></span><br><span class="line">				<span class="comment">// gets to resolve the main promise</span></span><br><span class="line">				.then( resolve );</span><br><span class="line">			&#125; );</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> This implementation of <code>first(..)</code> does not reject if all its promises reject; it simply hangs, much like a <code>Promise.race([])</code> does. If desired, you could add additional logic to track each promise rejection and if all reject, call <code>reject()</code> on the main promise. We’ll leave that as an exercise for the reader.</p>
<h3 id="Concurrent-Iterations"><a href="#Concurrent-Iterations" class="headerlink" title="Concurrent Iterations"></a>Concurrent Iterations</h3><p>Sometimes you want to iterate over a list of Promises and perform some task against all of them, much like you can do with synchronous <code>array</code>s (e.g., <code>forEach(..)</code>, <code>map(..)</code>, <code>some(..)</code>, and <code>every(..)</code>). If the task to perform against each Promise is fundamentally synchronous, these work fine, just as we used <code>forEach(..)</code> in the previous snippet.</p>
<p>But if the tasks are fundamentally asynchronous, or can/should otherwise be performed concurrently, you can use async versions of these utilities as provided by many libraries.</p>
<p>For example, let’s consider an asynchronous <code>map(..)</code> utility that takes an <code>array</code> of values (could be Promises or anything else), plus a function (task) to perform against each. <code>map(..)</code> itself returns a promise whose fulfillment value is an <code>array</code> that holds (in the same mapping order) the async fulfillment value from each task:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Promise</span>.map) &#123;</span><br><span class="line">	<span class="built_in">Promise</span>.map = <span class="function"><span class="keyword">function</span>(<span class="params">vals,cb</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// new promise that waits for all mapped promises</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">			<span class="comment">// note: regular array `map(..)`, turns</span></span><br><span class="line">			<span class="comment">// the array of values into an array of</span></span><br><span class="line">			<span class="comment">// promises</span></span><br><span class="line">			vals.map( <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">				<span class="comment">// replace `val` with a new promise that</span></span><br><span class="line">				<span class="comment">// resolves after `val` is async mapped</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">					cb( val, resolve );</span><br><span class="line">				&#125; );</span><br><span class="line">			&#125; )</span><br><span class="line">		);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> In this implementation of <code>map(..)</code>, you can’t signal async rejection, but if a synchronous exception/error occurs inside of the mapping callback (<code>cb(..)</code>), the main <code>Promise.map(..)</code> returned promise would reject.</p>
<p>Let’s illustrate using <code>map(..)</code> with a list of Promises (instead of simple values):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">21</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject( <span class="string">"Oops"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// double values in list even if they're in</span></span><br><span class="line"><span class="comment">// Promises</span></span><br><span class="line"><span class="built_in">Promise</span>.map( [p1,p2,p3], <span class="function"><span class="keyword">function</span>(<span class="params">pr,done</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// make sure the item itself is a Promise</span></span><br><span class="line">	<span class="built_in">Promise</span>.resolve( pr )</span><br><span class="line">	.then(</span><br><span class="line">		<span class="comment">// extract value as `v`</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">			<span class="comment">// map fulfillment `v` to new value</span></span><br><span class="line">			done( v * <span class="number">2</span> );</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// or, map to promise rejection message</span></span><br><span class="line">		done</span><br><span class="line">	);</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">vals</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( vals );	<span class="comment">// [42,84,"Oops"]</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h2 id="Promise-API-Recap"><a href="#Promise-API-Recap" class="headerlink" title="Promise API Recap"></a>Promise API Recap</h2><p>Let’s review the ES6 <code>Promise</code> API that we’ve already seen unfold in bits and pieces throughout this chapter.</p>
<p><strong>Note:</strong> The following API is native only as of ES6, but there are specification-compliant polyfills (not just extended Promise libraries) which can define <code>Promise</code> and all its associated behavior so that you can use native Promises even in pre-ES6 browsers. One such polyfill is “Native Promise Only” (<a href="http://github.com/getify/native-promise-only)" target="_blank" rel="noopener">http://github.com/getify/native-promise-only)</a>, which I wrote!</p>
<h3 id="new-Promise-Constructor"><a href="#new-Promise-Constructor" class="headerlink" title="new Promise(..) Constructor"></a>new Promise(..) Constructor</h3><p>The <em>revealing constructor</em> <code>Promise(..)</code> must be used with <code>new</code>, and must be provided a function callback that is synchronously/immediately called. This function is passed two function callbacks that act as resolution capabilities for the promise. We commonly label these <code>resolve(..)</code> and <code>reject(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// `resolve(..)` to resolve/fulfill the promise</span></span><br><span class="line">	<span class="comment">// `reject(..)` to reject the promise</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>reject(..)</code> simply rejects the promise, but <code>resolve(..)</code> can either fulfill the promise or reject it, depending on what it’s passed. If <code>resolve(..)</code> is passed an immediate, non-Promise, non-thenable value, then the promise is fulfilled with that value.</p>
<p>But if <code>resolve(..)</code> is passed a genuine Promise or thenable value, that value is unwrapped recursively, and whatever its final resolution/state is will be adopted by the promise.</p>
<h3 id="Promise-resolve-and-Promise-reject"><a href="#Promise-resolve-and-Promise-reject" class="headerlink" title="Promise.resolve(..) and Promise.reject(..)"></a>Promise.resolve(..) and Promise.reject(..)</h3><p>A shortcut for creating an already-rejected Promise is <code>Promise.reject(..)</code>, so these two promises are equivalent:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	reject( <span class="string">"Oops"</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject( <span class="string">"Oops"</span> );</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve(..)</code> is usually used to create an already-fulfilled Promise in a similar way to <code>Promise.reject(..)</code>. However, <code>Promise.resolve(..)</code> also unwraps thenable values (as discussed several times already). In that case, the Promise returned adopts the final resolution of the thenable you passed in, which could either be fulfillment or rejection:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fulfilledTh = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123; cb( <span class="number">42</span> ); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> rejectedTh = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">cb,errCb</span>) </span>&#123;</span><br><span class="line">		errCb( <span class="string">"Oops"</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( fulfilledTh );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( rejectedTh );</span><br><span class="line"></span><br><span class="line"><span class="comment">// `p1` will be a fulfilled promise</span></span><br><span class="line"><span class="comment">// `p2` will be a rejected promise</span></span><br></pre></td></tr></table></figure>
<p>And remember, <code>Promise.resolve(..)</code> doesn’t do anything if what you pass is already a genuine Promise; it just returns the value directly. So there’s no overhead to calling <code>Promise.resolve(..)</code> on values that you don’t know the nature of, if one happens to already be a genuine Promise.</p>
<h3 id="then-and-catch"><a href="#then-and-catch" class="headerlink" title="then(..) and catch(..)"></a>then(..) and catch(..)</h3><p>Each Promise instance (<strong>not</strong> the <code>Promise</code> API namespace) has <code>then(..)</code> and <code>catch(..)</code> methods, which allow registering of fulfillment and rejection handlers for the Promise. Once the Promise is resolved, one or the other of these handlers will be called, but not both, and it will always be called asynchronously (see “Jobs” in Chapter 1).</p>
<p><code>then(..)</code> takes one or two parameters, the first for the fulfillment callback, and the second for the rejection callback. If either is omitted or is otherwise passed as a non-function value, a default callback is substituted respectively. The default fulfillment callback simply passes the message along, while the default rejection callback simply rethrows (propagates) the error reason it receives.</p>
<p><code>catch(..)</code> takes only the rejection callback as a parameter, and automatically substitutes the default fulfillment callback, as just discussed. In other words, it’s equivalent to <code>then(null,..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then( fulfilled );</span><br><span class="line"></span><br><span class="line">p.then( fulfilled, rejected );</span><br><span class="line"></span><br><span class="line">p.catch( rejected ); <span class="comment">// or `p.then( null, rejected )`</span></span><br></pre></td></tr></table></figure>
<p><code>then(..)</code> and <code>catch(..)</code> also create and return a new promise, which can be used to express Promise chain flow control. If the fulfillment or rejection callbacks have an exception thrown, the returned promise is rejected. If either callback returns an immediate, non-Promise, non-thenable value, that value is set as the fulfillment for the returned promise. If the fulfillment handler specifically returns a promise or thenable value, that value is unwrapped and becomes the resolution of the returned promise.</p>
<h3 id="Promise-all-and-Promise-race"><a href="#Promise-all-and-Promise-race" class="headerlink" title="Promise.all([ .. ]) and Promise.race([ .. ])"></a>Promise.all([ .. ]) and Promise.race([ .. ])</h3><p>The static helpers <code>Promise.all([ .. ])</code> and <code>Promise.race([ .. ])</code> on the ES6 <code>Promise</code> API both create a Promise as their return value. The resolution of that promise is controlled entirely by the array of promises that you pass in.</p>
<p>For <code>Promise.all([ .. ])</code>, all the promises you pass in must fulfill for the returned promise to fulfill. If any promise is rejected, the main returned promise is immediately rejected, too (discarding the results of any of the other promises). For fulfillment, you receive an <code>array</code> of all the passed in promises’ fulfillment values. For rejection, you receive just the first promise rejection reason value. This pattern is classically called a “gate”: all must arrive before the gate opens.</p>
<p>For <code>Promise.race([ .. ])</code>, only the first promise to resolve (fulfillment or rejection) “wins,” and whatever that resolution is becomes the resolution of the returned promise. This pattern is classically called a “latch”: first one to open the latch gets through. Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="string">"Hello World"</span> );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject( <span class="string">"Oops"</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race( [p1,p2,p3] )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all( [p1,p2,p3] )</span><br><span class="line">.catch( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.error( err );	<span class="comment">// "Oops"</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all( [p1,p2] )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msgs );	<span class="comment">// [42,"Hello World"]</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Warning:</strong> Be careful! If an empty <code>array</code> is passed to <code>Promise.all([ .. ])</code>, it will fulfill immediately, but <code>Promise.race([ .. ])</code> will hang forever and never resolve.</p>
<p>The ES6 <code>Promise</code> API is pretty simple and straightforward. It’s at least good enough to serve the most basic of async cases, and is a good place to start when rearranging your code from callback hell to something better.</p>
<p>But there’s a whole lot of async sophistication that apps often demand which Promises themselves will be limited in addressing. In the next section, we’ll dive into those limitations as motivations for the benefit of Promise libraries.</p>
<h2 id="Promise-Limitations"><a href="#Promise-Limitations" class="headerlink" title="Promise Limitations"></a>Promise Limitations</h2><p>Many of the details we’ll discuss in this section have already been alluded to in this chapter, but we’ll just make sure to review these limitations specifically.</p>
<h3 id="Sequence-Error-Handling"><a href="#Sequence-Error-Handling" class="headerlink" title="Sequence Error Handling"></a>Sequence Error Handling</h3><p>We covered Promise-flavored error handling in detail earlier in this chapter. The limitations of how Promises are designed – how they chain, specifically – creates a very easy pitfall where an error in a Promise chain can be silently ignored accidentally.</p>
<p>But there’s something else to consider with Promise errors. Because a Promise chain is nothing more than its constituent Promises wired together, there’s no entity to refer to the entire chain as a single <em>thing</em>, which means there’s no external way to observe any errors that may occur.</p>
<p>If you construct a Promise chain that has no error handling in it, any error anywhere in the chain will propagate indefinitely down the chain, until observed (by registering a rejection handler at some step). So, in that specific case, having a reference to the <em>last</em> promise in the chain is enough (<code>p</code> in the following snippet), because you can register a rejection handler there, and it will be notified of any propagated errors:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `foo(..)`, `STEP2(..)` and `STEP3(..)` are</span></span><br><span class="line"><span class="comment">// all promise-aware utilities</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = foo( <span class="number">42</span> )</span><br><span class="line">.then( STEP2 )</span><br><span class="line">.then( STEP3 );</span><br></pre></td></tr></table></figure>
<p>Although it may seem sneakily confusing, <code>p</code> here doesn’t point to the first promise in the chain (the one from the <code>foo(42)</code> call), but instead from the last promise, the one that comes from the <code>then(STEP3)</code> call.</p>
<p>Also, no step in the promise chain is observably doing its own error handling. That means that you could then register a rejection error handler on <code>p</code>, and it would be notified if any errors occur anywhere in the chain:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.catch( handleErrors );</span><br></pre></td></tr></table></figure>
<p>But if any step of the chain in fact does its own error handling (perhaps hidden/abstracted away from what you can see), your <code>handleErrors(..)</code> won’t be notified. This may be what you want – it was, after all, a “handled rejection” – but it also may <em>not</em> be what you want. The complete lack of ability to be notified (of “already handled” rejection errors) is a limitation that restricts capabilities in some use cases.</p>
<p>It’s basically the same limitation that exists with a <code>try..catch</code> that can catch an exception and simply swallow it. So this isn’t a limitation <strong>unique to Promises</strong>, but it <em>is</em> something we might wish to have a workaround for.</p>
<p>Unfortunately, many times there is no reference kept for the intermediate steps in a Promise-chain sequence, so without such references, you cannot attach error handlers to reliably observe the errors.</p>
<h3 id="Single-Value"><a href="#Single-Value" class="headerlink" title="Single Value"></a>Single Value</h3><p>Promises by definition only have a single fulfillment value or a single rejection reason. In simple examples, this isn’t that big of a deal, but in more sophisticated scenarios, you may find this limiting.</p>
<p>The typical advice is to construct a values wrapper (such as an <code>object</code> or <code>array</code>) to contain these multiple messages. This solution works, but it can be quite awkward and tedious to wrap and unwrap your messages with every single step of your Promise chain.</p>
<h4 id="Splitting-Values"><a href="#Splitting-Values" class="headerlink" title="Splitting Values"></a>Splitting Values</h4><p>Sometimes you can take this as a signal that you could/should decompose the problem into two or more Promises.</p>
<p>Imagine you have a utility <code>foo(..)</code> that produces two values (<code>x</code> and <code>y</code>) asynchronously:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getY</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			resolve( (<span class="number">3</span> * x) - <span class="number">1</span> );</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar,baz</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = bar * baz;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> getY( x )</span><br><span class="line">	.then( <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// wrap both values into container</span></span><br><span class="line">		<span class="keyword">return</span> [x,y];</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = msgs[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">var</span> y = msgs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( x, y );	<span class="comment">// 200 599</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>First, let’s rearrange what <code>foo(..)</code> returns so that we don’t have to wrap <code>x</code> and <code>y</code> into a single <code>array</code> value to transport through one Promise. Instead, we can wrap each value into its own promise:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar,baz</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = bar * baz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return both promises</span></span><br><span class="line">	<span class="keyword">return</span> [</span><br><span class="line">		<span class="built_in">Promise</span>.resolve( x ),</span><br><span class="line">		getY( x )</span><br><span class="line">	];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">	foo( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line">)</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = msgs[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">var</span> y = msgs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( x, y );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Is an <code>array</code> of promises really better than an <code>array</code> of values passed through a single promise? Syntactically, it’s not much of an improvement.</p>
<p>But this approach more closely embraces the Promise design theory. It’s now easier in the future to refactor to split the calculation of <code>x</code> and <code>y</code> into separate functions. It’s cleaner and more flexible to let the calling code decide how to orchestrate the two promises – using <code>Promise.all([ .. ])</code> here, but certainly not the only option – rather than to abstract such details away inside of <code>foo(..)</code>.</p>
<h4 id="Unwrap-Spread-Arguments"><a href="#Unwrap-Spread-Arguments" class="headerlink" title="Unwrap/Spread Arguments"></a>Unwrap/Spread Arguments</h4><p>The <code>var x = ..</code> and <code>var y = ..</code> assignments are still awkward overhead. We can employ some functional trickery (hat tip to Reginald Braithwaite, @raganwald on Twitter) in a helper utility:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spread</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Function</span>.apply.bind( fn, <span class="literal">null</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">	foo( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">	spread( <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( x, y );	<span class="comment">// 200 599</span></span><br><span class="line">	&#125; )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>That’s a bit nicer! Of course, you could inline the functional magic to avoid the extra helper:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">	foo( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line">)</span><br><span class="line">.then( <span class="built_in">Function</span>.apply.bind(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( x, y );	<span class="comment">// 200 599</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="literal">null</span></span><br><span class="line">) );</span><br></pre></td></tr></table></figure>
<p>These tricks may be neat, but ES6 has an even better answer for us: destructuring. The array destructuring assignment form looks like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">	foo( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line">)</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> [x,y] = msgs;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( x, y );	<span class="comment">// 200 599</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>But best of all, ES6 offers the array parameter destructuring form:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(</span><br><span class="line">	foo( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line">)</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">[x,y]</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( x, y );	<span class="comment">// 200 599</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>We’ve now embraced the one-value-per-Promise mantra, but kept our supporting boilerplate to a minimum!</p>
<p><strong>Note:</strong> For more information on ES6 destructuring forms, see the <em>ES6 &amp; Beyond</em> title of this series.</p>
<h3 id="Single-Resolution"><a href="#Single-Resolution" class="headerlink" title="Single Resolution"></a>Single Resolution</h3><p>One of the most intrinsic behaviors of Promises is that a Promise can only be resolved once (fulfillment or rejection). For many async use cases, you’re only retrieving a value once, so this works fine.</p>
<p>But there’s also a lot of async cases that fit into a different model – one that’s more akin to events and/or streams of data. It’s not clear on the surface how well Promises can fit into such use cases, if at all. Without a significant abstraction on top of Promises, they will completely fall short for handling multiple value resolution.</p>
<p>Imagine a scenario where you might want to fire off a sequence of async steps in response to a stimulus (like an event) that can in fact happen multiple times, like a button click.</p>
<p>This probably won’t work the way you want:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `click(..)` binds the `"click"` event to a DOM element</span></span><br><span class="line"><span class="comment">// `request(..)` is the previously defined Promise-aware Ajax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	click( <span class="string">"#mybtn"</span>, resolve );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> btnID = evt.currentTarget.id;</span><br><span class="line">	<span class="keyword">return</span> request( <span class="string">"http://some.url.1/?id="</span> + btnID );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( text );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The behavior here only works if your application calls for the button to be clicked just once. If the button is clicked a second time, the <code>p</code> promise has already been resolved, so the second <code>resolve(..)</code> call would be ignored.</p>
<p>Instead, you’d probably need to invert the paradigm, creating a whole new Promise chain for each event firing:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">click( <span class="string">"#mybtn"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> btnID = evt.currentTarget.id;</span><br><span class="line"></span><br><span class="line">	request( <span class="string">"http://some.url.1/?id="</span> + btnID )</span><br><span class="line">	.then( <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>This approach will <em>work</em> in that a whole new Promise sequence will be fired off for each <code>&quot;click&quot;</code> event on the button.</p>
<p>But beyond just the ugliness of having to define the entire Promise chain inside the event handler, this design in some respects violates the idea of separation of concerns/capabilities (SoC). You might very well want to define your event handler in a different place in your code from where you define the <em>response</em> to the event (the Promise chain). That’s pretty awkward to do in this pattern, without helper mechanisms.</p>
<p><strong>Note:</strong> Another way of articulating this limitation is that it’d be nice if we could construct some sort of “observable” that we can subscribe a Promise chain to. There are libraries that have created these abstractions (such as RxJS – <a href="http://rxjs.codeplex.com/)" target="_blank" rel="noopener">http://rxjs.codeplex.com/)</a>, but the abstractions can seem so heavy that you can’t even see the nature of Promises anymore. Such heavy abstraction brings important questions to mind such as whether (sans Promises) these mechanisms are as <em>trustable</em> as Promises themselves have been designed to be. We’ll revisit the “Observable” pattern in Appendix B.</p>
<h3 id="Inertia"><a href="#Inertia" class="headerlink" title="Inertia"></a>Inertia</h3><p>One concrete barrier to starting to use Promises in your own code is all the code that currently exists which is not already Promise-aware. If you have lots of callback-based code, it’s far easier to just keep coding in that same style.</p>
<p>“A code base in motion (with callbacks) will remain in motion (with callbacks) unless acted upon by a smart, Promises-aware developer.”</p>
<p>Promises offer a different paradigm, and as such, the approach to the code can be anywhere from just a little different to, in some cases, radically different. You have to be intentional about it, because Promises will not just naturally shake out from the same ol’ ways of doing code that have served you well thus far.</p>
<p>Consider a callback-based scenario like the following:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,cb</span>) </span>&#123;</span><br><span class="line">	ajax(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y,</span><br><span class="line">		cb</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">11</span>, <span class="number">31</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,text</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Is it immediately obvious what the first steps are to convert this callback-based code to Promise-aware code? Depends on your experience. The more practice you have with it, the more natural it will feel. But certainly, Promises don’t just advertise on the label exactly how to do it – there’s no one-size-fits-all answer – so the responsibility is up to you.</p>
<p>As we’ve covered before, we definitely need an Ajax utility that is Promise-aware instead of callback-based, which we could call <code>request(..)</code>. You can make your own, as we have already. But the overhead of having to manually define Promise-aware wrappers for every callback-based utility makes it less likely you’ll choose to refactor to Promise-aware coding at all.</p>
<p>Promises offer no direct answer to that limitation. Most Promise libraries do offer a helper, however. But even without a library, imagine a helper like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polyfill-safe guard check</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Promise</span>.wrap) &#123;</span><br><span class="line">	<span class="built_in">Promise</span>.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> args = [].slice.call( <span class="built_in">arguments</span> );</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">				fn.apply(</span><br><span class="line">					<span class="literal">null</span>,</span><br><span class="line">					args.concat( <span class="function"><span class="keyword">function</span>(<span class="params">err,v</span>)</span>&#123;</span><br><span class="line">						<span class="keyword">if</span> (err) &#123;</span><br><span class="line">							reject( err );</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							resolve( v );</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; )</span><br><span class="line">				);</span><br><span class="line">			&#125; );</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK, that’s more than just a tiny trivial utility. However, although it may look a bit intimidating, it’s not as bad as you’d think. It takes a function that expects an error-first style callback as its last parameter, and returns a new one that automatically creates a Promise to return, and substitutes the callback for you, wired up to the Promise fulfillment/rejection.</p>
<p>Rather than waste too much time talking about <em>how</em> this <code>Promise.wrap(..)</code> helper works, let’s just look at how we use it:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">Promise</span>.wrap( ajax );</span><br><span class="line"></span><br><span class="line">request( <span class="string">"http://some.url.1/"</span> )</span><br><span class="line">.then( .. )</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>Wow, that was pretty easy!</p>
<p><code>Promise.wrap(..)</code> does <strong>not</strong> produce a Promise. It produces a function that will produce Promises. In a sense, a Promise-producing function could be seen as a “Promise factory.” I propose “promisory” as the name for such a thing (“Promise” + “factory”).</p>
<p>The act of wrapping a callback-expecting function to be a Promise-aware function is sometimes referred to as “lifting” or “promisifying”. But there doesn’t seem to be a standard term for what to call the resultant function other than a “lifted function”, so I like “promisory” better as I think it’s more descriptive.</p>
<p><strong>Note:</strong> Promisory isn’t a made-up term. It’s a real word, and its definition means to contain or convey a promise. That’s exactly what these functions are doing, so it turns out to be a pretty perfect terminology match!</p>
<p>So, <code>Promise.wrap(ajax)</code> produces an <code>ajax(..)</code> promisory we call <code>request(..)</code>, and that promisory produces Promises for Ajax responses.</p>
<p>If all functions were already promisories, we wouldn’t need to make them ourselves, so the extra step is a tad bit of a shame. But at least the wrapping pattern is (usually) repeatable so we can put it into a <code>Promise.wrap(..)</code> helper as shown to aid our promise coding.</p>
<p>So back to our earlier example, we need a promisory for both <code>ajax(..)</code> and <code>foo(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a promisory for `ajax(..)`</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">Promise</span>.wrap( ajax );</span><br><span class="line"></span><br><span class="line"><span class="comment">// refactor `foo(..)`, but keep it externally</span></span><br><span class="line"><span class="comment">// callback-based for compatibility with other</span></span><br><span class="line"><span class="comment">// parts of the code for now -- only use</span></span><br><span class="line"><span class="comment">// `request(..)`'s promise internally.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,cb</span>) </span>&#123;</span><br><span class="line">	request(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y</span><br><span class="line">	)</span><br><span class="line">	.then(</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">			cb( <span class="literal">null</span>, text );</span><br><span class="line">		&#125;,</span><br><span class="line">		cb</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now, for this code's purposes, make a</span></span><br><span class="line"><span class="comment">// promisory for `foo(..)`</span></span><br><span class="line"><span class="keyword">var</span> betterFoo = <span class="built_in">Promise</span>.wrap( foo );</span><br><span class="line"></span><br><span class="line"><span class="comment">// and use the promisory</span></span><br><span class="line">betterFoo( <span class="number">11</span>, <span class="number">31</span> )</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Of course, while we’re refactoring <code>foo(..)</code> to use our new <code>request(..)</code> promisory, we could just make <code>foo(..)</code> a promisory itself, instead of remaining callback-based and needing to make and use the subsequent <code>betterFoo(..)</code> promisory. This decision just depends on whether <code>foo(..)</code> needs to stay callback-based compatible with other parts of the code base or not.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `foo(..)` is now also a promisory because it</span></span><br><span class="line"><span class="comment">// delegates to the `request(..)` promisory</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> request(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">11</span>, <span class="number">31</span> )</span><br><span class="line">.then( .. )</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>While ES6 Promises don’t natively ship with helpers for such promisory wrapping, most libraries provide them, or you can make your own. Either way, this particular limitation of Promises is addressable without too much pain (certainly compared to the pain of callback hell!).</p>
<h3 id="Promise-Uncancelable"><a href="#Promise-Uncancelable" class="headerlink" title="Promise Uncancelable"></a>Promise Uncancelable</h3><p>Once you create a Promise and register a fulfillment and/or rejection handler for it, there’s nothing external you can do to stop that progression if something else happens to make that task moot.</p>
<p><strong>Note:</strong> Many Promise abstraction libraries provide facilities to cancel Promises, but this is a terrible idea! Many developers wish Promises had natively been designed with external cancelation capability, but the problem is that it would let one consumer/observer of a Promise affect some other consumer’s ability to observe that same Promise. This violates the future-value’s trustability (external immutability), but moreover is the embodiment of the “action at a distance” anti-pattern (<a href="http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Action_at_a_distance_%28computer_programming%29)</a>. Regardless of how useful it seems, it will actually lead you straight back into the same nightmares as callbacks.</p>
<p>Consider our Promise timeout scenario from earlier:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = foo( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race( [</span><br><span class="line">	p,</span><br><span class="line">	timeoutPromise( <span class="number">3000</span> )</span><br><span class="line">] )</span><br><span class="line">.then(</span><br><span class="line">	doSomething,</span><br><span class="line">	handleError</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// still happens even in the timeout case :(</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The “timeout” was external to the promise <code>p</code>, so <code>p</code> itself keeps going, which we probably don’t want.</p>
<p>One option is to invasively define your resolution callbacks:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> OK = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = foo( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race( [</span><br><span class="line">	p,</span><br><span class="line">	timeoutPromise( <span class="number">3000</span> )</span><br><span class="line">	.catch( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		OK = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">throw</span> err;</span><br><span class="line">	&#125; )</span><br><span class="line">] )</span><br><span class="line">.then(</span><br><span class="line">	doSomething,</span><br><span class="line">	handleError</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (OK) &#123;</span><br><span class="line">		<span class="comment">// only happens if no timeout! :)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>This is ugly. It works, but it’s far from ideal. Generally, you should try to avoid such scenarios.</p>
<p>But if you can’t, the ugliness of this solution should be a clue that <em>cancelation</em> is a functionality that belongs at a higher level of abstraction on top of Promises. I’d recommend you look to Promise abstraction libraries for assistance rather than hacking it yourself.</p>
<p><strong>Note:</strong> My <em>asynquence</em> Promise abstraction library provides just such an abstraction and an <code>abort()</code> capability for the sequence, all of which will be discussed in Appendix A.</p>
<p>A single Promise is not really a flow-control mechanism (at least not in a very meaningful sense), which is exactly what <em>cancelation</em> refers to; that’s why Promise cancelation would feel awkward.</p>
<p>By contrast, a chain of Promises taken collectively together – what I like to call a “sequence” – <em>is</em> a flow control expression, and thus it’s appropriate for cancelation to be defined at that level of abstraction.</p>
<p>No individual Promise should be cancelable, but it’s sensible for a <em>sequence</em> to be cancelable, because you don’t pass around a sequence as a single immutable value like you do with a Promise.</p>
<h3 id="Promise-Performance"><a href="#Promise-Performance" class="headerlink" title="Promise Performance"></a>Promise Performance</h3><p>This particular limitation is both simple and complex.</p>
<p>Comparing how many pieces are moving with a basic callback-based async task chain versus a Promise chain, it’s clear Promises have a fair bit more going on, which means they are naturally at least a tiny bit slower. Think back to just the simple list of trust guarantees that Promises offer, as compared to the ad hoc solution code you’d have to layer on top of callbacks to achieve the same protections.</p>
<p>More work to do, more guards to protect, means that Promises <em>are</em> slower as compared to naked, untrustable callbacks. That much is obvious, and probably simple to wrap your brain around.</p>
<p>But how much slower? Well… that’s actually proving to be an incredibly difficult question to answer absolutely, across the board.</p>
<p>Frankly, it’s kind of an apples-to-oranges comparison, so it’s probably the wrong question to ask. You should actually compare whether an ad-hoc callback system with all the same protections manually layered in is faster than a Promise implementation.</p>
<p>If Promises have a legitimate performance limitation, it’s more that they don’t really offer a line-item choice as to which trustability protections you want/need or not – you get them all, always.</p>
<p>Nevertheless, if we grant that a Promise is generally a <em>little bit slower</em> than its non-Promise, non-trustable callback equivalent – assuming there are places where you feel you can justify the lack of trustability – does that mean that Promises should be avoided across the board, as if your entire application is driven by nothing but must-be-utterly-the-fastest code possible?</p>
<p>Sanity check: if your code is legitimately like that, <strong>is JavaScript even the right language for such tasks?</strong> JavaScript can be optimized to run applications very performantly (see Chapter 5 and Chapter 6). But is obsessing over tiny performance tradeoffs with Promises, in light of all the benefits they offer, <em>really</em> appropriate?</p>
<p>Another subtle issue is that Promises make <em>everything</em> async, which means that some immediately (synchronously) complete steps still defer advancement of the next step to a Job (see Chapter 1). That means that it’s possible that a sequence of Promise tasks could complete ever-so-slightly slower than the same sequence wired up with callbacks.</p>
<p>Of course, the question here is this: are these potential slips in tiny fractions of performance <em>worth</em> all the other articulated benefits of Promises we’ve laid out across this chapter?</p>
<p>My take is that in virtually all cases where you might think Promise performance is slow enough to be concerned, it’s actually an anti-pattern to optimize away the benefits of Promise trustability and composability by avoiding them altogether.</p>
<p>Instead, you should default to using them across the code base, and then profile and analyze your application’s hot (critical) paths. Are Promises <em>really</em> a bottleneck, or are they just a theoretical slowdown? Only <em>then</em>, armed with actual valid benchmarks (see Chapter 6) is it responsible and prudent to factor out the Promises in just those identified critical areas.</p>
<p>Promises are a little slower, but in exchange you’re getting a lot of trustability, non-Zalgo predictability, and composability built in. Maybe the limitation is not actually their performance, but your lack of perception of their benefits?</p>
<h2 id="Review-2"><a href="#Review-2" class="headerlink" title="Review"></a>Review</h2><p>Promises are awesome. Use them. They solve the <em>inversion of control</em> issues that plague us with callbacks-only code.</p>
<p>They don’t get rid of callbacks, they just redirect the orchestration of those callbacks to a trustable intermediary mechanism that sits between us and another utility.</p>
<p>Promise chains also begin to address (though certainly not perfectly) a better way of expressing async flow in sequential fashion, which helps our brains plan and maintain async JS code better. We’ll see an even better solution to <em>that</em> problem in the next chapter!</p>
<h1 id="Chapter-4-Generators"><a href="#Chapter-4-Generators" class="headerlink" title="Chapter 4: Generators"></a>Chapter 4: Generators</h1><p>In Chapter 2, we identified two key drawbacks to expressing async flow control with callbacks:</p>
<ul>
<li>Callback-based async doesn’t fit how our brain plans out steps of a task.</li>
<li>Callbacks aren’t trustable or composable because of <em>inversion of control</em>.</li>
</ul>
<p>In Chapter 3, we detailed how Promises uninvert the <em>inversion of control</em> of callbacks, restoring trustability/composability.</p>
<p>Now we turn our attention to expressing async flow control in a sequential, synchronous-looking fashion. The “magic” that makes it possible is ES6 <strong>generators</strong>.</p>
<h2 id="Breaking-Run-to-Completion"><a href="#Breaking-Run-to-Completion" class="headerlink" title="Breaking Run-to-Completion"></a>Breaking Run-to-Completion</h2><p>In Chapter 1, we explained an expectation that JS developers almost universally rely on in their code: once a function starts executing, it runs until it completes, and no other code can interrupt and run in between.</p>
<p>As bizarre as it may seem, ES6 introduces a new type of function that does not behave with the run-to-completion behavior. This new type of function is called a “generator.”</p>
<p>To understand the implications, let’s consider this example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">	bar();				<span class="comment">// &lt;-- what about this line?</span></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"x:"</span>, x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();					<span class="comment">// x: 3</span></span><br></pre></td></tr></table></figure>
<p>In this example, we know for sure that <code>bar()</code> runs in between <code>x++</code> and <code>console.log(x)</code>. But what if <code>bar()</code> wasn’t there? Obviously, the result would be <code>2</code> instead of <code>3</code>.</p>
<p>Now let’s twist your brain. What if <code>bar()</code> wasn’t present, but it could still somehow run between the <code>x++</code> and <code>console.log(x)</code> statements? How would that be possible?</p>
<p>In <strong>preemptive</strong> multithreaded languages, it would essentially be possible for <code>bar()</code> to “interrupt” and run at exactly the right moment between those two statements. But JS is not preemptive, nor is it (currently) multithreaded. And yet, a <strong>cooperative</strong> form of this “interruption” (concurrency) is possible, if <code>foo()</code> itself could somehow indicate a “pause” at that part in the code.</p>
<p><strong>Note:</strong> I use the word “cooperative” not only because of the connection to classical concurrency terminology (see Chapter 1), but because as you’ll see in the next snippet, the ES6 syntax for indicating a pause point in code is <code>yield</code> – suggesting a politely <em>cooperative</em> yielding of control.</p>
<p>Here’s the ES6 code to accomplish such cooperative concurrency:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">	<span class="keyword">yield</span>; <span class="comment">// pause!</span></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"x:"</span>, x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> You will likely see most other JS documentation/code that will format a generator declaration as <code>function* foo() { .. }</code> instead of as I’ve done here with <code>function *foo() { .. }</code> – the only difference being the stylistic positioning of the <code>*</code>. The two forms are functionally/syntactically identical, as is a third <code>function*foo() { .. }</code> (no space) form. There are arguments for both styles, but I basically prefer <code>function *foo..</code> because it then matches when I reference a generator in writing with <code>*foo()</code>. If I said only <code>foo()</code>, you wouldn’t know as clearly if I was talking about a generator or a regular function. It’s purely a stylistic preference.</p>
<p>Now, how can we run the code in that previous snippet such that <code>bar()</code> executes at the point of the <code>yield</code> inside of <code>*foo()</code>?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct an iterator `it` to control the generator</span></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// start `foo()` here!</span></span><br><span class="line">it.next();</span><br><span class="line">x;						<span class="comment">// 2</span></span><br><span class="line">bar();</span><br><span class="line">x;						<span class="comment">// 3</span></span><br><span class="line">it.next();				<span class="comment">// x: 3</span></span><br></pre></td></tr></table></figure>
<p>OK, there’s quite a bit of new and potentially confusing stuff in those two code snippets, so we’ve got plenty to wade through. But before we explain the different mechanics/syntax with ES6 generators, let’s walk through the behavior flow:</p>
<ol>
<li>The <code>it = foo()</code> operation does <em>not</em> execute the <code>*foo()</code> generator yet, but it merely constructs an <em>iterator</em> that will control its execution. More on <em>iterators</em> in a bit.</li>
<li>The first <code>it.next()</code> starts the <code>*foo()</code> generator, and runs the <code>x++</code> on the first line of <code>*foo()</code>.</li>
<li><code>*foo()</code> pauses at the <code>yield</code> statement, at which point that first <code>it.next()</code> call finishes. At the moment, <code>*foo()</code> is still running and active, but it’s in a paused state.</li>
<li>We inspect the value of <code>x</code>, and it’s now <code>2</code>.</li>
<li>We call <code>bar()</code>, which increments <code>x</code> again with <code>x++</code>.</li>
<li>We inspect the value of <code>x</code> again, and it’s now <code>3</code>.</li>
<li>The final <code>it.next()</code> call resumes the <code>*foo()</code> generator from where it was paused, and runs the <code>console.log(..)</code> statement, which uses the current value of <code>x</code> of <code>3</code>.</li>
</ol>
<p>Clearly, <code>*foo()</code> started, but did <em>not</em> run-to-completion – it paused at the <code>yield</code>. We resumed <code>*foo()</code> later, and let it finish, but that wasn’t even required.</p>
<p>So, a generator is a special kind of function that can start and stop one or more times, and doesn’t necessarily ever have to finish. While it won’t be terribly obvious yet why that’s so powerful, as we go throughout the rest of this chapter, that will be one of the fundamental building blocks we use to construct generators-as-async-flow-control as a pattern for our code.</p>
<h3 id="Input-and-Output"><a href="#Input-and-Output" class="headerlink" title="Input and Output"></a>Input and Output</h3><p>A generator function is a special function with the new processing model we just alluded to. But it’s still a function, which means it still has some basic tenets that haven’t changed – namely, that it still accepts arguments (aka “input”), and that it can still return a value (aka “output”):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo( <span class="number">6</span>, <span class="number">7</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"></span><br><span class="line">res.value;		<span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>We pass in the arguments <code>6</code> and <code>7</code> to <code>*foo(..)</code> as the parameters <code>x</code> and <code>y</code>, respectively. And <code>*foo(..)</code> returns the value <code>42</code> back to the calling code.</p>
<p>We now see a difference with how the generator is invoked compared to a normal function. <code>foo(6,7)</code> obviously looks familiar. But subtly, the <code>*foo(..)</code> generator hasn’t actually run yet as it would have with a function.</p>
<p>Instead, we’re just creating an <em>iterator</em> object, which we assign to the variable <code>it</code>, to control the <code>*foo(..)</code> generator. Then we call <code>it.next()</code>, which instructs the <code>*foo(..)</code> generator to advance from its current location, stopping either at the next <code>yield</code> or end of the generator.</p>
<p>The result of that <code>next(..)</code> call is an object with a <code>value</code> property on it holding whatever value (if anything) was returned from <code>*foo(..)</code>. In other words, <code>yield</code> caused a value to be sent out from the generator during the middle of its execution, kind of like an intermediate <code>return</code>.</p>
<p>Again, it won’t be obvious yet why we need this whole indirect <em>iterator</em> object to control the generator. We’ll get there, I <em>promise</em>.</p>
<h4 id="Iteration-Messaging"><a href="#Iteration-Messaging" class="headerlink" title="Iteration Messaging"></a>Iteration Messaging</h4><p>In addition to generators accepting arguments and having return values, there’s even more powerful and compelling input/output messaging capability built into them, via <code>yield</code> and <code>next(..)</code>.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = x * (<span class="keyword">yield</span>);</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo( <span class="number">6</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// start `foo(..)`</span></span><br><span class="line">it.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = it.next( <span class="number">7</span> );</span><br><span class="line"></span><br><span class="line">res.value;		<span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>First, we pass in <code>6</code> as the parameter <code>x</code>. Then we call <code>it.next()</code>, and it starts up <code>*foo(..)</code>.</p>
<p>Inside <code>*foo(..)</code>, the <code>var y = x ..</code> statement starts to be processed, but then it runs across a <code>yield</code> expression. At that point, it pauses <code>*foo(..)</code> (in the middle of the assignment statement!), and essentially requests the calling code to provide a result value for the <code>yield</code> expression. Next, we call <code>it.next( 7 )</code>, which is passing the <code>7</code> value back in to <em>be</em> that result of the paused <code>yield</code> expression.</p>
<p>So, at this point, the assignment statement is essentially <code>var y = 6 * 7</code>. Now, <code>return y</code> returns that <code>42</code> value back as the result of the <code>it.next( 7 )</code> call.</p>
<p>Notice something very important but also easily confusing, even to seasoned JS developers: depending on your perspective, there’s a mismatch between the <code>yield</code> and the <code>next(..)</code> call. In general, you’re going to have one more <code>next(..)</code> call than you have <code>yield</code> statements – the preceding snippet has one <code>yield</code> and two <code>next(..)</code> calls.</p>
<p>Why the mismatch?</p>
<p>Because the first <code>next(..)</code> always starts a generator, and runs to the first <code>yield</code>. But it’s the second <code>next(..)</code> call that fulfills the first paused <code>yield</code> expression, and the third <code>next(..)</code> would fulfill the second <code>yield</code>, and so on.</p>
<h5 id="Tale-of-Two-Questions"><a href="#Tale-of-Two-Questions" class="headerlink" title="Tale of Two Questions"></a>Tale of Two Questions</h5><p>Actually, which code you’re thinking about primarily will affect whether there’s a perceived mismatch or not.</p>
<p>Consider only the generator code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = x * (<span class="keyword">yield</span>);</span><br><span class="line"><span class="keyword">return</span> y;</span><br></pre></td></tr></table></figure>
<p>This <strong>first</strong> <code>yield</code> is basically <em>asking a question</em>: “What value should I insert here?”</p>
<p>Who’s going to answer that question? Well, the <strong>first</strong> <code>next()</code> has already run to get the generator up to this point, so obviously <em>it</em> can’t answer the question. So, the <strong>second</strong> <code>next(..)</code> call must answer the question <em>posed</em> by the <strong>first</strong> <code>yield</code>.</p>
<p>See the mismatch – second-to-first?</p>
<p>But let’s flip our perspective. Let’s look at it not from the generator’s point of view, but from the iterator’s point of view.</p>
<p>To properly illustrate this perspective, we also need to explain that messages can go in both directions – <code>yield ..</code> as an expression can send out messages in response to <code>next(..)</code> calls, and <code>next(..)</code> can send values to a paused <code>yield</code> expression. Consider this slightly adjusted code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> y = x * (<span class="keyword">yield</span> <span class="string">"Hello"</span>);	<span class="comment">// &lt;-- yield a value!</span></span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo( <span class="number">6</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = it.next();	<span class="comment">// first `next()`, don't pass anything</span></span><br><span class="line">res.value;				<span class="comment">// "Hello"</span></span><br><span class="line"></span><br><span class="line">res = it.next( <span class="number">7</span> );		<span class="comment">// pass `7` to waiting `yield`</span></span><br><span class="line">res.value;				<span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p><code>yield ..</code> and <code>next(..)</code> pair together as a two-way message passing system <strong>during the execution of the generator</strong>.</p>
<p>So, looking only at the <em>iterator</em> code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = it.next();	<span class="comment">// first `next()`, don't pass anything</span></span><br><span class="line">res.value;				<span class="comment">// "Hello"</span></span><br><span class="line"></span><br><span class="line">res = it.next( <span class="number">7</span> );		<span class="comment">// pass `7` to waiting `yield`</span></span><br><span class="line">res.value;				<span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> We don’t pass a value to the first <code>next()</code> call, and that’s on purpose. Only a paused <code>yield</code> could accept such a value passed by a <code>next(..)</code>, and at the beginning of the generator when we call the first <code>next()</code>, there <strong>is no paused <code>yield</code></strong> to accept such a value. The specification and all compliant browsers just silently <strong>discard</strong> anything passed to the first <code>next()</code>. It’s still a bad idea to pass a value, as you’re just creating silently “failing” code that’s confusing. So, always start a generator with an argument-free <code>next()</code>.</p>
<p>The first <code>next()</code> call (with nothing passed to it) is basically <em>asking a question</em>: “What <em>next</em> value does the <code>*foo(..)</code> generator have to give me?” And who answers this question? The first <code>yield &quot;hello&quot;</code> expression.</p>
<p>See? No mismatch there.</p>
<p>Depending on <em>who</em> you think about asking the question, there is either a mismatch between the <code>yield</code> and <code>next(..)</code> calls, or not.</p>
<p>But wait! There’s still an extra <code>next()</code> compared to the number of <code>yield</code> statements. So, that final <code>it.next(7)</code> call is again asking the question about what <em>next</em> value the generator will produce. But there’s no more <code>yield</code> statements left to answer, is there? So who answers?</p>
<p>The <code>return</code> statement answers the question!</p>
<p>And if there <strong>is no <code>return</code></strong> in your generator – <code>return</code> is certainly not any more required in generators than in regular functions – there’s always an assumed/implicit <code>return;</code> (aka <code>return undefined;</code>), which serves the purpose of default answering the question <em>posed</em> by the final <code>it.next(7)</code> call.</p>
<p>These questions and answers – the two-way message passing with <code>yield</code> and <code>next(..)</code> – are quite powerful, but it’s not obvious at all how these mechanisms are connected to async flow control. We’re getting there!</p>
<h3 id="Multiple-Iterators"><a href="#Multiple-Iterators" class="headerlink" title="Multiple Iterators"></a>Multiple Iterators</h3><p>It may appear from the syntactic usage that when you use an <em>iterator</em> to control a generator, you’re controlling the declared generator function itself. But there’s a subtlety that’s easy to miss: each time you construct an <em>iterator</em>, you are implicitly constructing an instance of the generator which that <em>iterator</em> will control.</p>
<p>You can have multiple instances of the same generator running at the same time, and they can even interact:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	z++;</span><br><span class="line">	<span class="keyword">var</span> y = <span class="keyword">yield</span> (x * z);</span><br><span class="line">	<span class="built_in">console</span>.log( x, y, z );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it1 = foo();</span><br><span class="line"><span class="keyword">var</span> it2 = foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> val1 = it1.next().value;			<span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line"><span class="keyword">var</span> val2 = it2.next().value;			<span class="comment">// 2 &lt;-- yield 2</span></span><br><span class="line"></span><br><span class="line">val1 = it1.next( val2 * <span class="number">10</span> ).value;		<span class="comment">// 40  &lt;-- x:20,  z:2</span></span><br><span class="line">val2 = it2.next( val1 * <span class="number">5</span> ).value;		<span class="comment">// 600 &lt;-- x:200, z:3</span></span><br><span class="line"></span><br><span class="line">it1.next( val2 / <span class="number">2</span> );					<span class="comment">// y:300</span></span><br><span class="line">										<span class="comment">// 20 300 3</span></span><br><span class="line">it2.next( val1 / <span class="number">4</span> );					<span class="comment">// y:10</span></span><br><span class="line">										<span class="comment">// 200 10 3</span></span><br></pre></td></tr></table></figure>
<p><strong>Warning:</strong> The most common usage of multiple instances of the same generator running concurrently is not such interactions, but when the generator is producing its own values without input, perhaps from some independently connected resource. We’ll talk more about value production in the next section.</p>
<p>Let’s briefly walk through the processing:</p>
<ol>
<li>Both instances of <code>*foo()</code> are started at the same time, and both <code>next()</code> calls reveal a <code>value</code> of <code>2</code> from the <code>yield 2</code> statements, respectively.</li>
<li><code>val2 * 10</code> is <code>2 * 10</code>, which is sent into the first generator instance <code>it1</code>, so that <code>x</code> gets value <code>20</code>. <code>z</code> is incremented from <code>1</code> to <code>2</code>, and then <code>20 * 2</code> is <code>yield</code>ed out, setting <code>val1</code> to <code>40</code>.</li>
<li><code>val1 * 5</code> is <code>40 * 5</code>, which is sent into the second generator instance <code>it2</code>, so that <code>x</code> gets value <code>200</code>. <code>z</code> is incremented again, from <code>2</code> to <code>3</code>, and then <code>200 * 3</code> is <code>yield</code>ed out, setting <code>val2</code> to <code>600</code>.</li>
<li><code>val2 / 2</code> is <code>600 / 2</code>, which is sent into the first generator instance <code>it1</code>, so that <code>y</code> gets value <code>300</code>, then printing out <code>20 300 3</code> for its <code>x y z</code> values, respectively.</li>
<li><code>val1 / 4</code> is <code>40 / 4</code>, which is sent into the second generator instance <code>it2</code>, so that <code>y</code> gets value <code>10</code>, then printing out <code>200 10 3</code> for its <code>x y z</code> values, respectively.</li>
</ol>
<p>That’s a “fun” example to run through in your mind. Did you keep it straight?</p>
<h4 id="Interleaving"><a href="#Interleaving" class="headerlink" title="Interleaving"></a>Interleaving</h4><p>Recall this scenario from the “Run-to-completion” section of Chapter 1:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	a++;</span><br><span class="line">	b = b * a;</span><br><span class="line">	a = b + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	b--;</span><br><span class="line">	a = <span class="number">8</span> + b;</span><br><span class="line">	b = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With normal JS functions, of course either <code>foo()</code> can run completely first, or <code>bar()</code> can run completely first, but <code>foo()</code> cannot interleave its individual statements with <code>bar()</code>. So, there are only two possible outcomes to the preceding program.</p>
<p>However, with generators, clearly interleaving (even in the middle of statements!) is possible:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	a++;</span><br><span class="line">	<span class="keyword">yield</span>;</span><br><span class="line">	b = b * a;</span><br><span class="line">	a = (<span class="keyword">yield</span> b) + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	b--;</span><br><span class="line">	<span class="keyword">yield</span>;</span><br><span class="line">	a = (<span class="keyword">yield</span> <span class="number">8</span>) + b;</span><br><span class="line">	b = a * (<span class="keyword">yield</span> <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Depending on what respective order the <em>iterators</em> controlling <code>*foo()</code> and <code>*bar()</code> are called, the preceding program could produce several different results. In other words, we can actually illustrate (in a sort of fake-ish way) the theoretical “threaded race conditions” circumstances discussed in Chapter 1, by interleaving the two generator iterations over the same shared variables.</p>
<p>First, let’s make a helper called <code>step(..)</code> that controls an <em>iterator</em>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> it = gen();</span><br><span class="line">	<span class="keyword">var</span> last;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// whatever is `yield`ed out, just</span></span><br><span class="line">		<span class="comment">// send it right back in the next time!</span></span><br><span class="line">		last = it.next( last ).value;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>step(..)</code> initializes a generator to create its <code>it</code> <em>iterator</em>, then returns a function which, when called, advances the <em>iterator</em> by one step. Additionally, the previously <code>yield</code>ed out value is sent right back in at the <em>next</em> step. So, <code>yield 8</code> will just become <code>8</code> and <code>yield b</code> will just be <code>b</code> (whatever it was at the time of <code>yield</code>).</p>
<p>Now, just for fun, let’s experiment to see the effects of interleaving these different chunks of <code>*foo()</code> and <code>*bar()</code>. We’ll start with the boring base case, making sure <code>*foo()</code> totally finishes before <code>*bar()</code> (just like we did in Chapter 1):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure to reset `a` and `b`</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = step( foo );</span><br><span class="line"><span class="keyword">var</span> s2 = step( bar );</span><br><span class="line"></span><br><span class="line"><span class="comment">// run `*foo()` completely first</span></span><br><span class="line">s1();</span><br><span class="line">s1();</span><br><span class="line">s1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// now run `*bar()`</span></span><br><span class="line">s2();</span><br><span class="line">s2();</span><br><span class="line">s2();</span><br><span class="line">s2();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a, b );	<span class="comment">// 11 22</span></span><br></pre></td></tr></table></figure>
<p>The end result is <code>11</code> and <code>22</code>, just as it was in the Chapter 1 version. Now let’s mix up the interleaving ordering and see how it changes the final values of <code>a</code> and <code>b</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure to reset `a` and `b`</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = step( foo );</span><br><span class="line"><span class="keyword">var</span> s2 = step( bar );</span><br><span class="line"></span><br><span class="line">s2();		<span class="comment">// b--;</span></span><br><span class="line">s2();		<span class="comment">// yield 8</span></span><br><span class="line">s1();		<span class="comment">// a++;</span></span><br><span class="line">s2();		<span class="comment">// a = 8 + b;</span></span><br><span class="line">			<span class="comment">// yield 2</span></span><br><span class="line">s1();		<span class="comment">// b = b * a;</span></span><br><span class="line">			<span class="comment">// yield b</span></span><br><span class="line">s1();		<span class="comment">// a = b + 3;</span></span><br><span class="line">s2();		<span class="comment">// b = a * 2;</span></span><br></pre></td></tr></table></figure>
<p>Before I tell you the results, can you figure out what <code>a</code> and <code>b</code> are after the preceding program? No cheating!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a, b );	<span class="comment">// 12 18</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> As an exercise for the reader, try to see how many other combinations of results you can get back rearranging the order of the <code>s1()</code> and <code>s2()</code> calls. Don’t forget you’ll always need three <code>s1()</code> calls and four <code>s2()</code> calls. Recall the discussion earlier about matching <code>next()</code> with <code>yield</code> for the reasons why.</p>
<p>You almost certainly won’t want to intentionally create <em>this</em> level of interleaving confusion, as it creates incredibly difficult to understand code. But the exercise is interesting and instructive to understand more about how multiple generators can run concurrently in the same shared scope, because there will be places where this capability is quite useful.</p>
<p>We’ll discuss generator concurrency in more detail at the end of this chapter.</p>
<h2 id="Generator’ing-Values"><a href="#Generator’ing-Values" class="headerlink" title="Generator’ing Values"></a>Generator’ing Values</h2><p>In the previous section, we mentioned an interesting use for generators, as a way to produce values. This is <strong>not</strong> the main focus in this chapter, but we’d be remiss if we didn’t cover the basics, especially because this use case is essentially the origin of the name: generators.</p>
<p>We’re going to take a slight diversion into the topic of <em>iterators</em> for a bit, but we’ll circle back to how they relate to generators and using a generator to <em>generate</em> values.</p>
<h3 id="Producers-and-Iterators"><a href="#Producers-and-Iterators" class="headerlink" title="Producers and Iterators"></a>Producers and Iterators</h3><p>Imagine you’re producing a series of values where each value has a definable relationship to the previous value. To do this, you’re going to need a stateful producer that remembers the last value it gave out.</p>
<p>You can implement something like that straightforwardly using a function closure (see the <em>Scope &amp; Closures</em> title of this series):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gimmeSomething = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> nextVal;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nextVal === <span class="literal">undefined</span>) &#123;</span><br><span class="line">			nextVal = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nextVal = (<span class="number">3</span> * nextVal) + <span class="number">6</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> nextVal;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">gimmeSomething();		<span class="comment">// 1</span></span><br><span class="line">gimmeSomething();		<span class="comment">// 9</span></span><br><span class="line">gimmeSomething();		<span class="comment">// 33</span></span><br><span class="line">gimmeSomething();		<span class="comment">// 105</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> The <code>nextVal</code> computation logic here could have been simplified, but conceptually, we don’t want to calculate the <em>next value</em> (aka <code>nextVal</code>) until the <em>next</em> <code>gimmeSomething()</code> call happens, because in general that could be a resource-leaky design for producers of more persistent or resource-limited values than simple <code>number</code>s.</p>
<p>Generating an arbitrary number series isn’t a terribly realistic example. But what if you were generating records from a data source? You could imagine much the same code.</p>
<p>In fact, this task is a very common design pattern, usually solved by iterators. An <em>iterator</em> is a well-defined interface for stepping through a series of values from a producer. The JS interface for iterators, as it is in most languages, is to call <code>next()</code> each time you want the next value from the producer.</p>
<p>We could implement the standard <em>iterator</em> interface for our number series producer:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> something = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> nextVal;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="comment">// needed for `for..of` loops</span></span><br><span class="line">		[<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;,</span><br><span class="line"></span><br><span class="line">		<span class="comment">// standard iterator interface method</span></span><br><span class="line">		next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (nextVal === <span class="literal">undefined</span>) &#123;</span><br><span class="line">				nextVal = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				nextVal = (<span class="number">3</span> * nextVal) + <span class="number">6</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> &#123; <span class="attr">done</span>:<span class="literal">false</span>, <span class="attr">value</span>:nextVal &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">something.next().value;		<span class="comment">// 1</span></span><br><span class="line">something.next().value;		<span class="comment">// 9</span></span><br><span class="line">something.next().value;		<span class="comment">// 33</span></span><br><span class="line">something.next().value;		<span class="comment">// 105</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> We’ll explain why we need the <code>[Symbol.iterator]: ..</code> part of this code snippet in the “Iterables” section. Syntactically though, two ES6 features are at play. First, the <code>[ .. ]</code> syntax is called a <em>computed property name</em> (see the <em>this &amp; Object Prototypes</em> title of this series). It’s a way in an object literal definition to specify an expression and use the result of that expression as the name for the property. Next, <code>Symbol.iterator</code> is one of ES6’s predefined special <code>Symbol</code> values (see the <em>ES6 &amp; Beyond</em> title of this book series).</p>
<p>The <code>next()</code> call returns an object with two properties: <code>done</code> is a <code>boolean</code> value signaling the <em>iterator’s</em> complete status; <code>value</code> holds the iteration value.</p>
<p>ES6 also adds the <code>for..of</code> loop, which means that a standard <em>iterator</em> can automatically be consumed with native loop syntax:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> something) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// don't let the loop run forever!</span></span><br><span class="line">	<span class="keyword">if</span> (v &gt; <span class="number">500</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 9 33 105 321 969</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Because our <code>something</code> <em>iterator</em> always returns <code>done:false</code>, this <code>for..of</code> loop would run forever, which is why we put the <code>break</code> conditional in. It’s totally OK for iterators to be never-ending, but there are also cases where the <em>iterator</em> will run over a finite set of values and eventually return a <code>done:true</code>.</p>
<p>The <code>for..of</code> loop automatically calls <code>next()</code> for each iteration – it doesn’t pass any values in to the <code>next()</code> – and it will automatically terminate on receiving a <code>done:true</code>. It’s quite handy for looping over a set of data.</p>
<p>Of course, you could manually loop over iterators, calling <code>next()</code> and checking for the <code>done:true</code> condition to know when to stop:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (</span><br><span class="line">	<span class="keyword">var</span> ret;</span><br><span class="line">	(ret = something.next()) &amp;&amp; !ret.done;</span><br><span class="line">) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( ret.value );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// don't let the loop run forever!</span></span><br><span class="line">	<span class="keyword">if</span> (ret.value &gt; <span class="number">500</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 9 33 105 321 969</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> This manual <code>for</code> approach is certainly uglier than the ES6 <code>for..of</code> loop syntax, but its advantage is that it affords you the opportunity to pass in values to the <code>next(..)</code> calls if necessary.</p>
<p>In addition to making your own <em>iterators</em>, many built-in data structures in JS (as of ES6), like <code>array</code>s, also have default <em>iterators</em>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> a) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 3 5 7 9</span></span><br></pre></td></tr></table></figure>
<p>The <code>for..of</code> loop asks <code>a</code> for its <em>iterator</em>, and automatically uses it to iterate over <code>a</code>‘s values.</p>
<p><strong>Note:</strong> It may seem a strange omission by ES6, but regular <code>object</code>s intentionally do not come with a default <em>iterator</em> the way <code>array</code>s do. The reasons go deeper than we will cover here. If all you want is to iterate over the properties of an object (with no particular guarantee of ordering), <code>Object.keys(..)</code> returns an <code>array</code>, which can then be used like <code>for (var k of Object.keys(obj)) { ..</code>. Such a <code>for..of</code> loop over an object’s keys would be similar to a <code>for..in</code> loop, except that <code>Object.keys(..)</code> does not include properties from the <code>[[Prototype]]</code> chain while <code>for..in</code> does (see the <em>this &amp; Object Prototypes</em> title of this series).</p>
<h3 id="Iterables"><a href="#Iterables" class="headerlink" title="Iterables"></a>Iterables</h3><p>The <code>something</code> object in our running example is called an <em>iterator</em>, as it has the <code>next()</code> method on its interface. But a closely related term is <em>iterable</em>, which is an <code>object</code> that <strong>contains</strong> an <em>iterator</em> that can iterate over its values.</p>
<p>As of ES6, the way to retrieve an <em>iterator</em> from an <em>iterable</em> is that the <em>iterable</em> must have a function on it, with the name being the special ES6 symbol value <code>Symbol.iterator</code>. When this function is called, it returns an <em>iterator</em>. Though not required, generally each call should return a fresh new <em>iterator</em>.</p>
<p><code>a</code> in the previous snippet is an <em>iterable</em>. The <code>for..of</code> loop automatically calls its <code>Symbol.iterator</code> function to construct an <em>iterator</em>. But we could of course call the function manually, and use the <em>iterator</em> it returns:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = a[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">it.next().value;	<span class="comment">// 1</span></span><br><span class="line">it.next().value;	<span class="comment">// 3</span></span><br><span class="line">it.next().value;	<span class="comment">// 5</span></span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>In the previous code listing that defined <code>something</code>, you may have noticed this line:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>That little bit of confusing code is making the <code>something</code> value – the interface of the <code>something</code> <em>iterator</em> – also an <em>iterable</em>; it’s now both an <em>iterable</em> and an <em>iterator</em>. Then, we pass <code>something</code> to the <code>for..of</code> loop:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> something) &#123;</span><br><span class="line">	..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>for..of</code> loop expects <code>something</code> to be an <em>iterable</em>, so it looks for and calls its <code>Symbol.iterator</code> function. We defined that function to simply <code>return this</code>, so it just gives itself back, and the <code>for..of</code> loop is none the wiser.</p>
<h3 id="Generator-Iterator"><a href="#Generator-Iterator" class="headerlink" title="Generator Iterator"></a>Generator Iterator</h3><p>Let’s turn our attention back to generators, in the context of <em>iterators</em>. A generator can be treated as a producer of values that we extract one at a time through an <em>iterator</em> interface’s <code>next()</code> calls.</p>
<p>So, a generator itself is not technically an <em>iterable</em>, though it’s very similar – when you execute the generator, you get an <em>iterator</em> back:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123; .. &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br></pre></td></tr></table></figure>
<p>We can implement the <code>something</code> infinite number series producer from earlier with a generator, like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> nextVal;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nextVal === <span class="literal">undefined</span>) &#123;</span><br><span class="line">			nextVal = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nextVal = (<span class="number">3</span> * nextVal) + <span class="number">6</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">yield</span> nextVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> A <code>while..true</code> loop would normally be a very bad thing to include in a real JS program, at least if it doesn’t have a <code>break</code> or <code>return</code> in it, as it would likely run forever, synchronously, and block/lock-up the browser UI. However, in a generator, such a loop is generally totally OK if it has a <code>yield</code> in it, as the generator will pause at each iteration, <code>yield</code>ing back to the main program and/or to the event loop queue. To put it glibly, “generators put the <code>while..true</code> back in JS programming!”</p>
<p>That’s a fair bit cleaner and simpler, right? Because the generator pauses at each <code>yield</code>, the state (scope) of the function <code>*something()</code> is kept around, meaning there’s no need for the closure boilerplate to preserve variable state across calls.</p>
<p>Not only is it simpler code – we don’t have to make our own <em>iterator</em> interface – it actually is more reason-able code, because it more clearly expresses the intent. For example, the <code>while..true</code> loop tells us the generator is intended to run forever – to keep <em>generating</em> values as long as we keep asking for them.</p>
<p>And now we can use our shiny new <code>*something()</code> generator with a <code>for..of</code> loop, and you’ll see it works basically identically:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> something()) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// don't let the loop run forever!</span></span><br><span class="line">	<span class="keyword">if</span> (v &gt; <span class="number">500</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 9 33 105 321 969</span></span><br></pre></td></tr></table></figure>
<p>But don’t skip over <code>for (var v of something()) ..</code>! We didn’t just reference <code>something</code> as a value like in earlier examples, but instead called the <code>*something()</code> generator to get its <em>iterator</em> for the <code>for..of</code> loop to use.</p>
<p>If you’re paying close attention, two questions may arise from this interaction between the generator and the loop:</p>
<ul>
<li>Why couldn’t we say <code>for (var v of something) ..</code>? Because <code>something</code> here is a generator, which is not an <em>iterable</em>. We have to call <code>something()</code> to construct a producer for the <code>for..of</code> loop to iterate over.</li>
<li>The <code>something()</code> call produces an <em>iterator</em>, but the <code>for..of</code> loop wants an <em>iterable</em>, right? Yep. The generator’s <em>iterator</em> also has a <code>Symbol.iterator</code> function on it, which basically does a <code>return this</code>, just like the <code>something</code> <em>iterable</em> we defined earlier. In other words, a generator’s <em>iterator</em> is also an <em>iterable</em>!</li>
</ul>
<h4 id="Stopping-the-Generator"><a href="#Stopping-the-Generator" class="headerlink" title="Stopping the Generator"></a>Stopping the Generator</h4><p>In the previous example, it would appear the <em>iterator</em> instance for the <code>*something()</code> generator was basically left in a suspended state forever after the <code>break</code> in the loop was called.</p>
<p>But there’s a hidden behavior that takes care of that for you. “Abnormal completion” (i.e., “early termination”) of the <code>for..of</code> loop – generally caused by a <code>break</code>, <code>return</code>, or an uncaught exception – sends a signal to the generator’s <em>iterator</em> for it to terminate.</p>
<p><strong>Note:</strong> Technically, the <code>for..of</code> loop also sends this signal to the <em>iterator</em> at the normal completion of the loop. For a generator, that’s essentially a moot operation, as the generator’s <em>iterator</em> had to complete first so the <code>for..of</code> loop completed. However, custom <em>iterators</em> might desire to receive this additional signal from <code>for..of</code> loop consumers.</p>
<p>While a <code>for..of</code> loop will automatically send this signal, you may wish to send the signal manually to an <em>iterator</em>; you do this by calling <code>return(..)</code>.</p>
<p>If you specify a <code>try..finally</code> clause inside the generator, it will always be run even when the generator is externally completed. This is useful if you need to clean up resources (database connections, etc.):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextVal;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nextVal === <span class="literal">undefined</span>) &#123;</span><br><span class="line">				nextVal = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				nextVal = (<span class="number">3</span> * nextVal) + <span class="number">6</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">yield</span> nextVal;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cleanup clause</span></span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"cleaning up!"</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The earlier example with <code>break</code> in the <code>for..of</code> loop will trigger the <code>finally</code> clause. But you could instead manually terminate the generator’s <em>iterator</em> instance from the outside with <code>return(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = something();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> it) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// don't let the loop run forever!</span></span><br><span class="line">	<span class="keyword">if</span> (v &gt; <span class="number">500</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(</span><br><span class="line">			<span class="comment">// complete the generator's iterator</span></span><br><span class="line">			it.return( <span class="string">"Hello World"</span> ).value</span><br><span class="line">		);</span><br><span class="line">		<span class="comment">// no `break` needed here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 9 33 105 321 969</span></span><br><span class="line"><span class="comment">// cleaning up!</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>When we call <code>it.return(..)</code>, it immediately terminates the generator, which of course runs the <code>finally</code> clause. Also, it sets the returned <code>value</code> to whatever you passed in to <code>return(..)</code>, which is how <code>&quot;Hello World&quot;</code> comes right back out. We also don’t need to include a <code>break</code> now because the generator’s <em>iterator</em> is set to <code>done:true</code>, so the <code>for..of</code> loop will terminate on its next iteration.</p>
<p>Generators owe their namesake mostly to this <em>consuming produced values</em> use. But again, that’s just one of the uses for generators, and frankly not even the main one we’re concerned with in the context of this book.</p>
<p>But now that we more fully understand some of the mechanics of how they work, we can <em>next</em> turn our attention to how generators apply to async concurrency.</p>
<h2 id="Iterating-Generators-Asynchronously"><a href="#Iterating-Generators-Asynchronously" class="headerlink" title="Iterating Generators Asynchronously"></a>Iterating Generators Asynchronously</h2><p>What do generators have to do with async coding patterns, fixing problems with callbacks, and the like? Let’s get to answering that important question.</p>
<p>We should revisit one of our scenarios from Chapter 3. Let’s recall the callback approach:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,cb</span>) </span>&#123;</span><br><span class="line">	ajax(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y,</span><br><span class="line">		cb</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">11</span>, <span class="number">31</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err,text</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>If we wanted to express this same task flow control with a generator, we could do:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	ajax(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y,</span><br><span class="line">		<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				<span class="comment">// throw an error into `*main()`</span></span><br><span class="line">				it.throw( err );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// resume `*main()` with received `data`</span></span><br><span class="line">				it.next( data );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> text = <span class="keyword">yield</span> foo( <span class="number">11</span>, <span class="number">31</span> );</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"></span><br><span class="line"><span class="comment">// start it all up!</span></span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>
<p>At first glance, this snippet is longer, and perhaps a little more complex looking, than the callback snippet before it. But don’t let that impression get you off track. The generator snippet is actually <strong>much</strong> better! But there’s a lot going on for us to explain.</p>
<p>First, let’s look at this part of the code, which is the most important:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="keyword">yield</span> foo( <span class="number">11</span>, <span class="number">31</span> );</span><br><span class="line"><span class="built_in">console</span>.log( text );</span><br></pre></td></tr></table></figure>
<p>Think about how that code works for a moment. We’re calling a normal function <code>foo(..)</code> and we’re apparently able to get back the <code>text</code> from the Ajax call, even though it’s asynchronous.</p>
<p>How is that possible? If you recall the beginning of Chapter 1, we had almost identical code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = ajax( <span class="string">"..url 1.."</span> );</span><br><span class="line"><span class="built_in">console</span>.log( data );</span><br></pre></td></tr></table></figure>
<p>And that code didn’t work! Can you spot the difference? It’s the <code>yield</code> used in a generator.</p>
<p>That’s the magic! That’s what allows us to have what appears to be blocking, synchronous code, but it doesn’t actually block the whole program; it only pauses/blocks the code in the generator itself.</p>
<p>In <code>yield foo(11,31)</code>, first the <code>foo(11,31)</code> call is made, which returns nothing (aka <code>undefined</code>), so we’re making a call to request data, but we’re actually then doing <code>yield undefined</code>. That’s OK, because the code is not currently relying on a <code>yield</code>ed value to do anything interesting. We’ll revisit this point later in the chapter.</p>
<p>We’re not using <code>yield</code> in a message passing sense here, only in a flow control sense to pause/block. Actually, it will have message passing, but only in one direction, after the generator is resumed.</p>
<p>So, the generator pauses at the <code>yield</code>, essentially asking the question, “what value should I return to assign to the variable <code>text</code>?” Who’s going to answer that question?</p>
<p>Look at <code>foo(..)</code>. If the Ajax request is successful, we call:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it.next( data );</span><br></pre></td></tr></table></figure>
<p>That’s resuming the generator with the response data, which means that our paused <code>yield</code> expression receives that value directly, and then as it restarts the generator code, that value gets assigned to the local variable <code>text</code>.</p>
<p>Pretty cool, huh?</p>
<p>Take a step back and consider the implications. We have totally synchronous-looking code inside the generator (other than the <code>yield</code> keyword itself), but hidden behind the scenes, inside of <code>foo(..)</code>, the operations can complete asynchronously.</p>
<p><strong>That’s huge!</strong> That’s a nearly perfect solution to our previously stated problem with callbacks not being able to express asynchrony in a sequential, synchronous fashion that our brains can relate to.</p>
<p>In essence, we are abstracting the asynchrony away as an implementation detail, so that we can reason synchronously/sequentially about our flow control: “Make an Ajax request, and when it finishes print out the response.” And of course, we just expressed two steps in the flow control, but this same capability extends without bounds, to let us express however many steps we need to.</p>
<p><strong>Tip:</strong> This is such an important realization, just go back and read the last three paragraphs again to let it sink in!</p>
<h3 id="Synchronous-Error-Handling"><a href="#Synchronous-Error-Handling" class="headerlink" title="Synchronous Error Handling"></a>Synchronous Error Handling</h3><p>But the preceding generator code has even more goodness to <em>yield</em> to us. Let’s turn our attention to the <code>try..catch</code> inside the generator:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> text = <span class="keyword">yield</span> foo( <span class="number">11</span>, <span class="number">31</span> );</span><br><span class="line">	<span class="built_in">console</span>.log( text );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="built_in">console</span>.error( err );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How does this work? The <code>foo(..)</code> call is asynchronously completing, and doesn’t <code>try..catch</code> fail to catch asynchronous errors, as we looked at in Chapter 3?</p>
<p>We already saw how the <code>yield</code> lets the assignment statement pause to wait for <code>foo(..)</code> to finish, so that the completed response can be assigned to <code>text</code>. The awesome part is that this <code>yield</code> pausing <em>also</em> allows the generator to <code>catch</code> an error. We throw that error into the generator with this part of the earlier code listing:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">	<span class="comment">// throw an error into `*main()`</span></span><br><span class="line">	it.throw( err );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>yield</code>-pause nature of generators means that not only do we get synchronous-looking <code>return</code> values from async function calls, but we can also synchronously <code>catch</code> errors from those async function calls!</p>
<p>So we’ve seen we can throw errors <em>into</em> a generator, but what about throwing errors <em>out of</em> a generator? Exactly as you’d expect:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">yield</span> x.toLowerCase();	<span class="comment">// cause an exception!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"></span><br><span class="line">it.next().value;			<span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	it.next( <span class="number">42</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="built_in">console</span>.error( err );	<span class="comment">// TypeError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Of course, we could have manually thrown an error with <code>throw ..</code> instead of causing an exception.</p>
<p>We can even <code>catch</code> the same error that we <code>throw(..)</code> into the generator, essentially giving the generator a chance to handle it but if it doesn’t, the <em>iterator</em> code must handle it:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// never gets here</span></span><br><span class="line">	<span class="built_in">console</span>.log( x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// will `*main()` handle this error? we'll see!</span></span><br><span class="line">	it.throw( <span class="string">"Oops"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="comment">// nope, didn't handle it!</span></span><br><span class="line">	<span class="built_in">console</span>.error( err );			<span class="comment">// Oops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Synchronous-looking error handling (via <code>try..catch</code>) with async code is a huge win for readability and reason-ability.</p>
<h2 id="Generators-Promises"><a href="#Generators-Promises" class="headerlink" title="Generators + Promises"></a>Generators + Promises</h2><p>In our previous discussion, we showed how generators can be iterated asynchronously, which is a huge step forward in sequential reason-ability over the spaghetti mess of callbacks. But we lost something very important: the trustability and composability of Promises (see Chapter 3)!</p>
<p>Don’t worry – we can get that back. The best of all worlds in ES6 is to combine generators (synchronous-looking async code) with Promises (trustable and composable).</p>
<p>But how?</p>
<p>Recall from Chapter 3 the Promise-based approach to our running Ajax example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> request(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">11</span>, <span class="number">31</span> )</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>In our earlier generator code for the running Ajax example, <code>foo(..)</code> returned nothing (<code>undefined</code>), and our <em>iterator</em> control code didn’t care about that <code>yield</code>ed value.</p>
<p>But here the Promise-aware <code>foo(..)</code> returns a promise after making the Ajax call. That suggests that we could construct a promise with <code>foo(..)</code> and then <code>yield</code> it from the generator, and then the <em>iterator</em> control code would receive that promise.</p>
<p>But what should the <em>iterator</em> do with the promise?</p>
<p>It should listen for the promise to resolve (fulfillment or rejection), and then either resume the generator with the fulfillment message or throw an error into the generator with the rejection reason.</p>
<p>Let me repeat that, because it’s so important. The natural way to get the most out of Promises and generators is <strong>to <code>yield</code> a Promise</strong>, and wire that Promise to control the generator’s <em>iterator</em>.</p>
<p>Let’s give it a try! First, we’ll put the Promise-aware <code>foo(..)</code> together with the generator <code>*main()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> request(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> text = <span class="keyword">yield</span> foo( <span class="number">11</span>, <span class="number">31</span> );</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The most powerful revelation in this refactor is that the code inside <code>*main()</code> <strong>did not have to change at all!</strong> Inside the generator, whatever values are <code>yield</code>ed out is just an opaque implementation detail, so we’re not even aware it’s happening, nor do we need to worry about it.</p>
<p>But how are we going to run <code>*main()</code> now? We still have some of the implementation plumbing work to do, to receive and wire up the <code>yield</code>ed promise so that it resumes the generator upon resolution. We’ll start by trying that manually:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = it.next().value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for the `p` promise to resolve</span></span><br><span class="line">p.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		it.next( text );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		it.throw( err );</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Actually, that wasn’t so painful at all, was it?</p>
<p>This snippet should look very similar to what we did earlier with the manually wired generator controlled by the error-first callback. Instead of an <code>if (err) { it.throw..</code>, the promise already splits fulfillment (success) and rejection (failure) for us, but otherwise the <em>iterator</em> control is identical.</p>
<p>Now, we’ve glossed over some important details.</p>
<p>Most importantly, we took advantage of the fact that we knew that <code>*main()</code> only had one Promise-aware step in it. What if we wanted to be able to Promise-drive a generator no matter how many steps it has? We certainly don’t want to manually write out the Promise chain differently for each generator! What would be much nicer is if there was a way to repeat (aka “loop” over) the iteration control, and each time a Promise comes out, wait on its resolution before continuing.</p>
<p>Also, what if the generator throws out an error (intentionally or accidentally) during the <code>it.next(..)</code> call? Should we quit, or should we <code>catch</code> it and send it right back in? Similarly, what if we <code>it.throw(..)</code> a Promise rejection into the generator, but it’s not handled, and comes right back out?</p>
<h3 id="Promise-Aware-Generator-Runner"><a href="#Promise-Aware-Generator-Runner" class="headerlink" title="Promise-Aware Generator Runner"></a>Promise-Aware Generator Runner</h3><p>The more you start to explore this path, the more you realize, “wow, it’d be great if there was just some utility to do it for me.” And you’re absolutely correct. This is such an important pattern, and you don’t want to get it wrong (or exhaust yourself repeating it over and over), so your best bet is to use a utility that is specifically designed to <em>run</em> Promise-<code>yield</code>ing generators in the manner we’ve illustrated.</p>
<p>Several Promise abstraction libraries provide just such a utility, including my <em>asynquence</em> library and its <code>runner(..)</code>, which will be discussed in Appendix A of this book.</p>
<p>But for the sake of learning and illustration, let’s just define our own standalone utility that we’ll call <code>run(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thanks to Benjamin Gruenbaum (@benjamingr on GitHub) for</span></span><br><span class="line"><span class="comment">// big improvements here!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span>), it;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize the generator in the current context</span></span><br><span class="line">	it = gen.apply( <span class="keyword">this</span>, args );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return a promise for the generator completing</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">		.then( <span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">			<span class="comment">// run to the next yielded value</span></span><br><span class="line">			<span class="keyword">var</span> next = it.next( value );</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">				<span class="comment">// generator has completed running?</span></span><br><span class="line">				<span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">					<span class="keyword">return</span> next.value;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// otherwise keep going</span></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve( next.value )</span><br><span class="line">						.then(</span><br><span class="line">							<span class="comment">// resume the async loop on</span></span><br><span class="line">							<span class="comment">// success, sending the resolved</span></span><br><span class="line">							<span class="comment">// value back into the generator</span></span><br><span class="line">							handleNext,</span><br><span class="line"></span><br><span class="line">							<span class="comment">// if `value` is a rejected</span></span><br><span class="line">							<span class="comment">// promise, propagate error back</span></span><br><span class="line">							<span class="comment">// into the generator for its own</span></span><br><span class="line">							<span class="comment">// error handling</span></span><br><span class="line">							<span class="function"><span class="keyword">function</span> <span class="title">handleErr</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">								<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">									it.throw( err )</span><br><span class="line">								)</span><br><span class="line">								.then( handleResult );</span><br><span class="line">							&#125;</span><br><span class="line">						);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)(next);</span><br><span class="line">		&#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As you can see, it’s a quite a bit more complex than you’d probably want to author yourself, and you especially wouldn’t want to repeat this code for each generator you use. So, a utility/library helper is definitely the way to go. Nevertheless, I encourage you to spend a few minutes studying that code listing to get a better sense of how to manage the generator+Promise negotiation.</p>
<p>How would you use <code>run(..)</code> with <code>*main()</code> in our <em>running</em> Ajax example?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run( main );</span><br></pre></td></tr></table></figure>
<p>That’s it! The way we wired <code>run(..)</code>, it will automatically advance the generator you pass to it, asynchronously until completion.</p>
<p><strong>Note:</strong> The <code>run(..)</code> we defined returns a promise which is wired to resolve once the generator is complete, or receive an uncaught exception if the generator doesn’t handle it. We don’t show that capability here, but we’ll come back to it later in the chapter.</p>
<h4 id="ES7-async-and-await"><a href="#ES7-async-and-await" class="headerlink" title="ES7: async and await?"></a>ES7: <code>async</code> and <code>await</code>?</h4><p>The preceding pattern – generators yielding Promises that then control the generator’s <em>iterator</em> to advance it to completion – is such a powerful and useful approach, it would be nicer if we could do it without the clutter of the library utility helper (aka <code>run(..)</code>).</p>
<p>There’s probably good news on that front. At the time of this writing, there’s early but strong support for a proposal for more syntactic addition in this realm for the post-ES6, ES7-ish timeframe. Obviously, it’s too early to guarantee the details, but there’s a pretty decent chance it will shake out similar to the following:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> request(</span><br><span class="line">		<span class="string">"http://some.url.1/?x="</span> + x + <span class="string">"&amp;y="</span> + y</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> text = <span class="keyword">await</span> foo( <span class="number">11</span>, <span class="number">31</span> );</span><br><span class="line">		<span class="built_in">console</span>.log( text );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>As you can see, there’s no <code>run(..)</code> call (meaning no need for a library utility!) to invoke and drive <code>main()</code> – it’s just called as a normal function. Also, <code>main()</code> isn’t declared as a generator function anymore; it’s a new kind of function: <code>async function</code>. And finally, instead of <code>yield</code>ing a Promise, we <code>await</code> for it to resolve.</p>
<p>The <code>async function</code> automatically knows what to do if you <code>await</code> a Promise – it will pause the function (just like with generators) until the Promise resolves. We didn’t illustrate it in this snippet, but calling an async function like <code>main()</code> automatically returns a promise that’s resolved whenever the function finishes completely.</p>
<p><strong>Tip:</strong> The <code>async</code> / <code>await</code> syntax should look very familiar to readers with  experience in C#, because it’s basically identical.</p>
<p>The proposal essentially codifies support for the pattern we’ve already derived, into a syntactic mechanism: combining Promises with sync-looking flow control code. That’s the best of both worlds combined, to effectively address practically all of the major concerns we outlined with callbacks.</p>
<p>The mere fact that such a ES7-ish proposal already exists and has early support and enthusiasm is a major vote of confidence in the future importance of this async pattern.</p>
<h3 id="Promise-Concurrency-in-Generators"><a href="#Promise-Concurrency-in-Generators" class="headerlink" title="Promise Concurrency in Generators"></a>Promise Concurrency in Generators</h3><p>So far, all we’ve demonstrated is a single-step async flow with Promises+generators. But real-world code will often have many async steps.</p>
<p>If you’re not careful, the sync-looking style of generators may lull you into complacency with how you structure your async concurrency, leading to suboptimal performance patterns. So we want to spend a little time exploring the options.</p>
<p>Imagine a scenario where you need to fetch data from two different sources, then combine those responses to make a third request, and finally print out the last response. We explored a similar scenario with Promises in Chapter 3, but let’s reconsider it in the context of generators.</p>
<p>Your first instinct might be something like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> request(</span><br><span class="line">		<span class="string">"http://some.url.3/?v="</span> + r1 + <span class="string">","</span> + r2</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( r3 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use previously defined `run(..)` utility</span></span><br><span class="line">run( foo );</span><br></pre></td></tr></table></figure>
<p>This code will work, but in the specifics of our scenario, it’s not optimal. Can you spot why?</p>
<p>Because the <code>r1</code> and <code>r2</code> requests can – and for performance reasons, <em>should</em> – run concurrently, but in this code they will run sequentially; the <code>&quot;http://some.url.2&quot;</code> URL isn’t Ajax fetched until after the <code>&quot;http://some.url.1&quot;</code> request is finished. These two requests are independent, so the better performance approach would likely be to have them run at the same time.</p>
<p>But how exactly would you do that with a generator and <code>yield</code>? We know that <code>yield</code> is only a single pause point in the code, so you can’t really do two pauses at the same time.</p>
<p>The most natural and effective answer is to base the async flow on Promises, specifically on their capability to manage state in a time-independent fashion (see “Future Value” in Chapter 3).</p>
<p>The simplest approach:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// make both requests "in parallel"</span></span><br><span class="line">	<span class="keyword">var</span> p1 = request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">	<span class="keyword">var</span> p2 = request( <span class="string">"http://some.url.2"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait until both promises resolve</span></span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> p1;</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> p2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> request(</span><br><span class="line">		<span class="string">"http://some.url.3/?v="</span> + r1 + <span class="string">","</span> + r2</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( r3 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use previously defined `run(..)` utility</span></span><br><span class="line">run( foo );</span><br></pre></td></tr></table></figure>
<p>Why is this different from the previous snippet? Look at where the <code>yield</code> is and is not. <code>p1</code> and <code>p2</code> are promises for Ajax requests made concurrently (aka “in parallel”). It doesn’t matter which one finishes first, because promises will hold onto their resolved state for as long as necessary.</p>
<p>Then we use two subsequent <code>yield</code> statements to wait for and retrieve the resolutions from the promises (into <code>r1</code> and <code>r2</code>, respectively). If <code>p1</code> resolves first, the <code>yield p1</code> resumes first then waits on the <code>yield p2</code> to resume. If <code>p2</code> resolves first, it will just patiently hold onto that resolution value until asked, but the <code>yield p1</code> will hold on first, until <code>p1</code> resolves.</p>
<p>Either way, both <code>p1</code> and <code>p2</code> will run concurrently, and both have to finish, in either order, before the <code>r3 = yield request..</code> Ajax request will be made.</p>
<p>If that flow control processing model sounds familiar, it’s basically the same as what we identified in Chapter 3 as the “gate” pattern, enabled by the <code>Promise.all([ .. ])</code> utility. So, we could also express the flow control like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// make both requests "in parallel," and</span></span><br><span class="line">	<span class="comment">// wait until both promises resolve</span></span><br><span class="line">	<span class="keyword">var</span> results = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">		request( <span class="string">"http://some.url.1"</span> ),</span><br><span class="line">		request( <span class="string">"http://some.url.2"</span> )</span><br><span class="line">	] );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r1 = results[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">var</span> r2 = results[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> request(</span><br><span class="line">		<span class="string">"http://some.url.3/?v="</span> + r1 + <span class="string">","</span> + r2</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( r3 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use previously defined `run(..)` utility</span></span><br><span class="line">run( foo );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> As we discussed in Chapter 3, we can even use ES6 destructuring assignment to simplify the <code>var r1 = .. var r2 = ..</code> assignments, with <code>var [r1,r2] = results</code>.</p>
<p>In other words, all of the concurrency capabilities of Promises are available to us in the generator+Promise approach. So in any place where you need more than sequential this-then-that async flow control steps, Promises are likely your best bet.</p>
<h4 id="Promises-Hidden"><a href="#Promises-Hidden" class="headerlink" title="Promises, Hidden"></a>Promises, Hidden</h4><p>As a word of stylistic caution, be careful about how much Promise logic you include <strong>inside your generators</strong>. The whole point of using generators for asynchrony in the way we’ve described is to create simple, sequential, sync-looking code, and to hide as much of the details of asynchrony away from that code as possible.</p>
<p>For example, this might be a cleaner approach:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: normal function, not generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">url1,url2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">		request( url1 ),</span><br><span class="line">		request( url2 )</span><br><span class="line">	] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// hide the Promise-based concurrency details</span></span><br><span class="line">	<span class="comment">// inside `bar(..)`</span></span><br><span class="line">	<span class="keyword">var</span> results = <span class="keyword">yield</span> bar(</span><br><span class="line">		<span class="string">"http://some.url.1"</span>,</span><br><span class="line">		<span class="string">"http://some.url.2"</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r1 = results[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">var</span> r2 = results[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> request(</span><br><span class="line">		<span class="string">"http://some.url.3/?v="</span> + r1 + <span class="string">","</span> + r2</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( r3 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use previously defined `run(..)` utility</span></span><br><span class="line">run( foo );</span><br></pre></td></tr></table></figure>
<p>Inside <code>*foo()</code>, it’s cleaner and clearer that all we’re doing is just asking <code>bar(..)</code> to get us some <code>results</code>, and we’ll <code>yield</code>-wait on that to happen. We don’t have to care that under the covers a <code>Promise.all([ .. ])</code> Promise composition will be used to make that happen.</p>
<p><strong>We treat asynchrony, and indeed Promises, as an implementation detail.</strong></p>
<p>Hiding your Promise logic inside a function that you merely call from your generator is especially useful if you’re going to do a sophisticated series flow-control. For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span>	<span class="built_in">Promise</span>.all( [</span><br><span class="line">		  baz( .. )</span><br><span class="line">		  .then( .. ),</span><br><span class="line">		  <span class="built_in">Promise</span>.race( [ .. ] )</span><br><span class="line">		] )</span><br><span class="line">		.then( .. )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That kind of logic is sometimes required, and if you dump it directly inside your generator(s), you’ve defeated most of the reason why you would want to use generators in the first place. We <em>should</em> intentionally abstract such details away from our generator code so that they don’t clutter up the higher level task expression.</p>
<p>Beyond creating code that is both functional and performant, you should also strive to make code that is as reason-able and maintainable as possible.</p>
<p><strong>Note:</strong> Abstraction is not <em>always</em> a healthy thing for programming – many times it can increase complexity in exchange for terseness. But in this case, I believe it’s much healthier for your generator+Promise async code than the alternatives. As with all such advice, though, pay attention to your specific situations and make proper decisions for you and your team.</p>
<h2 id="Generator-Delegation"><a href="#Generator-Delegation" class="headerlink" title="Generator Delegation"></a>Generator Delegation</h2><p>In the previous section, we showed calling regular functions from inside a generator, and how that remains a useful technique for abstracting away implementation details (like async Promise flow). But the main drawback of using a normal function for this task is that it has to behave by the normal function rules, which means it cannot pause itself with <code>yield</code> like a generator can.</p>
<p>It may then occur to you that you might try to call one generator from another generator, using our <code>run(..)</code> helper, such as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2"</span> );</span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.3/?v="</span> + r2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "delegating" to `*foo()` via `run(..)`</span></span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> run( foo );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( r3 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run( bar );</span><br></pre></td></tr></table></figure>
<p>We run <code>*foo()</code> inside of <code>*bar()</code> by using our <code>run(..)</code> utility again. We take advantage here of the fact that the <code>run(..)</code> we defined earlier returns a promise which is resolved when its generator is run to completion (or errors out), so if we <code>yield</code> out to a <code>run(..)</code> instance the promise from another <code>run(..)</code> call, it automatically pauses <code>*bar()</code> until <code>*foo()</code> finishes.</p>
<p>But there’s an even better way to integrate calling <code>*foo()</code> into <code>*bar()</code>, and it’s called <code>yield</code>-delegation. The special syntax for <code>yield</code>-delegation is: <code>yield * __</code> (notice the extra <code>*</code>). Before we see it work in our previous example, let’s look at a simpler scenario:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"`*foo()` starting"</span> );</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"`*foo()` finished"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> *foo();	<span class="comment">// `yield`-delegation!</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next().value;	<span class="comment">// 1</span></span><br><span class="line">it.next().value;	<span class="comment">// 2</span></span><br><span class="line">it.next().value;	<span class="comment">// `*foo()` starting</span></span><br><span class="line">					<span class="comment">// 3</span></span><br><span class="line">it.next().value;	<span class="comment">// 4</span></span><br><span class="line">it.next().value;	<span class="comment">// `*foo()` finished</span></span><br><span class="line">					<span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Similar to a note earlier in the chapter where I explained why I prefer <code>function *foo() ..</code> instead of <code>function* foo() ..</code>, I also prefer – differing from most other documentation on the topic – to say <code>yield *foo()</code> instead of <code>yield* foo()</code>. The placement of the <code>*</code> is purely stylistic and up to your best judgment. But I find the consistency of styling attractive.</p>
<p>How does the <code>yield *foo()</code> delegation work?</p>
<p>First, calling <code>foo()</code> creates an <em>iterator</em> exactly as we’ve already seen. Then, <code>yield *</code> delegates/transfers the <em>iterator</em> instance control (of the present <code>*bar()</code> generator) over to this other <code>*foo()</code> <em>iterator</em>.</p>
<p>So, the first two <code>it.next()</code> calls are controlling <code>*bar()</code>, but when we make the third <code>it.next()</code> call, now <code>*foo()</code> starts up, and now we’re controlling <code>*foo()</code> instead of <code>*bar()</code>. That’s why it’s called delegation – <code>*bar()</code> delegated its iteration control to <code>*foo()</code>.</p>
<p>As soon as the <code>it</code> <em>iterator</em> control exhausts the entire <code>*foo()</code> <em>iterator</em>, it automatically returns to controlling <code>*bar()</code>.</p>
<p>So now back to the previous example with the three sequential Ajax requests:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2"</span> );</span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.3/?v="</span> + r2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// "delegating" to `*foo()` via `yield*`</span></span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> *foo();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( r3 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run( bar );</span><br></pre></td></tr></table></figure>
<p>The only difference between this snippet and the version used earlier is the use of <code>yield *foo()</code> instead of the previous <code>yield run(foo)</code>.</p>
<p><strong>Note:</strong> <code>yield *</code> yields iteration control, not generator control; when you invoke the <code>*foo()</code> generator, you’re now <code>yield</code>-delegating to its <em>iterator</em>. But you can actually <code>yield</code>-delegate to any <em>iterable</em>; <code>yield *[1,2,3]</code> would consume the default <em>iterator</em> for the <code>[1,2,3]</code> array value.</p>
<h3 id="Why-Delegation"><a href="#Why-Delegation" class="headerlink" title="Why Delegation?"></a>Why Delegation?</h3><p>The purpose of <code>yield</code>-delegation is mostly code organization, and in that way is symmetrical with normal function calling.</p>
<p>Imagine two modules that respectively provide methods <code>foo()</code> and <code>bar()</code>, where <code>bar()</code> calls <code>foo()</code>. The reason the two are separate is generally because the proper organization of code for the program calls for them to be in separate functions. For example, there may be cases where <code>foo()</code> is called standalone, and other places where <code>bar()</code> calls <code>foo()</code>.</p>
<p>For all these exact same reasons, keeping generators separate aids in program readability, maintenance, and debuggability. In that respect, <code>yield *</code> is a syntactic shortcut for manually iterating over the steps of <code>*foo()</code> while inside of <code>*bar()</code>.</p>
<p>Such manual approach would be especially complex if the steps in <code>*foo()</code> were asynchronous, which is why you’d probably need to use that <code>run(..)</code> utility to do it. And as we’ve shown, <code>yield *foo()</code> eliminates the need for a sub-instance of the <code>run(..)</code> utility (like <code>run(foo)</code>).</p>
<h3 id="Delegating-Messages"><a href="#Delegating-Messages" class="headerlink" title="Delegating Messages"></a>Delegating Messages</h3><p>You may wonder how this <code>yield</code>-delegation works not just with <em>iterator</em> control but with the two-way message passing. Carefully follow the flow of messages in and out, through the <code>yield</code>-delegation:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*foo()`:"</span>, <span class="keyword">yield</span> <span class="string">"B"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*foo()`:"</span>, <span class="keyword">yield</span> <span class="string">"C"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"D"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*bar()`:"</span>, <span class="keyword">yield</span> <span class="string">"A"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `yield`-delegation!</span></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*bar()`:"</span>, <span class="keyword">yield</span> *foo() );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*bar()`:"</span>, <span class="keyword">yield</span> <span class="string">"E"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next().value );</span><br><span class="line"><span class="comment">// outside: A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">1</span> ).value );</span><br><span class="line"><span class="comment">// inside `*bar()`: 1</span></span><br><span class="line"><span class="comment">// outside: B</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">2</span> ).value );</span><br><span class="line"><span class="comment">// inside `*foo()`: 2</span></span><br><span class="line"><span class="comment">// outside: C</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">3</span> ).value );</span><br><span class="line"><span class="comment">// inside `*foo()`: 3</span></span><br><span class="line"><span class="comment">// inside `*bar()`: D</span></span><br><span class="line"><span class="comment">// outside: E</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">4</span> ).value );</span><br><span class="line"><span class="comment">// inside `*bar()`: 4</span></span><br><span class="line"><span class="comment">// outside: F</span></span><br></pre></td></tr></table></figure>
<p>Pay particular attention to the processing steps after the <code>it.next(3)</code> call:</p>
<ol>
<li>The <code>3</code> value is passed (through the <code>yield</code>-delegation in <code>*bar()</code>) into the waiting <code>yield &quot;C&quot;</code> expression inside of <code>*foo()</code>.</li>
<li><code>*foo()</code> then calls <code>return &quot;D&quot;</code>, but this value doesn’t get returned all the way back to the outside <code>it.next(3)</code> call.</li>
<li>Instead, the <code>&quot;D&quot;</code> value is sent as the result of the waiting <code>yield *foo()</code> expression inside of <code>*bar()</code> – this <code>yield</code>-delegation expression has essentially been paused while all of <code>*foo()</code> was exhausted. So <code>&quot;D&quot;</code> ends up inside of <code>*bar()</code> for it to print out.</li>
<li><code>yield &quot;E&quot;</code> is called inside of <code>*bar()</code>, and the <code>&quot;E&quot;</code> value is yielded to the outside as the result of the <code>it.next(3)</code> call.</li>
</ol>
<p>From the perspective of the external <em>iterator</em> (<code>it</code>), it doesn’t appear any differently between controlling the initial generator or a delegated one.</p>
<p>In fact, <code>yield</code>-delegation doesn’t even have to be directed to another generator; it can just be directed to a non-generator, general <em>iterable</em>. For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*bar()`:"</span>, <span class="keyword">yield</span> <span class="string">"A"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `yield`-delegation to a non-generator!</span></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*bar()`:"</span>, <span class="keyword">yield</span> *[ <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span> ] );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"inside `*bar()`:"</span>, <span class="keyword">yield</span> <span class="string">"E"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next().value );</span><br><span class="line"><span class="comment">// outside: A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">1</span> ).value );</span><br><span class="line"><span class="comment">// inside `*bar()`: 1</span></span><br><span class="line"><span class="comment">// outside: B</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">2</span> ).value );</span><br><span class="line"><span class="comment">// outside: C</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">3</span> ).value );</span><br><span class="line"><span class="comment">// outside: D</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">4</span> ).value );</span><br><span class="line"><span class="comment">// inside `*bar()`: undefined</span></span><br><span class="line"><span class="comment">// outside: E</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">5</span> ).value );</span><br><span class="line"><span class="comment">// inside `*bar()`: 5</span></span><br><span class="line"><span class="comment">// outside: F</span></span><br></pre></td></tr></table></figure>
<p>Notice the differences in where the messages were received/reported between this example and the one previous.</p>
<p>Most strikingly, the default <code>array</code> <em>iterator</em> doesn’t care about any messages sent in via <code>next(..)</code> calls, so the values <code>2</code>, <code>3</code>, and <code>4</code> are essentially ignored. Also, because that <em>iterator</em> has no explicit <code>return</code> value (unlike the previously used <code>*foo()</code>), the <code>yield *</code> expression gets an <code>undefined</code> when it finishes.</p>
<h4 id="Exceptions-Delegated-Too"><a href="#Exceptions-Delegated-Too" class="headerlink" title="Exceptions Delegated, Too!"></a>Exceptions Delegated, Too!</h4><p>In the same way that <code>yield</code>-delegation transparently passes messages through in both directions, errors/exceptions also pass in both directions:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="string">"B"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"error caught inside `*foo()`:"</span>, err );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">yield</span> <span class="string">"C"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"D"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> *foo();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"error caught inside `*bar()`:"</span>, err );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">yield</span> <span class="string">"E"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">yield</span> *baz();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// note: can't get here!</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="string">"G"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next().value );</span><br><span class="line"><span class="comment">// outside: A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">1</span> ).value );</span><br><span class="line"><span class="comment">// outside: B</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.throw( <span class="number">2</span> ).value );</span><br><span class="line"><span class="comment">// error caught inside `*foo()`: 2</span></span><br><span class="line"><span class="comment">// outside: C</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">3</span> ).value );</span><br><span class="line"><span class="comment">// error caught inside `*bar()`: D</span></span><br><span class="line"><span class="comment">// outside: E</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"outside:"</span>, it.next( <span class="number">4</span> ).value );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"error caught outside:"</span>, err );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error caught outside: F</span></span><br></pre></td></tr></table></figure>
<p>Some things to note from this snippet:</p>
<ol>
<li>When we call <code>it.throw(2)</code>, it sends the error message <code>2</code> into <code>*bar()</code>, which delegates that to <code>*foo()</code>, which then <code>catch</code>es it and handles it gracefully. Then, the <code>yield &quot;C&quot;</code> sends <code>&quot;C&quot;</code> back out as the return <code>value</code> from the <code>it.throw(2)</code> call.</li>
<li>The <code>&quot;D&quot;</code> value that’s next <code>throw</code>n from inside <code>*foo()</code> propagates out to <code>*bar()</code>, which <code>catch</code>es it and handles it gracefully. Then the <code>yield &quot;E&quot;</code> sends <code>&quot;E&quot;</code> back out as the return <code>value</code> from the <code>it.next(3)</code> call.</li>
<li>Next, the exception <code>throw</code>n from <code>*baz()</code> isn’t caught in <code>*bar()</code> – though we did <code>catch</code> it outside – so both <code>*baz()</code> and <code>*bar()</code> are set to a completed state. After this snippet, you would not be able to get the <code>&quot;G&quot;</code> value out with any subsequent <code>next(..)</code> call(s) – they will just return <code>undefined</code> for <code>value</code>.</li>
</ol>
<h3 id="Delegating-Asynchrony"><a href="#Delegating-Asynchrony" class="headerlink" title="Delegating Asynchrony"></a>Delegating Asynchrony</h3><p>Let’s finally get back to our earlier <code>yield</code>-delegation example with the multiple sequential Ajax requests:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2"</span> );</span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.3/?v="</span> + r2 );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r3 = <span class="keyword">yield</span> *foo();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( r3 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run( bar );</span><br></pre></td></tr></table></figure>
<p>Instead of calling <code>yield run(foo)</code> inside of <code>*bar()</code>, we just call <code>yield *foo()</code>.</p>
<p>In the previous version of this example, the Promise mechanism (controlled by <code>run(..)</code>) was used to transport the value from <code>return r3</code> in <code>*foo()</code> to the local variable <code>r3</code> inside <code>*bar()</code>. Now, that value is just returned back directly via the <code>yield *</code> mechanics.</p>
<p>Otherwise, the behavior is pretty much identical.</p>
<h3 id="Delegating-“Recursion”"><a href="#Delegating-“Recursion”" class="headerlink" title="Delegating “Recursion”"></a>Delegating “Recursion”</h3><p>Of course, <code>yield</code>-delegation can keep following as many delegation steps as you wire up. You could even use <code>yield</code>-delegation for async-capable generator “recursion” – a generator <code>yield</code>-delegating to itself:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// generator recursion</span></span><br><span class="line">		val = <span class="keyword">yield</span> *foo( val - <span class="number">1</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">yield</span> request( <span class="string">"http://some.url/?v="</span> + val );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> *foo( <span class="number">3</span> );</span><br><span class="line">	<span class="built_in">console</span>.log( r1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run( bar );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Our <code>run(..)</code> utility could have been called with <code>run( foo, 3 )</code>, because it supports additional parameters being passed along to the initialization of the generator. However, we used a parameter-free <code>*bar()</code> here to highlight the flexibility of <code>yield *</code>.</p>
<p>What processing steps follow from that code? Hang on, this is going to be quite intricate to describe in detail:</p>
<ol>
<li><code>run(bar)</code> starts up the <code>*bar()</code> generator.</li>
<li><code>foo(3)</code> creates an <em>iterator</em> for <code>*foo(..)</code> and passes <code>3</code> as its <code>val</code> parameter.</li>
<li>Because <code>3 &gt; 1</code>, <code>foo(2)</code> creates another <em>iterator</em> and passes in <code>2</code> as its <code>val</code> parameter.</li>
<li>Because <code>2 &gt; 1</code>, <code>foo(1)</code> creates yet another <em>iterator</em> and passes in <code>1</code> as its <code>val</code> parameter.</li>
<li><code>1 &gt; 1</code> is <code>false</code>, so we next call <code>request(..)</code> with the <code>1</code> value, and get a promise back for that first Ajax call.</li>
<li>That promise is <code>yield</code>ed out, which comes back to the <code>*foo(2)</code> generator instance.</li>
<li>The <code>yield *</code> passes that promise back out to the <code>*foo(3)</code> generator instance. Another <code>yield *</code> passes the promise out to the <code>*bar()</code> generator instance. And yet again another <code>yield *</code> passes the promise out to the <code>run(..)</code> utility, which will wait on that promise (for the first Ajax request) to proceed.</li>
<li>When the promise resolves, its fulfillment message is sent to resume <code>*bar()</code>, which passes through the <code>yield *</code> into the <code>*foo(3)</code> instance, which then passes through the <code>yield *</code> to the <code>*foo(2)</code> generator instance, which then passes through the <code>yield *</code> to the normal <code>yield</code> that’s waiting in the <code>*foo(3)</code> generator instance.</li>
<li>That first call’s Ajax response is now immediately <code>return</code>ed from the <code>*foo(3)</code> generator instance, which sends that value back as the result of the <code>yield *</code> expression in the <code>*foo(2)</code> instance, and assigned to its local <code>val</code> variable.</li>
<li>Inside <code>*foo(2)</code>, a second Ajax request is made with <code>request(..)</code>, whose promise is <code>yield</code>ed back to the <code>*foo(1)</code> instance, and then <code>yield *</code> propagates all the way out to <code>run(..)</code> (step 7 again). When the promise resolves, the second Ajax response propagates all the way back into the <code>*foo(2)</code> generator instance, and is assigned to its local <code>val</code> variable.</li>
<li>Finally, the third Ajax request is made with <code>request(..)</code>, its promise goes out to <code>run(..)</code>, and then its resolution value comes all the way back, which is then <code>return</code>ed so that it comes back to the waiting <code>yield *</code> expression in <code>*bar()</code>.</li>
</ol>
<p>Phew! A lot of crazy mental juggling, huh? You might want to read through that a few more times, and then go grab a snack to clear your head!</p>
<h2 id="Generator-Concurrency"><a href="#Generator-Concurrency" class="headerlink" title="Generator Concurrency"></a>Generator Concurrency</h2><p>As we discussed in both Chapter 1 and earlier in this chapter, two simultaneously running “processes” can cooperatively interleave their operations, and many times this can <em>yield</em> (pun intended) very powerful asynchrony expressions.</p>
<p>Frankly, our earlier examples of concurrency interleaving of multiple generators showed how to make it really confusing. But we hinted that there’s places where this capability is quite useful.</p>
<p>Recall a scenario we looked at in Chapter 1, where two different simultaneous Ajax response handlers needed to coordinate with each other to make sure that the data communication was not a race condition. We slotted the responses into the <code>res</code> array like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data.url == <span class="string">"http://some.url.1"</span>) &#123;</span><br><span class="line">		res[<span class="number">0</span>] = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data.url == <span class="string">"http://some.url.2"</span>) &#123;</span><br><span class="line">		res[<span class="number">1</span>] = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But how can we use multiple generators concurrently for this scenario?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">reqData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	res.push(</span><br><span class="line">		<span class="keyword">yield</span> request( url )</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> We’re going to use two instances of the <code>*reqData(..)</code> generator here, but there’s no difference to running a single instance of two different generators; both approaches are reasoned about identically. We’ll see two different generators coordinating in just a bit.</p>
<p>Instead of having to manually sort out <code>res[0]</code> and <code>res[1]</code> assignments, we’ll use coordinated ordering so that <code>res.push(..)</code> properly slots the values in the expected and predictable order. The expressed logic thus should feel a bit cleaner.</p>
<p>But how will we actually orchestrate this interaction? First, let’s just do it manually, with Promises:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it1 = reqData( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="keyword">var</span> it2 = reqData( <span class="string">"http://some.url.2"</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = it1.next().value;</span><br><span class="line"><span class="keyword">var</span> p2 = it2.next().value;</span><br><span class="line"></span><br><span class="line">p1</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	it1.next( data );</span><br><span class="line">	<span class="keyword">return</span> p2;</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	it2.next( data );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>*reqData(..)</code>‘s two instances are both started to make their Ajax requests, then paused with <code>yield</code>. Then we choose to resume the first instance when <code>p1</code> resolves, and then <code>p2</code>‘s resolution will restart the second instance. In this way, we use Promise orchestration to ensure that <code>res[0]</code> will have the first response and <code>res[1]</code> will have the second response.</p>
<p>But frankly, this is awfully manual, and it doesn’t really let the generators orchestrate themselves, which is where the true power can lie. Let’s try it a different way:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">reqData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> data = <span class="keyword">yield</span> request( url );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// transfer control</span></span><br><span class="line">	<span class="keyword">yield</span>;</span><br><span class="line"></span><br><span class="line">	res.push( data );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it1 = reqData( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="keyword">var</span> it2 = reqData( <span class="string">"http://some.url.2"</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = it1.next().value;</span><br><span class="line"><span class="keyword">var</span> p2 = it2.next().value;</span><br><span class="line"></span><br><span class="line">p1.then( <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	it1.next( data );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p2.then( <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	it2.next( data );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all( [p1,p2] )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	it1.next();</span><br><span class="line">	it2.next();</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>OK, this is a bit better (though still manual!), because now the two instances of <code>*reqData(..)</code> run truly concurrently, and (at least for the first part) independently.</p>
<p>In the previous snippet, the second instance was not given its data until after the first instance was totally finished. But here, both instances receive their data as soon as their respective responses come back, and then each instance does another <code>yield</code> for control transfer purposes. We then choose what order to resume them in the <code>Promise.all([ .. ])</code> handler.</p>
<p>What may not be as obvious is that this approach hints at an easier form for a reusable utility, because of the symmetry. We can do even better. Let’s imagine using a utility called <code>runAll(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line">runAll(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> p1 = request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// transfer control</span></span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line"></span><br><span class="line">		res.push( <span class="keyword">yield</span> p1 );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> p2 = request( <span class="string">"http://some.url.2"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// transfer control</span></span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line"></span><br><span class="line">		res.push( <span class="keyword">yield</span> p2 );</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> We’re not including a code listing for <code>runAll(..)</code> as it is not only long enough to bog down the text, but is an extension of the logic we’ve already implemented in <code>run(..)</code> earlier. So, as a good supplementary exercise for the reader, try your hand at evolving the code from <code>run(..)</code> to work like the imagined <code>runAll(..)</code>. Also, my <em>asynquence</em> library provides a previously mentioned <code>runner(..)</code> utility with this kind of capability already built in, and will be discussed in Appendix A of this book.</p>
<p>Here’s how the processing inside <code>runAll(..)</code> would operate:</p>
<ol>
<li>The first generator gets a promise for the first Ajax response from <code>&quot;http://some.url.1&quot;</code>, then <code>yield</code>s control back to the <code>runAll(..)</code> utility.</li>
<li>The second generator runs and does the same for <code>&quot;http://some.url.2&quot;</code>, <code>yield</code>ing control back to the <code>runAll(..)</code> utility.</li>
<li>The first generator resumes, and then <code>yield</code>s out its promise <code>p1</code>. The <code>runAll(..)</code> utility does the same in this case as our previous <code>run(..)</code>, in that it waits on that promise to resolve, then resumes the same generator (no control transfer!). When <code>p1</code> resolves, <code>runAll(..)</code> resumes the first generator again with that resolution value, and then <code>res[0]</code> is given its value. When the first generator then finishes, that’s an implicit transfer of control.</li>
<li>The second generator resumes, <code>yield</code>s out its promise <code>p2</code>, and waits for it to resolve. Once it does, <code>runAll(..)</code> resumes the second generator with that value, and <code>res[1]</code> is set.</li>
</ol>
<p>In this running example, we use an outer variable called <code>res</code> to store the results of the two different Ajax responses – that’s our concurrency coordination making that possible.</p>
<p>But it might be quite helpful to further extend <code>runAll(..)</code> to provide an inner variable space for the multiple generator instances to <em>share</em>, such as an empty object we’ll call <code>data</code> below. Also, it could take non-Promise values that are <code>yield</code>ed and hand them off to the next generator.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line">runAll(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>*(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		data.res = [];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// transfer control (and message pass)</span></span><br><span class="line">		<span class="keyword">var</span> url1 = <span class="keyword">yield</span> <span class="string">"http://some.url.2"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> p1 = request( url1 ); <span class="comment">// "http://some.url.1"</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// transfer control</span></span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line"></span><br><span class="line">		data.res.push( <span class="keyword">yield</span> p1 );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>*(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// transfer control (and message pass)</span></span><br><span class="line">		<span class="keyword">var</span> url2 = <span class="keyword">yield</span> <span class="string">"http://some.url.1"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> p2 = request( url2 ); <span class="comment">// "http://some.url.2"</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// transfer control</span></span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line"></span><br><span class="line">		data.res.push( <span class="keyword">yield</span> p2 );</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>In this formulation, the two generators are not just coordinating control transfer, but actually communicating with each other, both through <code>data.res</code> and the <code>yield</code>ed messages that trade <code>url1</code> and <code>url2</code> values. That’s incredibly powerful!</p>
<p>Such realization also serves as a conceptual base for a more sophisticated asynchrony technique called CSP (Communicating Sequential Processes), which we will cover in Appendix B of this book.</p>
<h2 id="Thunks"><a href="#Thunks" class="headerlink" title="Thunks"></a>Thunks</h2><p>So far, we’ve made the assumption that <code>yield</code>ing a Promise from a generator – and having that Promise resume the generator via a helper utility like <code>run(..)</code> – was the best possible way to manage asynchrony with generators. To be clear, it is.</p>
<p>But we skipped over another pattern that has some mildly widespread adoption, so in the interest of completeness we’ll take a brief look at it.</p>
<p>In general computer science, there’s an old pre-JS concept called a “thunk.” Without getting bogged down in the historical nature, a narrow expression of a thunk in JS is a function that – without any parameters – is wired to call another function.</p>
<p>In other words, you wrap a function definition around function call – with any parameters it needs – to <em>defer</em> the execution of that call, and that wrapping function is a thunk. When you later execute the thunk, you end up calling the original function.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooThunk</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> foo( <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( fooThunk() );	<span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>So, a synchronous thunk is pretty straightforward. But what about an async thunk? We can essentially extend the narrow thunk definition to include it receiving a callback.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,cb</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		cb( x + y );</span><br><span class="line">	&#125;, <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooThunk</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">	foo( <span class="number">3</span>, <span class="number">4</span>, cb );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line">fooThunk( <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( sum );		<span class="comment">// 7</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>As you can see, <code>fooThunk(..)</code> only expects a <code>cb(..)</code> parameter, as it already has values <code>3</code> and <code>4</code> (for <code>x</code> and <code>y</code>, respectively) pre-specified and ready to pass to <code>foo(..)</code>. A thunk is just waiting around patiently for the last piece it needs to do its job: the callback.</p>
<p>You don’t want to make thunks manually, though. So, let’s invent a utility that does this wrapping for us.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">		args.push( cb );</span><br><span class="line">		<span class="keyword">return</span> fn.apply( <span class="literal">null</span>, args );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooThunk = thunkify( foo, <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line">fooThunk( <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( sum );		<span class="comment">// 7</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Tip:</strong> Here we assume that the original (<code>foo(..)</code>) function signature expects its callback in the last position, with any other parameters coming before it. This is a pretty ubiquitous “standard” for async JS function standards. You might call it “callback-last style.” If for some reason you had a need to handle “callback-first style” signatures, you would just make a utility that used <code>args.unshift(..)</code> instead of <code>args.push(..)</code>.</p>
<p>The preceding formulation of <code>thunkify(..)</code> takes both the <code>foo(..)</code> function reference, and any parameters it needs, and returns back the thunk itself (<code>fooThunk(..)</code>). However, that’s not the typical approach you’ll find to thunks in JS.</p>
<p>Instead of <code>thunkify(..)</code> making the thunk itself, typically – if not perplexingly – the <code>thunkify(..)</code> utility would produce a function that produces thunks.</p>
<p>Uhhhh… yeah.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> args = [].slice.call( <span class="built_in">arguments</span> );</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">			args.push( cb );</span><br><span class="line">			<span class="keyword">return</span> fn.apply( <span class="literal">null</span>, args );</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The main difference here is the extra <code>return function() { .. }</code> layer. Here’s how its usage differs:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> whatIsThis = thunkify( foo );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooThunk = whatIsThis( <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line">fooThunk( <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( sum );		<span class="comment">// 7</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Obviously, the big question this snippet implies is what is <code>whatIsThis</code> properly called? It’s not the thunk, it’s the thing that will produce thunks from <code>foo(..)</code> calls. It’s kind of like a “factory” for “thunks.” There doesn’t seem to be any kind of standard agreement for naming such a thing.</p>
<p>So, my proposal is “thunkory” (“thunk” + “factory”).  So, <code>thunkify(..)</code> produces a thunkory, and a thunkory produces thunks. That reasoning is symmetric to my proposal for “promisory” in Chapter 3:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooThunkory = thunkify( foo );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooThunk1 = fooThunkory( <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line"><span class="keyword">var</span> fooThunk2 = fooThunkory( <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line">fooThunk1( <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( sum );		<span class="comment">// 7</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">fooThunk2( <span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( sum );		<span class="comment">// 11</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> The running <code>foo(..)</code> example expects a style of callback that’s not “error-first style.” Of course, “error-first style” is much more common. If <code>foo(..)</code> had some sort of legitimate error-producing expectation, we could change it to expect and use an error-first callback. None of the subsequent <code>thunkify(..)</code> machinery cares what style of callback is assumed. The only difference in usage would be <code>fooThunk1(function(err,sum){..</code>.</p>
<p>Exposing the thunkory method – instead of how the earlier <code>thunkify(..)</code> hides this intermediary step – may seem like unnecessary complication. But in general, it’s quite useful to make thunkories at the beginning of your program to wrap existing API methods, and then be able to pass around and call those thunkories when you need thunks. The two distinct steps preserve a cleaner separation of capability.</p>
<p>To illustrate:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cleaner:</span></span><br><span class="line"><span class="keyword">var</span> fooThunkory = thunkify( foo );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooThunk1 = fooThunkory( <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line"><span class="keyword">var</span> fooThunk2 = fooThunkory( <span class="number">5</span>, <span class="number">6</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// instead of:</span></span><br><span class="line"><span class="keyword">var</span> fooThunk1 = thunkify( foo, <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line"><span class="keyword">var</span> fooThunk2 = thunkify( foo, <span class="number">5</span>, <span class="number">6</span> );</span><br></pre></td></tr></table></figure>
<p>Regardless of whether you like to deal with the thunkories explicitly or not, the usage of thunks <code>fooThunk1(..)</code> and <code>fooThunk2(..)</code> remains the same.</p>
<h3 id="s-promise-thunk"><a href="#s-promise-thunk" class="headerlink" title="s/promise/thunk/"></a>s/promise/thunk/</h3><p>So what’s all this thunk stuff have to do with generators?</p>
<p>Comparing thunks to promises generally: they’re not directly interchangable as they’re not equivalent in behavior. Promises are vastly more capable and trustable than bare thunks.</p>
<p>But in another sense, they both can be seen as a request for a value, which may be async in its answering.</p>
<p>Recall from Chapter 3 we defined a utility for promisifying a function, which we called <code>Promise.wrap(..)</code> – we could have called it <code>promisify(..)</code>, too! This Promise-wrapping utility doesn’t produce Promises; it produces promisories that in turn produce Promises. This is completely symmetric to the thunkories and thunks presently being discussed.</p>
<p>To illustrate the symmetry, let’s first alter the running <code>foo(..)</code> example from earlier to assume an “error-first style” callback:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,cb</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// assume `cb(..)` as "error-first style"</span></span><br><span class="line">		cb( <span class="literal">null</span>, x + y );</span><br><span class="line">	&#125;, <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, we’ll compare using <code>thunkify(..)</code> and <code>promisify(..)</code> (aka <code>Promise.wrap(..)</code> from Chapter 3):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// symmetrical: constructing the question asker</span></span><br><span class="line"><span class="keyword">var</span> fooThunkory = thunkify( foo );</span><br><span class="line"><span class="keyword">var</span> fooPromisory = promisify( foo );</span><br><span class="line"></span><br><span class="line"><span class="comment">// symmetrical: asking the question</span></span><br><span class="line"><span class="keyword">var</span> fooThunk = fooThunkory( <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line"><span class="keyword">var</span> fooPromise = fooPromisory( <span class="number">3</span>, <span class="number">4</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the thunk answer</span></span><br><span class="line">fooThunk( <span class="function"><span class="keyword">function</span>(<span class="params">err,sum</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( sum );		<span class="comment">// 7</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the promise answer</span></span><br><span class="line">fooPromise</span><br><span class="line">.then(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( sum );		<span class="comment">// 7</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.error( err );</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Both the thunkory and the promisory are essentially asking a question (for a value), and respectively the thunk <code>fooThunk</code> and promise <code>fooPromise</code> represent the future answers to that question. Presented in that light, the symmetry is clear.</p>
<p>With that perspective in mind, we can see that generators which <code>yield</code> Promises for asynchrony could instead <code>yield</code> thunks for asynchrony. All we’d need is a smarter <code>run(..)</code> utility (like from before) that can not only look for and wire up to a <code>yield</code>ed Promise but also to provide a callback to a <code>yield</code>ed thunk.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> val = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">	<span class="built_in">console</span>.log( val );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run( foo );</span><br></pre></td></tr></table></figure>
<p>In this example, <code>request(..)</code> could either be a promisory that returns a promise, or a thunkory that returns a thunk. From the perspective of what’s going on inside the generator code logic, we don’t care about that implementation detail, which is quite powerful!</p>
<p>So, <code>request(..)</code> could be either:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promisory `request(..)` (see Chapter 3)</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">Promise</span>.wrap( ajax );</span><br><span class="line"></span><br><span class="line"><span class="comment">// vs.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// thunkory `request(..)`</span></span><br><span class="line"><span class="keyword">var</span> request = thunkify( ajax );</span><br></pre></td></tr></table></figure>
<p>Finally, as a thunk-aware patch to our earlier <code>run(..)</code> utility, we would need logic like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..</span></span><br><span class="line"><span class="comment">// did we receive a thunk back?</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> next.value == <span class="string">"function"</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// call the thunk with an error-first callback</span></span><br><span class="line">		next.value( <span class="function"><span class="keyword">function</span>(<span class="params">err,msg</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				reject( err );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				resolve( msg );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125; )</span><br><span class="line">	.then(</span><br><span class="line">		handleNext,</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">handleErr</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">				it.throw( err )</span><br><span class="line">			)</span><br><span class="line">			.then( handleResult );</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, our generators can either call promisories to <code>yield</code> Promises, or call thunkories to <code>yield</code> thunks, and in either case, <code>run(..)</code> would handle that value and use it to wait for the completion to resume the generator.</p>
<p>Symmetry wise, these two approaches look identical. However, we should point out that’s true only from the perspective of Promises or thunks representing the future value continuation of a generator.</p>
<p>From the larger perspective, thunks do not in and of themselves have hardly any of the trustability or composability guarantees that Promises are designed with. Using a thunk as a stand-in for a Promise in this particular generator asynchrony pattern is workable but should be seen as less than ideal when compared to all the benefits that Promises offer (see Chapter 3).</p>
<p>If you have the option, prefer <code>yield pr</code> rather than <code>yield th</code>. But there’s nothing wrong with having a <code>run(..)</code> utility which can handle both value types.</p>
<p><strong>Note:</strong> The <code>runner(..)</code> utility in my <em>asynquence</em> library, which will be discussed in Appendix A, handles <code>yield</code>s of Promises, thunks and <em>asynquence</em> sequences.</p>
<h2 id="Pre-ES6-Generators"><a href="#Pre-ES6-Generators" class="headerlink" title="Pre-ES6 Generators"></a>Pre-ES6 Generators</h2><p>You’re hopefully convinced now that generators are a very important addition to the async programming toolbox. But it’s a new syntax in ES6, which means you can’t just polyfill generators like you can Promises (which are just a new API). So what can we do to bring generators to our browser JS if we don’t have the luxury of ignoring pre-ES6 browsers?</p>
<p>For all new syntax extensions in ES6, there are tools – the most common term for them is transpilers, for trans-compilers – which can take your ES6 syntax and transform it into equivalent (but obviously uglier!) pre-ES6 code. So, generators can be transpiled into code that will have the same behavior but work in ES5 and below.</p>
<p>But how? The “magic” of <code>yield</code> doesn’t obviously sound like code that’s easy to transpile. We actually hinted at a solution in our earlier discussion of closure-based <em>iterators</em>.</p>
<h3 id="Manual-Transformation"><a href="#Manual-Transformation" class="headerlink" title="Manual Transformation"></a>Manual Transformation</h3><p>Before we discuss the transpilers, let’s derive how manual transpilation would work in the case of generators. This isn’t just an academic exercise, because doing so will actually help further reinforce how they work.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"requesting:"</span>, url );</span><br><span class="line">		<span class="keyword">var</span> val = <span class="keyword">yield</span> request( url );</span><br><span class="line">		<span class="built_in">console</span>.log( val );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"Oops:"</span>, err );</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo( <span class="string">"http://some.url.1"</span> );</span><br></pre></td></tr></table></figure>
<p>The first thing to observe is that we’ll still need a normal <code>foo()</code> function that can be called, and it will still need to return an <em>iterator</em>. So, let’s sketch out the non-generator transformation:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// make and return an iterator</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		next: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// ..</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="keyword">throw</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// ..</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo( <span class="string">"http://some.url.1"</span> );</span><br></pre></td></tr></table></figure>
<p>The next thing to observe is that a generator does its “magic” by suspending its scope/state, but we can emulate that with function closure (see the <em>Scope &amp; Closures</em> title of this series). To understand how to write such code, we’ll first annotate different parts of our generator with state values:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// STATE *1*</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"requesting:"</span>, url );</span><br><span class="line">		<span class="keyword">var</span> TMP1 = request( url );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// STATE *2*</span></span><br><span class="line">		<span class="keyword">var</span> val = <span class="keyword">yield</span> TMP1;</span><br><span class="line">		<span class="built_in">console</span>.log( val );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">		<span class="comment">// STATE *3*</span></span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"Oops:"</span>, err );</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> For more accurate illustration, we split up the <code>val = yield request..</code> statement into two parts, using the temporary <code>TMP1</code> variable. <code>request(..)</code> happens in state <code>*1*</code>, and the assignment of its completion value to <code>val</code> happens in state <code>*2*</code>. We’ll get rid of that intermediate <code>TMP1</code> when we convert the code to its non-generator equivalent.</p>
<p>In other words, <code>*1*</code> is the beginning state, <code>*2*</code> is the state if the <code>request(..)</code> succeeds, and <code>*3*</code> is the state if the <code>request(..)</code> fails. You can probably imagine how any extra <code>yield</code> steps would just be encoded as extra states.</p>
<p>Back to our transpiled generator, let’s define a variable <code>state</code> in the closure we can use to keep track of the state:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// manage generator state</span></span><br><span class="line">	<span class="keyword">var</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, let’s define an inner function called <code>process(..)</code> inside the closure which handles each state, using a <code>switch</code> statement:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// manage generator state</span></span><br><span class="line">	<span class="keyword">var</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// generator-wide variable declarations</span></span><br><span class="line">	<span class="keyword">var</span> val;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (state) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">"requesting:"</span>, url );</span><br><span class="line">				<span class="keyword">return</span> request( url );</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				val = v;</span><br><span class="line">				<span class="built_in">console</span>.log( val );</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">var</span> err = v;</span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">"Oops:"</span>, err );</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Each state in our generator is represented by its own <code>case</code> in the <code>switch</code> statement. <code>process(..)</code> will be called each time we need to process a new state. We’ll come back to how that works in just a moment.</p>
<p>For any generator-wide variable declarations (<code>val</code>), we move those to a <code>var</code> declaration outside of <code>process(..)</code> so they can survive multiple calls to <code>process(..)</code>. But the “block scoped” <code>err</code> variable is only needed for the <code>*3*</code> state, so we leave it in place.</p>
<p>In state <code>*1*</code>, instead of <code>yield request(..)</code>, we did <code>return request(..)</code>. In terminal state <code>*2*</code>, there was no explicit <code>return</code>, so we just do a <code>return;</code> which is the same as <code>return undefined</code>. In terminal state <code>*3*</code>, there was a <code>return false</code>, so we preserve that.</p>
<p>Now we need to define the code in the <em>iterator</em> functions so they call <code>process(..)</code> appropriately:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// manage generator state</span></span><br><span class="line">	<span class="keyword">var</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// generator-wide variable declarations</span></span><br><span class="line">	<span class="keyword">var</span> val;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (state) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">"requesting:"</span>, url );</span><br><span class="line">				<span class="keyword">return</span> request( url );</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				val = v;</span><br><span class="line">				<span class="built_in">console</span>.log( val );</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">var</span> err = v;</span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">"Oops:"</span>, err );</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make and return an iterator</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		next: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// initial state</span></span><br><span class="line">			<span class="keyword">if</span> (!state) &#123;</span><br><span class="line">				state = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					done: <span class="literal">false</span>,</span><br><span class="line">					value: process()</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// yield resumed successfully</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">				state = <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					done: <span class="literal">true</span>,</span><br><span class="line">					value: process( v )</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// generator already completed</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					done: <span class="literal">true</span>,</span><br><span class="line">					value: <span class="literal">undefined</span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"throw"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">			<span class="comment">// the only explicit error handling is in</span></span><br><span class="line">			<span class="comment">// state *1*</span></span><br><span class="line">			<span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">				state = <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					done: <span class="literal">true</span>,</span><br><span class="line">					value: process( e )</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// otherwise, an error won't be handled,</span></span><br><span class="line">			<span class="comment">// so just throw it right back out</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How does this code work?</p>
<ol>
<li>The first call to the <em>iterator</em>‘s <code>next()</code> call would move the generator from the uninitialized state to state <code>1</code>, and then call <code>process()</code> to handle that state. The return value from <code>request(..)</code>, which is the promise for the Ajax response, is returned back as the <code>value</code> property from the <code>next()</code> call.</li>
<li>If the Ajax request succeeds, the second call to <code>next(..)</code> should send in the Ajax response value, which moves our state to <code>2</code>. <code>process(..)</code> is again called (this time with the passed in Ajax response value), and the <code>value</code> property returned from <code>next(..)</code> will be <code>undefined</code>.</li>
<li>However, if the Ajax request fails, <code>throw(..)</code> should be called with the error, which would move the state from <code>1</code> to <code>3</code> (instead of <code>2</code>). Again <code>process(..)</code> is called, this time with the error value. That <code>case</code> returns <code>false</code>, which is set as the <code>value</code> property returned from the <code>throw(..)</code> call.</li>
</ol>
<p>From the outside – that is, interacting only with the <em>iterator</em> – this <code>foo(..)</code> normal function works pretty much the same as the <code>*foo(..)</code> generator would have worked. So we’ve effectively “transpiled” our ES6 generator to pre-ES6 compatibility!</p>
<p>We could then manually instantiate our generator and control its iterator – calling <code>var it = foo(&quot;..&quot;)</code> and <code>it.next(..)</code> and such – or better, we could pass it to our previously defined <code>run(..)</code> utility as <code>run(foo,&quot;..&quot;)</code>.</p>
<h3 id="Automatic-Transpilation"><a href="#Automatic-Transpilation" class="headerlink" title="Automatic Transpilation"></a>Automatic Transpilation</h3><p>The preceding exercise of manually deriving a transformation of our ES6 generator to pre-ES6 equivalent teaches us how generators work conceptually. But that transformation was really intricate and very non-portable to other generators in our code. It would be quite impractical to do this work by hand, and would completely obviate all the benefit of generators.</p>
<p>But luckily, several tools already exist that can automatically convert ES6 generators to things like what we derived in the previous section. Not only do they do the heavy lifting work for us, but they also handle several complications that we glossed over.</p>
<p>One such tool is regenerator (<a href="https://facebook.github.io/regenerator/)" target="_blank" rel="noopener">https://facebook.github.io/regenerator/)</a>, from the smart folks at Facebook.</p>
<p>If we use regenerator to transpile our previous generator, here’s the code produced (at the time of this writing):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `request(..)` is a Promise-aware Ajax utility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = regeneratorRuntime.mark(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">foo$</span>(<span class="params">context$<span class="number">1</span>$<span class="number">0</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) <span class="keyword">switch</span> (context$<span class="number">1</span>$<span class="number">0.</span>prev = context$<span class="number">1</span>$<span class="number">0.</span>next) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            context$<span class="number">1</span>$<span class="number">0.</span>prev = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">console</span>.log( <span class="string">"requesting:"</span>, url );</span><br><span class="line">            context$<span class="number">1</span>$<span class="number">0.</span>next = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">return</span> request( url );</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            val = context$<span class="number">1</span>$<span class="number">0.</span>sent;</span><br><span class="line">            <span class="built_in">console</span>.log( val );</span><br><span class="line">            context$<span class="number">1</span>$<span class="number">0.</span>next = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            context$<span class="number">1</span>$<span class="number">0.</span>prev = <span class="number">8</span>;</span><br><span class="line">            context$<span class="number">1</span>$<span class="number">0.</span>t0 = context$<span class="number">1</span>$<span class="number">0.</span><span class="keyword">catch</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Oops:"</span>, context$<span class="number">1</span>$<span class="number">0.</span>t0);</span><br><span class="line">            <span class="keyword">return</span> context$<span class="number">1</span>$<span class="number">0.</span>abrupt(<span class="string">"return"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">            <span class="keyword">return</span> context$<span class="number">1</span>$<span class="number">0.</span>stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, foo, <span class="keyword">this</span>, [[<span class="number">0</span>, <span class="number">8</span>]]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>There’s some obvious similarities here to our manual derivation, such as the <code>switch</code> / <code>case</code> statements, and we even see <code>val</code> pulled out of the closure just as we did.</p>
<p>Of course, one trade-off is that regenerator’s transpilation requires a helper library <code>regeneratorRuntime</code> that holds all the reusable logic for managing a general generator / <em>iterator</em>. A lot of that boilerplate looks different than our version, but even then, the concepts can be seen, like with <code>context$1$0.next = 4</code> keeping track of the next state for the generator.</p>
<p>The main takeaway is that generators are not restricted to only being useful in ES6+ environments. Once you understand the concepts, you can employ them throughout your code, and use tools to transform the code to be compatible with older environments.</p>
<p>This is more work than just using a <code>Promise</code> API polyfill for pre-ES6 Promises, but the effort is totally worth it, because generators are so much better at expressing async flow control in a reason-able, sensible, synchronous-looking, sequential fashion.</p>
<p>Once you get hooked on generators, you’ll never want to go back to the hell of async spaghetti callbacks!</p>
<h2 id="Review-3"><a href="#Review-3" class="headerlink" title="Review"></a>Review</h2><p>Generators are a new ES6 function type that does not run-to-completion like normal functions. Instead, the generator can be paused in mid-completion (entirely preserving its state), and it can later be resumed from where it left off.</p>
<p>This pause/resume interchange is cooperative rather than preemptive, which means that the generator has the sole capability to pause itself, using the <code>yield</code> keyword, and yet the <em>iterator</em> that controls the generator has the sole capability (via <code>next(..)</code>) to resume the generator.</p>
<p>The <code>yield</code> / <code>next(..)</code> duality is not just a control mechanism, it’s actually a two-way message passing mechanism. A <code>yield ..</code> expression essentially pauses waiting for a value, and the next <code>next(..)</code> call passes a value (or implicit <code>undefined</code>) back to that paused <code>yield</code> expression.</p>
<p>The key benefit of generators related to async flow control is that the code inside a generator expresses a sequence of steps for the task in a naturally sync/sequential fashion. The trick is that we essentially hide potential asynchrony behind the <code>yield</code> keyword – moving the asynchrony to the code where the generator’s <em>iterator</em> is controlled.</p>
<p>In other words, generators preserve a sequential, synchronous, blocking code pattern for async code, which lets our brains reason about the code much more naturally, addressing one of the two key drawbacks of callback-based async.</p>
<h1 id="Chapter-5-Program-Performance"><a href="#Chapter-5-Program-Performance" class="headerlink" title="Chapter 5: Program Performance"></a>Chapter 5: Program Performance</h1><p>This book so far has been all about how to leverage asynchrony patterns more effectively. But we haven’t directly addressed why asynchrony really matters to JS. The most obvious explicit reason is <strong>performance</strong>.</p>
<p>For example, if you have two Ajax requests to make, and they’re independent, but you need to wait on them both to finish before doing the next task, you have two options for modeling that interaction: serial and concurrent.</p>
<p>You could make the first request and wait to start the second request until the first finishes. Or, as we’ve seen both with promises and generators, you could make both requests “in parallel,” and express the “gate” to wait on both of them before moving on.</p>
<p>Clearly, the latter is usually going to be more performant than the former. And better performance generally leads to better user experience.</p>
<p>It’s even possible that asynchrony (interleaved concurrency) can improve just the perception of performance, even if the overall program still takes the same amount of time to complete. User perception of performance is every bit – if not more! – as important as actual measurable performance.</p>
<p>We want to now move beyond localized asynchrony patterns to talk about some bigger picture performance details at the program level.</p>
<p><strong>Note:</strong> You may be wondering about micro-performance issues like if <code>a++</code> or <code>++a</code> is faster. We’ll look at those sorts of performance details in the next chapter on “Benchmarking &amp; Tuning.”</p>
<h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>If you have processing-intensive tasks but you don’t want them to run on the main thread (which may slow down the browser/UI), you might have wished that JavaScript could operate in a multithreaded manner.</p>
<p>In Chapter 1, we talked in detail about how JavaScript is single threaded. And that’s still true. But a single thread isn’t the only way to organize the execution of your program.</p>
<p>Imagine splitting your program into two pieces, and running one of those pieces on the main UI thread, and running the other piece on an entirely separate thread.</p>
<p>What kinds of concerns would such an architecture bring up?</p>
<p>For one, you’d want to know if running on a separate thread meant that it ran in parallel (on systems with multiple CPUs/cores) such that a long-running process on that second thread would <strong>not</strong> block the main program thread. Otherwise, “virtual threading” wouldn’t be of much benefit over what we already have in JS with async concurrency.</p>
<p>And you’d want to know if these two pieces of the program have access to the same shared scope/resources. If they do, then you have all the questions that multithreaded languages (Java, C++, etc.) deal with, such as needing cooperative or preemptive locking (mutexes, etc.). That’s a lot of extra work, and shouldn’t be undertaken lightly.</p>
<p>Alternatively, you’d want to know how these two pieces could “communicate” if they couldn’t share scope/resources.</p>
<p>All these are great questions to consider as we explore a feature added to the web platform circa HTML5 called “Web Workers.” This is a feature of the browser (aka host environment) and actually has almost nothing to do with the JS language itself. That is, JavaScript does not <em>currently</em> have any features that support threaded execution.</p>
<p>But an environment like your browser can easily provide multiple instances of the JavaScript engine, each on its own thread, and let you run a different program in each thread. Each of those separate threaded pieces of your program is called a “(Web) Worker.” This type of parallelism is called “task parallelism,” as the emphasis is on splitting up chunks of your program to run in parallel.</p>
<p>From your main JS program (or another Worker), you instantiate a Worker like so:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w1 = <span class="keyword">new</span> Worker( <span class="string">"http://some.url.1/mycoolworker.js"</span> );</span><br></pre></td></tr></table></figure>
<p>The URL should point to the location of a JS file (not an HTML page!) which is intended to be loaded into a Worker. The browser will then spin up a separate thread and let that file run as an independent program in that thread.</p>
<p><strong>Note:</strong> The kind of Worker created with such a URL is called a “Dedicated Worker.” But instead of providing a URL to an external file, you can also create an “Inline Worker” by providing a Blob URL (another HTML5 feature); essentially it’s an inline file stored in a single (binary) value. However, Blobs are beyond the scope of what we’ll discuss here.</p>
<p>Workers do not share any scope or resources with each other or the main program – that would bring all the nightmares of threaded programming to the forefront – but instead have a basic event messaging mechanism connecting them.</p>
<p>The <code>w1</code> Worker object is an event listener and trigger, which lets you subscribe to events sent by the Worker as well as send events to the Worker.</p>
<p>Here’s how to listen for events (actually, the fixed <code>&quot;message&quot;</code> event):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w1.addEventListener( <span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// evt.data</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>And you can send the <code>&quot;message&quot;</code> event to the Worker:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1.postMessage( <span class="string">"something cool to say"</span> );</span><br></pre></td></tr></table></figure>
<p>Inside the Worker, the messaging is totally symmetrical:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "mycoolworker.js"</span></span><br><span class="line"></span><br><span class="line">addEventListener( <span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// evt.data</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">postMessage( <span class="string">"a really cool reply"</span> );</span><br></pre></td></tr></table></figure>
<p>Notice that a dedicated Worker is in a one-to-one relationship with the program that created it. That is, the <code>&quot;message&quot;</code> event doesn’t need any disambiguation here, because we’re sure that it could only have come from this one-to-one relationship – either it came from the Worker or the main page.</p>
<p>Usually the main page application creates the Workers, but a Worker can instantiate its own child Worker(s) – known as subworkers – as necessary. Sometimes this is useful to delegate such details to a sort of “master” Worker that spawns other Workers to process parts of a task. Unfortunately, at the time of this writing, Chrome still does not support subworkers, while Firefox does.</p>
<p>To kill a Worker immediately from the program that created it, call <code>terminate()</code> on the Worker object (like <code>w1</code> in the previous snippets). Abruptly terminating a Worker thread does not give it any chance to finish up its work or clean up any resources. It’s akin to you closing a browser tab to kill a page.</p>
<p>If you have two or more pages (or multiple tabs with the same page!) in the browser that try to create a Worker from the same file URL, those will actually end up as completely separate Workers. Shortly, we’ll discuss a way to “share” a Worker.</p>
<p><strong>Note:</strong> It may seem like a malicious or ignorant JS program could easily perform a denial-of-service attack on a system by spawning hundreds of Workers, seemingly each with their own thread. While it’s true that it’s somewhat of a guarantee that a Worker will end up on a separate thread, this guarantee is not unlimited. The system is free to decide how many actual threads/CPUs/cores it really wants to create. There’s no way to predict or guarantee how many you’ll have access to, though many people assume it’s at least as many as the number of CPUs/cores available. I think the safest assumption is that there’s at least one other thread besides the main UI thread, but that’s about it.</p>
<h3 id="Worker-Environment"><a href="#Worker-Environment" class="headerlink" title="Worker Environment"></a>Worker Environment</h3><p>Inside the Worker, you do not have access to any of the main program’s resources. That means you cannot access any of its global variables, nor can you access the page’s DOM or other resources. Remember: it’s a totally separate thread.</p>
<p>You can, however, perform network operations (Ajax, WebSockets) and set timers. Also, the Worker has access to its own copy of several important global variables/features, including <code>navigator</code>, <code>location</code>, <code>JSON</code>, and <code>applicationCache</code>.</p>
<p>You can also load extra JS scripts into your Worker, using <code>importScripts(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside the Worker</span></span><br><span class="line">importScripts( <span class="string">"foo.js"</span>, <span class="string">"bar.js"</span> );</span><br></pre></td></tr></table></figure>
<p>These scripts are loaded synchronously, which means the <code>importScripts(..)</code> call will block the rest of the Worker’s execution until the file(s) are finished loading and executing.</p>
<p><strong>Note:</strong> There have also been some discussions about exposing the <code>&lt;canvas&gt;</code> API to Workers, which combined with having canvases be Transferables (see the “Data Transfer” section), would allow Workers to perform more sophisticated off-thread graphics processing, which can be useful for high-performance gaming (WebGL) and other similar applications. Although this doesn’t exist yet in any browsers, it’s likely to happen in the near future.</p>
<p>What are some common uses for Web Workers?</p>
<ul>
<li>Processing intensive math calculations</li>
<li>Sorting large data sets</li>
<li>Data operations (compression, audio analysis, image pixel manipulations, etc.)</li>
<li>High-traffic network communications</li>
</ul>
<h3 id="Data-Transfer"><a href="#Data-Transfer" class="headerlink" title="Data Transfer"></a>Data Transfer</h3><p>You may notice a common characteristic of most of those uses, which is that they require a large amount of information to be transferred across the barrier between threads using the event mechanism, perhaps in both directions.</p>
<p>In the early days of Workers, serializing all data to a string value was the only option. In addition to the speed penalty of the two-way serializations, the other major negative was that the data was being copied, which meant a doubling of memory usage (and the subsequent churn of garbage collection).</p>
<p>Thankfully, we now have a few better options.</p>
<p>If you pass an object, a so-called “Structured Cloning Algorithm” (<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm</a>) is used to copy/duplicate the object on the other side. This algorithm is fairly sophisticated and can even handle duplicating objects with circular references. The to-string/from-string performance penalty is not paid, but we still have duplication of memory using this approach. There is support for this in IE10 and above, as well as all the other major browsers.</p>
<p>An even better option, especially for larger data sets, is “Transferable Objects” (<a href="http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast)" target="_blank" rel="noopener">http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast)</a>. What happens is that the object’s “ownership” is transferred, but the data itself is not moved. Once you transfer away an object to a Worker, it’s empty or inaccessible in the originating location – that eliminates the hazards of threaded programming over a shared scope. Of course, transfer of ownership can go in both directions.</p>
<p>There really isn’t much you need to do to opt into a Transferable Object; any data structure that implements the Transferable interface (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Transferable</a>) will automatically be transferred this way (support Firefox &amp; Chrome).</p>
<p>For example, typed arrays like <code>Uint8Array</code> (see the <em>ES6 &amp; Beyond</em> title of this series) are “Transferables.” This is how you’d send a Transferable Object using <code>postMessage(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `foo` is a `Uint8Array` for instance</span></span><br><span class="line"></span><br><span class="line">postMessage( foo.buffer, [ foo.buffer ] );</span><br></pre></td></tr></table></figure>
<p>The first parameter is the raw buffer and the second parameter is a list of what to transfer.</p>
<p>Browsers that don’t support Transferable Objects simply degrade to structured cloning, which means performance reduction rather than outright feature breakage.</p>
<h3 id="Shared-Workers"><a href="#Shared-Workers" class="headerlink" title="Shared Workers"></a>Shared Workers</h3><p>If your site or app allows for loading multiple tabs of the same page (a common feature), you may very well want to reduce the resource usage of their system by preventing duplicate dedicated Workers; the most common limited resource in this respect is a socket network connection, as browsers limit the number of simultaneous connections to a single host. Of course, limiting multiple connections from a client also eases your server resource requirements.</p>
<p>In this case, creating a single centralized Worker that all the page instances of your site or app can <em>share</em> is quite useful.</p>
<p>That’s called a <code>SharedWorker</code>, which you create like so (support for this is limited to Firefox and Chrome):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w1 = <span class="keyword">new</span> SharedWorker( <span class="string">"http://some.url.1/mycoolworker.js"</span> );</span><br></pre></td></tr></table></figure>
<p>Because a shared Worker can be connected to or from more than one program instance or page on your site, the Worker needs a way to know which program a message comes from. This unique identification is called a “port” – think network socket ports. So the calling program must use the <code>port</code> object of the Worker for communication:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w1.port.addEventListener( <span class="string">"message"</span>, handleMessages );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">w1.port.postMessage( <span class="string">"something cool"</span> );</span><br></pre></td></tr></table></figure>
<p>Also, the port connection must be initialized, as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1.port.start();</span><br></pre></td></tr></table></figure>
<p>Inside the shared Worker, an extra event must be handled: <code>&quot;connect&quot;</code>. This event provides the port <code>object</code> for that particular connection. The most convenient way to keep multiple connections separate is to use closure (see <em>Scope &amp; Closures</em> title of this series) over the <code>port</code>, as shown next, with the event listening and transmitting for that connection defined inside the handler for the <code>&quot;connect&quot;</code> event:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside the shared Worker</span></span><br><span class="line">addEventListener( <span class="string">"connect"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// the assigned port for this connection</span></span><br><span class="line">	<span class="keyword">var</span> port = evt.ports[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	port.addEventListener( <span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">		port.postMessage( .. );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ..</span></span><br><span class="line">	&#125; );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// initialize the port connection</span></span><br><span class="line">	port.start();</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Other than that difference, shared and dedicated Workers have the same capabilities and semantics.</p>
<p><strong>Note:</strong> Shared Workers survive the termination of a port connection if other port connections are still alive, whereas dedicated Workers are terminated whenever the connection to their initiating program is terminated.</p>
<h3 id="Polyfilling-Web-Workers"><a href="#Polyfilling-Web-Workers" class="headerlink" title="Polyfilling Web Workers"></a>Polyfilling Web Workers</h3><p>Web Workers are very attractive performance-wise for running JS programs in parallel. However, you may be in a position where your code needs to run in older browsers that lack support. Because Workers are an API and not a syntax, they can be polyfilled, to an extent.</p>
<p>If a browser doesn’t support Workers, there’s simply no way to fake multithreading from the performance perspective. Iframes are commonly thought of to provide a parallel environment, but in all modern browsers they actually run on the same thread as the main page, so they’re not sufficient for faking parallelism.</p>
<p>As we detailed in Chapter 1, JS’s asynchronicity (not parallelism) comes from the event loop queue, so you can force faked Workers to be asynchronous using timers (<code>setTimeout(..)</code>, etc.). Then you just need to provide a polyfill for the Worker API. There are some listed here (<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers)" target="_blank" rel="noopener">https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers)</a>, but frankly none of them look great.</p>
<p>I’ve written a sketch of a polyfill for <code>Worker</code> here (<a href="https://gist.github.com/getify/1b26accb1a09aa53ad25)" target="_blank" rel="noopener">https://gist.github.com/getify/1b26accb1a09aa53ad25)</a>. It’s basic, but it should get the job done for simple <code>Worker</code> support, given that the two-way messaging works correctly as well as <code>&quot;onerror&quot;</code> handling. You could probably also extend it with more features, such as <code>terminate()</code> or faked Shared Workers, as you see fit.</p>
<p><strong>Note:</strong> You can’t fake synchronous blocking, so this polyfill just disallows use of <code>importScripts(..)</code>. Another option might have been to parse and transform the Worker’s code (once Ajax loaded) to handle rewriting to some asynchronous form of an <code>importScripts(..)</code> polyfill, perhaps with a promise-aware interface.</p>
<h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><p>Single instruction, multiple data (SIMD) is a form of “data parallelism,” as contrasted to “task parallelism” with Web Workers, because the emphasis is not really on program logic chunks being parallelized, but rather multiple bits of data being processed in parallel.</p>
<p>With SIMD, threads don’t provide the parallelism. Instead, modern CPUs provide SIMD capability with “vectors” of numbers – think: type specialized arrays – as well as instructions that can operate in parallel across all the numbers; these are low-level operations leveraging instruction-level parallelism.</p>
<p>The effort to expose SIMD capability to JavaScript is primarily spearheaded by Intel (<a href="https://01.org/node/1495)" target="_blank" rel="noopener">https://01.org/node/1495)</a>, namely by Mohammad Haghighat (at the time of this writing), in cooperation with Firefox and Chrome teams. SIMD is on an early standards track with a good chance of making it into a future revision of JavaScript, likely in the ES7 timeframe.</p>
<p>SIMD JavaScript proposes to expose short vector types and APIs to JS code, which on those SIMD-enabled systems would map the operations directly through to the CPU equivalents, with fallback to non-parallelized operation “shims” on non-SIMD systems.</p>
<p>The performance benefits for data-intensive applications (signal analysis, matrix operations on graphics, etc.) with such parallel math processing are quite obvious!</p>
<p>Early proposal forms of the SIMD API at the time of this writing look like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = SIMD.float32x4( <span class="number">3.14159</span>, <span class="number">21.0</span>, <span class="number">32.3</span>, <span class="number">55.55</span> );</span><br><span class="line"><span class="keyword">var</span> v2 = SIMD.float32x4( <span class="number">2.1</span>, <span class="number">3.2</span>, <span class="number">4.3</span>, <span class="number">5.4</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v3 = SIMD.int32x4( <span class="number">10</span>, <span class="number">101</span>, <span class="number">1001</span>, <span class="number">10001</span> );</span><br><span class="line"><span class="keyword">var</span> v4 = SIMD.int32x4( <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> );</span><br><span class="line"></span><br><span class="line">SIMD.float32x4.mul( v1, v2 );	<span class="comment">// [ 6.597339, 67.2, 138.89, 299.97 ]</span></span><br><span class="line">SIMD.int32x4.add( v3, v4 );		<span class="comment">// [ 20, 121, 1031, 10041 ]</span></span><br></pre></td></tr></table></figure>
<p>Shown here are two different vector data types, 32-bit floating-point numbers and 32-bit integer numbers. You can see that these vectors are sized exactly to four 32-bit elements, as this matches the SIMD vector sizes (128-bit) available in most modern CPUs. It’s also possible we may see an <code>x8</code> (or larger!) version of these APIs in the future.</p>
<p>Besides <code>mul()</code> and <code>add()</code>, many other operations are likely to be included, such as <code>sub()</code>, <code>div()</code>, <code>abs()</code>, <code>neg()</code>, <code>sqrt()</code>, <code>reciprocal()</code>, <code>reciprocalSqrt()</code> (arithmetic), <code>shuffle()</code> (rearrange vector elements), <code>and()</code>, <code>or()</code>, <code>xor()</code>, <code>not()</code> (logical), <code>equal()</code>, <code>greaterThan()</code>, <code>lessThan()</code> (comparison), <code>shiftLeft()</code>, <code>shiftRightLogical()</code>, <code>shiftRightArithmetic()</code> (shifts), <code>fromFloat32x4()</code>, and <code>fromInt32x4()</code> (conversions).</p>
<p><strong>Note:</strong> There’s an official “prollyfill” (hopeful, expectant, future-leaning polyfill) for the SIMD functionality available (<a href="https://github.com/johnmccutchan/ecmascript_simd)" target="_blank" rel="noopener">https://github.com/johnmccutchan/ecmascript_simd)</a>, which illustrates a lot more of the planned SIMD capability than we’ve illustrated in this section.</p>
<h2 id="asm-js"><a href="#asm-js" class="headerlink" title="asm.js"></a>asm.js</h2><p>“asm.js” (<a href="http://asmjs.org/" target="_blank" rel="noopener">http://asmjs.org/</a>) is a label for a highly optimizable subset of the JavaScript language. By carefully avoiding certain mechanisms and patterns that are <em>hard</em> to optimize (garbage collection, coercion, etc.), asm.js-styled code can be recognized by the JS engine and given special attention with aggressive low-level optimizations.</p>
<p>Distinct from other program performance mechanisms discussed in this chapter, asm.js isn’t necessarily something that needs to be adopted into the JS language specification. There <em>is</em> an asm.js specification (<a href="http://asmjs.org/spec/latest/)" target="_blank" rel="noopener">http://asmjs.org/spec/latest/)</a>, but it’s mostly for tracking an agreed upon set of candidate inferences for optimization rather than a set of requirements of JS engines.</p>
<p>There’s not currently any new syntax being proposed. Instead, asm.js suggests ways to recognize existing standard JS syntax that conforms to the rules of asm.js and let engines implement their own optimizations accordingly.</p>
<p>There’s been some disagreement between browser vendors over exactly how asm.js should be activated in a program. Early versions of the asm.js experiment required a <code>&quot;use asm&quot;;</code> pragma (similar to strict mode’s <code>&quot;use strict&quot;;</code>) to help clue the JS engine to be looking for asm.js optimization opportunities and hints. Others have asserted that asm.js should just be a set of heuristics that engines automatically recognize without the author having to do anything extra, meaning that existing programs could theoretically benefit from asm.js-style optimizations without doing anything special.</p>
<h3 id="How-to-Optimize-with-asm-js"><a href="#How-to-Optimize-with-asm-js" class="headerlink" title="How to Optimize with asm.js"></a>How to Optimize with asm.js</h3><p>The first thing to understand about asm.js optimizations is around types and coercion (see the <em>Types &amp; Grammar</em> title of this series). If the JS engine has to track multiple different types of values in a variable through various operations, so that it can handle coercions between types as necessary, that’s a lot of extra work that keeps the program optimization suboptimal.</p>
<p><strong>Note:</strong> We’re going to use asm.js-style code here for illustration purposes, but be aware that it’s not commonly expected that you’ll author such code by hand. asm.js is more intended to a compilation target from other tools, such as Emscripten (<a href="https://github.com/kripken/emscripten/wiki)" target="_blank" rel="noopener">https://github.com/kripken/emscripten/wiki)</a>. It’s of course possible to write your own asm.js code, but that’s usually a bad idea because the code is very low level and managing it can be very time consuming and error prone. Nevertheless, there may be cases where you’d want to hand tweak your code for asm.js optimization purposes.</p>
<p>There are some “tricks” you can use to hint to an asm.js-aware JS engine what the intended type is for variables/operations, so that it can skip these coercion tracking steps.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a;</span><br></pre></td></tr></table></figure>
<p>In that program, the <code>b = a</code> assignment leaves the door open for type divergence in variables. However, it could instead be written as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a | <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>Here, we’ve used the <code>|</code> (“binary OR”) with value <code>0</code>, which has no effect on the value other than to make sure it’s a 32-bit integer. That code run in a normal JS engine works just fine, but when run in an asm.js-aware JS engine it <em>can</em> signal that <code>b</code> should always be treated as a 32-bit integer, so the coercion tracking can be skipped.</p>
<p>Similarly, the addition operation between two variables can be restricted to a more performant integer addition (instead of floating point):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a + b) | <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Again, the asm.js-aware JS engine can see that hint and infer that the <code>+</code> operation should be 32-bit integer addition because the end result of the whole expression would automatically be 32-bit integer conformed anyway.</p>
<h3 id="asm-js-Modules"><a href="#asm-js-Modules" class="headerlink" title="asm.js Modules"></a>asm.js Modules</h3><p>One of the biggest detractors to performance in JS is around memory allocation, garbage collection, and scope access. asm.js suggests one of the ways around these issues is to declare a more formalized asm.js “module” – do not confuse these with ES6 modules; see the <em>ES6 &amp; Beyond</em> title of this series.</p>
<p>For an asm.js module, you need to explicitly pass in a tightly conformed namespace – this is referred to in the spec as <code>stdlib</code>, as it should represent standard libraries needed – to import necessary symbols, rather than just using globals via lexical scope. In the base case, the <code>window</code> object is an acceptable <code>stdlib</code> object for asm.js module purposes, but you could and perhaps should construct an even more restricted one.</p>
<p>You also must declare a “heap” – which is just a fancy term for a reserved spot in memory where variables can already be used without asking for more memory or releasing previously used memory – and pass that in, so that the asm.js module won’t need to do anything that would cause memory churn; it can just use the pre-reserved space.</p>
<p>A “heap” is likely a typed <code>ArrayBuffer</code>, such as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> heap = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>( <span class="number">0x10000</span> );	<span class="comment">// 64k heap</span></span><br></pre></td></tr></table></figure>
<p>Using that pre-reserved 64k of binary space, an asm.js module can store and retrieve values in that buffer without any memory allocation or garbage collection penalties. For example, the <code>heap</code> buffer could be used inside the module to back an array of 64-bit float values like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Float64Array</span>( heap );</span><br></pre></td></tr></table></figure>
<p>OK, so let’s make a quick, silly example of an asm.js-styled module to illustrate how these pieces fit together. We’ll define a <code>foo(..)</code> that takes a start (<code>x</code>) and end (<code>y</code>) integer for a range, and calculates all the inner adjacent multiplications of the values in the range, and then finally averages those values together:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooASM</span>(<span class="params">stdlib,foreign,heap</span>) </span>&#123;</span><br><span class="line"><span class="meta">	"use asm"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> arr = <span class="keyword">new</span> stdlib.Int32Array( heap );</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">		x = x | <span class="number">0</span>;</span><br><span class="line">		y = y | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">var</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">var</span> count = ((y|<span class="number">0</span>) - (x|<span class="number">0</span>)) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// calculate all the inner adjacent multiplications</span></span><br><span class="line">		<span class="keyword">for</span> (i = x | <span class="number">0</span>;</span><br><span class="line">			(i | <span class="number">0</span>) &lt; (y | <span class="number">0</span>);</span><br><span class="line">			p = (p + <span class="number">8</span>) | <span class="number">0</span>, i = (i + <span class="number">1</span>) | <span class="number">0</span></span><br><span class="line">		) &#123;</span><br><span class="line">			<span class="comment">// store result</span></span><br><span class="line">			arr[ p &gt;&gt; <span class="number">3</span> ] = (i * (i + <span class="number">1</span>)) | <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// calculate average of all intermediate values</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">			(i | <span class="number">0</span>) &lt; (count | <span class="number">0</span>);</span><br><span class="line">			p = (p + <span class="number">8</span>) | <span class="number">0</span>, i = (i + <span class="number">1</span>) | <span class="number">0</span></span><br><span class="line">		) &#123;</span><br><span class="line">			sum = (sum + arr[ p &gt;&gt; <span class="number">3</span> ]) | <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> +(sum / count);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		foo: foo</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heap = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>( <span class="number">0x1000</span> );</span><br><span class="line"><span class="keyword">var</span> foo = fooASM( <span class="built_in">window</span>, <span class="literal">null</span>, heap ).foo;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">10</span>, <span class="number">20</span> );		<span class="comment">// 233</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> This asm.js example is hand authored for illustration purposes, so it doesn’t represent the same code that would be produced from a compilation tool targeting asm.js. But it does show the typical nature of asm.js code, especially the type hinting and use of the <code>heap</code> buffer for temporary variable storage.</p>
<p>The first call to <code>fooASM(..)</code> is what sets up our asm.js module with its <code>heap</code> allocation. The result is a <code>foo(..)</code> function we can call as many times as necessary. Those <code>foo(..)</code> calls should be specially optimized by an asm.js-aware JS engine. Importantly, the preceding code is completely standard JS and would run just fine (without special optimization) in a non-asm.js engine.</p>
<p>Obviously, the nature of restrictions that make asm.js code so optimizable reduces the possible uses for such code significantly. asm.js won’t necessarily be a general optimization set for any given JS program. Instead, it’s intended to provide an optimized way of handling specialized tasks such as intensive math operations (e.g., those used in graphics processing for games).</p>
<h2 id="Review-4"><a href="#Review-4" class="headerlink" title="Review"></a>Review</h2><p>The first four chapters of this book are based on the premise that async coding patterns give you the ability to write more performant code, which is generally a very important improvement. But async behavior only gets you so far, because it’s still fundamentally bound to a single event loop thread.</p>
<p>So in this chapter we’ve covered several program-level mechanisms for improving performance even further.</p>
<p>Web Workers let you run a JS file (aka program) in a separate thread using async events to message between the threads. They’re wonderful for offloading long-running or resource-intensive tasks to a different thread, leaving the main UI thread more responsive.</p>
<p>SIMD proposes to map CPU-level parallel math operations to JavaScript APIs for high-performance data-parallel operations, like number processing on large data sets.</p>
<p>Finally, asm.js describes a small subset of JavaScript that avoids the hard-to-optimize parts of JS (like garbage collection and coercion) and lets the JS engine recognize and run such code through aggressive optimizations. asm.js could be hand authored, but that’s extremely tedious and error prone, akin to hand authoring assembly language (hence the name). Instead, the main intent is that asm.js would be a good target for cross-compilation from other highly optimized program languages – for example, Emscripten (<a href="https://github.com/kripken/emscripten/wiki" target="_blank" rel="noopener">https://github.com/kripken/emscripten/wiki</a>) transpiling C/C++ to JavaScript.</p>
<p>While not covered explicitly in this chapter, there are even more radical ideas under very early discussion for JavaScript, including approximations of direct threaded functionality (not just hidden behind data structure APIs). Whether that happens explicitly, or we just see more parallelism creep into JS behind the scenes, the future of more optimized program-level performance in JS looks really <em>promising</em>.</p>
<h1 id="Chapter-6-Benchmarking-amp-Tuning"><a href="#Chapter-6-Benchmarking-amp-Tuning" class="headerlink" title="Chapter 6: Benchmarking &amp; Tuning"></a>Chapter 6: Benchmarking &amp; Tuning</h1><p>As the first four chapters of this book were all about performance as a coding pattern (asynchrony and concurrency), and Chapter 5 was about performance at the macro program architecture level, this chapter goes after the topic of performance at the micro level, focusing on single expressions/statements.</p>
<p>One of the most common areas of curiosity – indeed, some developers can get quite obsessed about it – is in analyzing and testing various options for how to write a line or chunk of code, and which one is faster.</p>
<p>We’re going to look at some of these issues, but it’s important to understand from the outset that this chapter is <strong>not</strong> about feeding the obsession of micro-performance tuning, like whether some given JS engine can run <code>++a</code> faster than <code>a++</code>. The more important goal of this chapter is to figure out what kinds of JS performance matter and which ones don’t, <em>and how to tell the difference</em>.</p>
<p>But even before we get there, we need to explore how to most accurately and reliably test JS performance, because there’s tons of misconceptions and myths that have flooded our collective cult knowledge base. We’ve got to sift through all that junk to find some clarity.</p>
<h2 id="Benchmarking"><a href="#Benchmarking" class="headerlink" title="Benchmarking"></a>Benchmarking</h2><p>OK, time to start dispelling some misconceptions. I’d wager the vast majority of JS developers, if asked to benchmark the speed (execution time) of a certain operation, would initially go about it something like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();	<span class="comment">// or `Date.now()`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do some operation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> end = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"Duration:"</span>, (end - start) );</span><br></pre></td></tr></table></figure>
<p>Raise your hand if that’s roughly what came to your mind. Yep, I thought so. There’s a lot wrong with this approach, but don’t feel bad; <strong>we’ve all been there.</strong></p>
<p>What did that measurement tell you, exactly? Understanding what it does and doesn’t say about the execution time of the operation in question is key to learning how to appropriately benchmark performance in JavaScript.</p>
<p>If the duration reported is <code>0</code>, you may be tempted to believe that it took less than a millisecond. But that’s not very accurate. Some platforms don’t have single millisecond precision, but instead only update the timer in larger increments. For example, older versions of windows (and thus IE) had only 15ms precision, which means the operation has to take at least that long for anything other than <code>0</code> to be reported!</p>
<p>Moreover, whatever duration is reported, the only thing you really know is that the operation took approximately that long on that exact single run. You have near-zero confidence that it will always run at that speed. You have no idea if the engine or system had some sort of interference at that exact moment, and that at other times the operation could run faster.</p>
<p>What if the duration reported is <code>4</code>? Are you more sure it took about four milliseconds? Nope. It might have taken less time, and there may have been some other delay in getting either <code>start</code> or <code>end</code> timestamps.</p>
<p>More troublingly, you also don’t know that the circumstances of this operation test aren’t overly optimistic. It’s possible that the JS engine figured out a way to optimize your isolated test case, but in a more real program such optimization would be diluted or impossible, such that the operation would run slower than your test.</p>
<p>So… what do we know? Unfortunately, with those realizations stated, <strong>we know very little.</strong> Something of such low confidence isn’t even remotely good enough to build your determinations on. Your “benchmark” is basically useless. And worse, it’s dangerous in that it implies false confidence, not just to you but also to others who don’t think critically about the conditions that led to those results.</p>
<h3 id="Repetition"><a href="#Repetition" class="headerlink" title="Repetition"></a>Repetition</h3><p>“OK,” you now say, “Just put a loop around it so the whole test takes longer.” If you repeat an operation 100 times, and that whole loop reportedly takes a total of 137ms, then you can just divide by 100 and get an average duration of 1.37ms for each operation, right?</p>
<p>Well, not exactly.</p>
<p>A straight mathematical average by itself is definitely not sufficient for making judgments about performance which you plan to extrapolate to the breadth of your entire application. With a hundred iterations, even a couple of outliers (high or low) can skew the average, and then when you apply that conclusion repeatedly, you even further inflate the skew beyond credulity.</p>
<p>Instead of just running for a fixed number of iterations, you can instead choose to run the loop of tests until a certain amount of time has passed. That might be more reliable, but how do you decide how long to run? You might guess that it should be some multiple of how long your operation should take to run once. Wrong.</p>
<p>Actually, the length of time to repeat across should be based on the accuracy of the timer you’re using, specifically to minimize the chances of inaccuracy. The less precise your timer, the longer you need to run to make sure you’ve minimized the error percentage. A 15ms timer is pretty bad for accurate benchmarking; to minimize its uncertainty (aka “error rate”) to less than 1%, you need to run your each cycle of test iterations for 750ms. A 1ms timer only needs a cycle to run for 50ms to get the same confidence.</p>
<p>But then, that’s just a single sample. To be sure you’re factoring out the skew, you’ll want lots of samples to average across. You’ll also want to understand something about just how slow the worst sample is, how fast the best sample is, how far apart those best and worse cases were, and so on. You’ll want to know not just a number that tells you how fast something ran, but also to have some quantifiable measure of how trustable that number is.</p>
<p>Also, you probably want to combine these different techniques (as well as others), so that you get the best balance of all the possible approaches.</p>
<p>That’s all bare minimum just to get started. If you’ve been approaching performance benchmarking with anything less serious than what I just glossed over, well… “you don’t know: proper benchmarking.”</p>
<h3 id="Benchmark-js"><a href="#Benchmark-js" class="headerlink" title="Benchmark.js"></a>Benchmark.js</h3><p>Any relevant and reliable benchmark should be based on statistically sound practices. I am not going to write a chapter on statistics here, so I’ll hand wave around some terms: standard deviation, variance, margin of error. If you don’t know what those terms really mean – I took a stats class back in college and I’m still a little fuzzy on them – you are not actually qualified to write your own benchmarking logic.</p>
<p>Luckily, smart folks like John-David Dalton and Mathias Bynens do understand these concepts, and wrote a statistically sound benchmarking tool called Benchmark.js (<a href="http://benchmarkjs.com/)" target="_blank" rel="noopener">http://benchmarkjs.com/)</a>. So I can end the suspense by simply saying: “just use that tool.”</p>
<p>I won’t repeat their whole documentation for how Benchmark.js works; they have fantastic API Docs (<a href="http://benchmarkjs.com/docs" target="_blank" rel="noopener">http://benchmarkjs.com/docs</a>) you should read. Also there are some great (<a href="http://calendar.perfplanet.com/2010/bulletproof-javascript-benchmarks/" target="_blank" rel="noopener">http://calendar.perfplanet.com/2010/bulletproof-javascript-benchmarks/</a>) writeups (<a href="http://monsur.hossa.in/2012/12/11/benchmarkjs.html" target="_blank" rel="noopener">http://monsur.hossa.in/2012/12/11/benchmarkjs.html</a>) on more of the details and methodology.</p>
<p>But just for quick illustration purposes, here’s how you could use Benchmark.js to run a quick performance test:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// operation(s) to test</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bench = <span class="keyword">new</span> Benchmark(</span><br><span class="line">	<span class="string">"foo test"</span>,				<span class="comment">// test name</span></span><br><span class="line">	foo,					<span class="comment">// function to test (just contents)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// ..				// optional extra options (see docs)</span></span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">bench.hz;					<span class="comment">// number of operations per second</span></span><br><span class="line">bench.stats.moe;			<span class="comment">// margin of error</span></span><br><span class="line">bench.stats.variance;		<span class="comment">// variance across samples</span></span><br><span class="line"><span class="comment">// ..</span></span><br></pre></td></tr></table></figure>
<p>There’s <em>lots</em> more to learn about using Benchmark.js besides this glance I’m including here. But the point is that it’s handling all of the complexities of setting up a fair, reliable, and valid performance benchmark for a given piece of JavaScript code. If you’re going to try to test and benchmark your code, this library is the first place you should turn.</p>
<p>We’re showing here the usage to test a single operation like X, but it’s fairly common that you want to compare X to Y. This is easy to do by simply setting up two different tests in a “Suite” (a Benchmark.js organizational feature). Then, you run them head-to-head, and compare the statistics to conclude whether X or Y was faster.</p>
<p>Benchmark.js can of course be used to test JavaScript in a browser (see the “jsPerf.com” section later in this chapter), but it can also run in non-browser environments (Node.js, etc.).</p>
<p>One largely untapped potential use-case for Benchmark.js is to use it in your Dev or QA environments to run automated performance regression tests against critical path parts of your application’s JavaScript. Similar to how you might run unit test suites before deployment, you can also compare the performance against previous benchmarks to monitor if you are improving or degrading application performance.</p>
<h4 id="Setup-Teardown"><a href="#Setup-Teardown" class="headerlink" title="Setup/Teardown"></a>Setup/Teardown</h4><p>In the previous code snippet, we glossed over the “extra options” <code>{ .. }</code> object. But there are two options we should discuss: <code>setup</code> and <code>teardown</code>.</p>
<p>These two options let you define functions to be called before and after your test case runs.</p>
<p>It’s incredibly important to understand that your <code>setup</code> and <code>teardown</code> code <strong>does not run for each test iteration</strong>. The best way to think about it is that there’s an outer loop (repeating cycles), and an inner loop (repeating test iterations). <code>setup</code> and <code>teardown</code> are run at the beginning and end of each <em>outer</em> loop (aka cycle) iteration, but not inside the inner loop.</p>
<p>Why does this matter? Let’s imagine you have a test case that looks like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = a + <span class="string">"w"</span>;</span><br><span class="line">b = a.charAt( <span class="number">1</span> );</span><br></pre></td></tr></table></figure>
<p>Then, you set up your test <code>setup</code> as follows:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"x"</span>;</span><br></pre></td></tr></table></figure>
<p>Your temptation is probably to believe that <code>a</code> is starting out as <code>&quot;x&quot;</code> for each test iteration.</p>
<p>But it’s not! It’s starting <code>a</code> at <code>&quot;x&quot;</code> for each test cycle, and then your repeated <code>+ &quot;w&quot;</code> concatenations will be making a larger and larger <code>a</code> value, even though you’re only ever accessing the character <code>&quot;w&quot;</code> at the <code>1</code> position.</p>
<p>Where this most commonly bites you is when you make side effect changes to something like the DOM, like appending a child element. You may think your parent element is set as empty each time, but it’s actually getting lots of elements added, and that can significantly sway the results of your tests.</p>
<h2 id="Context-Is-King"><a href="#Context-Is-King" class="headerlink" title="Context Is King"></a>Context Is King</h2><p>Don’t forget to check the context of a particular performance benchmark, especially a comparison between X and Y tasks. Just because your test reveals that X is faster than Y doesn’t mean that the conclusion “X is faster than Y” is actually relevant.</p>
<p>For example, let’s say a performance test reveals that X runs 10,000,000 operations per second, and Y runs at 8,000,000 operations per second. You could claim that Y is 20% slower than X, and you’d be mathematically correct, but your assertion doesn’t hold as much water as you’d think.</p>
<p>Let’s think about the results more critically: 10,000,000 operations per second is 10,000 operations per millisecond, and 10 operations per microsecond. In other words, a single operation takes 0.1 microseconds, or 100 nanoseconds. It’s hard to fathom just how small 100ns is, but for comparison, it’s often cited that the human eye isn’t generally capable of distinguishing anything less than 100ms, which is one million times slower than the 100ns speed of the X operation.</p>
<p>Even recent scientific studies showing that maybe the brain can process as quick as 13ms (about 8x faster than previously asserted) would mean that X is still running 125,000 times faster than the human brain can perceive a distinct thing happening. <strong>X is going really, really fast.</strong></p>
<p>But more importantly, let’s talk about the difference between X and Y, the 2,000,000 operations per second difference. If X takes 100ns, and Y takes 80ns, the difference is 20ns, which in the best case is still one 650-thousandth of the interval the human brain can perceive.</p>
<p>What’s my point? <strong>None of this performance difference matters, at all!</strong></p>
<p>But wait, what if this operation is going to happen a whole bunch of times in a row? Then the difference could add up, right?</p>
<p>OK, so what we’re asking then is, how likely is it that operation X is going to be run over and over again, one right after the other, and that this has to happen 650,000 times just to get a sliver of a hope the human brain could perceive it. More likely, it’d have to happen 5,000,000 to 10,000,000 times together in a tight loop to even approach relevance.</p>
<p>While the computer scientist in you might protest that this is possible, the louder voice of realism in you should sanity check just how likely or unlikely that really is. Even if it is relevant in rare occasions, it’s irrelevant in most situations.</p>
<p>The vast majority of your benchmark results on tiny operations – like the <code>++x</code> vs <code>x++</code> myth – <strong>are just totally bogus</strong> for supporting the conclusion that X should be favored over Y on a performance basis.</p>
<h3 id="Engine-Optimizations"><a href="#Engine-Optimizations" class="headerlink" title="Engine Optimizations"></a>Engine Optimizations</h3><p>You simply cannot reliably extrapolate that if X was 10 microseconds faster than Y in your isolated test, that means X is always faster than Y and should always be used. That’s not how performance works. It’s vastly more complicated.</p>
<p>For example, let’s imagine (purely hypothetical) that you test some microperformance behavior such as comparing:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twelve = <span class="string">"12"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">"foo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test 1</span></span><br><span class="line"><span class="keyword">var</span> X1 = <span class="built_in">parseInt</span>( twelve );</span><br><span class="line"><span class="keyword">var</span> X2 = <span class="built_in">parseInt</span>( foo );</span><br><span class="line"></span><br><span class="line"><span class="comment">// test 2</span></span><br><span class="line"><span class="keyword">var</span> Y1 = <span class="built_in">Number</span>( twelve );</span><br><span class="line"><span class="keyword">var</span> Y2 = <span class="built_in">Number</span>( foo );</span><br></pre></td></tr></table></figure>
<p>If you understand what <code>parseInt(..)</code> does compared to <code>Number(..)</code>, you might intuit that <code>parseInt(..)</code> potentially has “more work” to do, especially in the <code>foo</code> case. Or you might intuit that they should have the same amount of work to do in the <code>foo</code> case, as both should be able to stop at the first character <code>&quot;f&quot;</code>.</p>
<p>Which intuition is correct? I honestly don’t know. But I’ll make the case it doesn’t matter what your intuition is. What might the results be when you test it? Again, I’m making up a pure hypothetical here, I haven’t actually tried, nor do I care.</p>
<p>Let’s pretend the test comes back that <code>X</code> and <code>Y</code> are statistically identical. Have you then confirmed your intuition about the <code>&quot;f&quot;</code> character thing? Nope.</p>
<p>It’s possible in our hypothetical that the engine might recognize that the variables <code>twelve</code> and <code>foo</code> are only being used in one place in each test, and so it might decide to inline those values. Then it may realize that <code>Number( &quot;12&quot; )</code> can just be replaced by <code>12</code>. And maybe it comes to the same conclusion with <code>parseInt(..)</code>, or maybe not.</p>
<p>Or an engine’s dead-code removal heuristic could kick in, and it could realize that variables <code>X</code> and <code>Y</code> aren’t being used, so declaring them is irrelevant, so it doesn’t end up doing anything at all in either test.</p>
<p>And all that’s just made with the mindset of assumptions about a single test run. Modern engines are fantastically more complicated than what we’re intuiting here. They do all sorts of tricks, like tracing and tracking how a piece of code behaves over a short period of time, or with a particularly constrained set of inputs.</p>
<p>What if the engine optimizes a certain way because of the fixed input, but in your real program you give more varied input and the optimization decisions shake out differently (or not at all!)? Or what if the engine kicks in optimizations because it sees the code being run tens of thousands of times by the benchmarking utility, but in your real program it will only run a hundred times in near proximity, and under those conditions the engine determines the optimizations are not worth it?</p>
<p>And all those optimizations we just hypothesized about might happen in our constrained test but maybe the engine wouldn’t do them in a more complex program (for various reasons). Or it could be reversed – the engine might not optimize such trivial code but may be more inclined to optimize it more aggressively when the system is already more taxed by a more sophisticated program.</p>
<p>The point I’m trying to make is that you really don’t know for sure exactly what’s going on under the covers. All the guesses and hypothesis you can muster don’t amount to hardly anything concrete for really making such decisions.</p>
<p>Does that mean you can’t really do any useful testing? <strong>Definitely not!</strong></p>
<p>What this boils down to is that testing <em>not real</em> code gives you <em>not real</em> results. In so much as is possible and practical, you should test actual real, non-trivial snippets of your code, and under as best of real conditions as you can actually hope to. Only then will the results you get have a chance to approximate reality.</p>
<p>Microbenchmarks like <code>++x</code> vs <code>x++</code> are so incredibly likely to be bogus, we might as well just flatly assume them as such.</p>
<h2 id="jsPerf-com"><a href="#jsPerf-com" class="headerlink" title="jsPerf.com"></a>jsPerf.com</h2><p>While Benchmark.js is useful for testing the performance of your code in whatever JS environment you’re running, it cannot be stressed enough that you need to compile test results from lots of different environments (desktop browsers, mobile devices, etc.) if you want to have any hope of reliable test conclusions.</p>
<p>For example, Chrome on a high-end desktop machine is not likely to perform anywhere near the same as Chrome mobile on a smartphone. And a smartphone with a full battery charge is not likely to perform anywhere near the same as a smartphone with 2% battery life left, when the device is starting to power down the radio and processor.</p>
<p>If you want to make assertions like “X is faster than Y” in any reasonable sense across more than just a single environment, you’re going to need to actually test as many of those real world environments as possible. Just because Chrome executes some X operation faster than Y doesn’t mean that all browsers do. And of course you also probably will want to cross-reference the results of multiple browser test runs with the demographics of your users.</p>
<p>There’s an awesome website for this purpose called jsPerf (<a href="http://jsperf.com)" target="_blank" rel="noopener">http://jsperf.com)</a>. It uses the Benchmark.js library we talked about earlier to run statistically accurate and reliable tests, and makes the test on an openly available URL that you can pass around to others.</p>
<p>Each time a test is run, the results are collected and persisted with the test, and the cumulative test results are graphed on the page for anyone to see.</p>
<p>When creating a test on the site, you start out with two test cases to fill in, but you can add as many as you need. You also have the ability to set up <code>setup</code> code that is run at the beginning of each test cycle and <code>teardown</code> code run at the end of each cycle.</p>
<p><strong>Note:</strong> A trick for doing just one test case (if you’re benchmarking a single approach instead of a head-to-head) is to fill in the second test input boxes with placeholder text on first creation, then edit the test and leave the second test blank, which will delete it. You can always add more test cases later.</p>
<p>You can define the initial page setup (importing libraries, defining utility helper functions, declaring variables, etc.). There are also options for defining setup and teardown behavior if needed – consult the “Setup/Teardown” section in the Benchmark.js discussion earlier.</p>
<h3 id="Sanity-Check"><a href="#Sanity-Check" class="headerlink" title="Sanity Check"></a>Sanity Check</h3><p>jsPerf is a fantastic resource, but there’s an awful lot of tests published that when you analyze them are quite flawed or bogus, for any of a variety of reasons as outlined so far in this chapter.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1</span></span><br><span class="line"><span class="keyword">var</span> x = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	x[i] = <span class="string">"x"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2</span></span><br><span class="line"><span class="keyword">var</span> x = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	x[x.length] = <span class="string">"x"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 3</span></span><br><span class="line"><span class="keyword">var</span> x = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	x.push( <span class="string">"x"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Some observations to ponder about this test scenario:</p>
<ul>
<li>It’s extremely common for devs to put their own loops into test cases, and they forget that Benchmark.js already does all the repetition you need. There’s a really strong chance that the <code>for</code> loops in these cases are totally unnecessary noise.</li>
<li><p>The declaring and initializing of <code>x</code> is included in each test case, possibly unnecessarily. Recall from earlier that if <code>x = []</code> were in the <code>setup</code> code, it wouldn’t actually be run before each test iteration, but instead once at the beginning of each cycle. That means <code>x</code> would continue growing quite large, not just the size <code>10</code> implied by the <code>for</code> loops.</p>
<p> So is the intent to make sure the tests are constrained only to how the JS engine behaves with very small arrays (size <code>10</code>)? That <em>could</em> be the intent, but if it is, you have to consider if that’s not focusing far too much on nuanced internal implementation details.</p>
<p> On the other hand, does the intent of the test embrace the context that the arrays will actually be growing quite large? Is the JS engines’ behavior with larger arrays relevant and accurate when compared with the intended real world usage?</p>
</li>
<li><p>Is the intent to find out how much <code>x.length</code> or <code>x.push(..)</code> add to the performance of the operation to append to the <code>x</code> array? OK, that might be a valid thing to test. But then again, <code>push(..)</code> is a function call, so of course it’s going to be slower than <code>[..]</code> access. Arguably, cases 1 and 2 are fairer than case 3.</p>
</li>
</ul>
<p>Here’s another example that illustrates a common apples-to-oranges flaw:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1</span></span><br><span class="line"><span class="keyword">var</span> x = [<span class="string">"John"</span>,<span class="string">"Albert"</span>,<span class="string">"Sue"</span>,<span class="string">"Frank"</span>,<span class="string">"Bob"</span>];</span><br><span class="line">x.sort();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2</span></span><br><span class="line"><span class="keyword">var</span> x = [<span class="string">"John"</span>,<span class="string">"Albert"</span>,<span class="string">"Sue"</span>,<span class="string">"Frank"</span>,<span class="string">"Bob"</span>];</span><br><span class="line">x.sort( <span class="function"><span class="keyword">function</span> <span class="title">mySort</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Here, the obvious intent is to find out how much slower the custom <code>mySort(..)</code> comparator is than the built-in default comparator. But by specifying the function <code>mySort(..)</code> as inline function expression, you’ve created an unfair/bogus test. Here, the second case is not only testing a custom user JS function, <strong>but it’s also testing creating a new function expression for each iteration.</strong></p>
<p>Would it surprise you to find out that if you run a similar test but update it to isolate only for creating an inline function expression versus using a pre-declared function, the inline function expression creation can be from 2% to 20% slower!?</p>
<p>Unless your intent with this test <em>is</em> to consider the inline function expression creation “cost,” a better/fairer test would put <code>mySort(..)</code>‘s declaration in the page setup – don’t put it in the test <code>setup</code> as that’s unnecessary redeclaration for each cycle – and simply reference it by name in the test case: <code>x.sort(mySort)</code>.</p>
<p>Building on the previous example, another pitfall is in opaquely avoiding or adding “extra work” to one test case that creates an apples-to-oranges scenario:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1</span></span><br><span class="line"><span class="keyword">var</span> x = [<span class="number">12</span>,<span class="number">-14</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">18</span>,<span class="number">0</span>,<span class="number">2.9</span>];</span><br><span class="line">x.sort();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2</span></span><br><span class="line"><span class="keyword">var</span> x = [<span class="number">12</span>,<span class="number">-14</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">18</span>,<span class="number">0</span>,<span class="number">2.9</span>];</span><br><span class="line">x.sort( <span class="function"><span class="keyword">function</span> <span class="title">mySort</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Setting aside the previously mentioned inline function expression pitfall, the second case’s <code>mySort(..)</code> works in this case because you have provided it numbers, but would have of course failed with strings. The first case doesn’t throw an error, but it actually behaves differently and has a different outcome! It should be obvious, but: <strong>a different outcome between two test cases almost certainly invalidates the entire test!</strong></p>
<p>But beyond the different outcomes, in this case, the built in <code>sort(..)</code>‘s comparator is actually doing “extra work” that <code>mySort()</code> does not, in that the built-in one coerces the compared values to strings and does lexicographic comparison. The first snippet results in <code>[-14, 0, 0, 12, 18, 2.9, 3]</code> while the second snippet results (likely more accurately based on intent) in <code>[-14, 0, 0, 2.9, 3, 12, 18]</code>.</p>
<p>So that test is unfair because it’s not actually doing the same task between the cases. Any results you get are bogus.</p>
<p>These same pitfalls can even be much more subtle:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> y = x ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">var</span> y = x ? <span class="number">1</span> : <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>Here, the intent might be to test the performance impact of the coercion to a Boolean that the <code>? :</code> operator will do if the <code>x</code> expression is not already a Boolean (see the <em>Types &amp; Grammar</em> title of this book series). So, you’re apparently OK with the fact that there is extra work to do the coercion in the second case.</p>
<p>The subtle problem? You’re setting <code>x</code>‘s value in the first case and not setting it in the other, so you’re actually doing work in the first case that you’re not doing in the second. To eliminate any potential (albeit minor) skew, try:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> y = x ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case 2</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> y = x ? <span class="number">1</span> : <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>Now there’s an assignment in both cases, so the thing you want to test – the coercion of <code>x</code> or not – has likely been more accurately isolated and tested.</p>
<h2 id="Writing-Good-Tests"><a href="#Writing-Good-Tests" class="headerlink" title="Writing Good Tests"></a>Writing Good Tests</h2><p>Let me see if I can articulate the bigger point I’m trying to make here.</p>
<p>Good test authoring requires careful analytical thinking about what differences exist between two test cases and whether the differences between them are <em>intentional</em> or <em>unintentional</em>.</p>
<p>Intentional differences are of course normal and OK, but it’s too easy to create unintentional differences that skew your results. You have to be really, really careful to avoid that skew. Moreover, you may intend a difference but it may not be obvious to other readers of your test what your intent was, so they may doubt (or trust!) your test incorrectly. How do you fix that?</p>
<p><strong>Write better, clearer tests.</strong> But also, take the time to document (using the jsPerf.com “Description” field and/or code comments) exactly what the intent of your test is, even to the nuanced detail. Call out the intentional differences, which will help others and your future self to better identify unintentional differences that could be skewing the test results.</p>
<p>Isolate things which aren’t relevant to your test by pre-declaring them in the page or test setup settings so they’re outside the timed parts of the test.</p>
<p>Instead of trying to narrow in on a tiny snippet of your real code and benchmarking just that piece out of context, tests and benchmarks are better when they include a larger (while still relevant) context. Those tests also tend to run slower, which means any differences you spot are more relevant in context.</p>
<h2 id="Microperformance"><a href="#Microperformance" class="headerlink" title="Microperformance"></a>Microperformance</h2><p>OK, until now we’ve been dancing around various microperformance issues and generally looking disfavorably upon obsessing about them. I want to take just a moment to address them directly.</p>
<p>The first thing you need to get more comfortable with when thinking about performance benchmarking your code is that the code you write is not always the code the engine actually runs. We briefly looked at that topic back in Chapter 1 when we discussed statement reordering by the compiler, but here we’re going to suggest the compiler can sometimes decide to run different code than you wrote, not just in different orders but different in substance.</p>
<p>Let’s consider this piece of code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">41</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		(<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> bar = foo + baz;</span><br><span class="line">			<span class="comment">// ..</span></span><br><span class="line">		&#125;)(<span class="number">1</span>);</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>You may think about the <code>foo</code> reference in the innermost function as needing to do a three-level scope lookup. We covered in the <em>Scope &amp; Closures</em> title of this book series how lexical scope works, and the fact that the compiler generally caches such lookups so that referencing <code>foo</code> from different scopes doesn’t really practically “cost” anything extra.</p>
<p>But there’s something deeper to consider. What if the compiler realizes that <code>foo</code> isn’t referenced anywhere else but that one location, and it further notices that the value never is anything except the <code>41</code> as shown?</p>
<p>Isn’t it quite possible and acceptable that the JS compiler could decide to just remove the <code>foo</code> variable entirely, and <em>inline</em> the value, such as this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		(<span class="function"><span class="keyword">function</span>(<span class="params">baz</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> bar = <span class="number">41</span> + baz;</span><br><span class="line">			<span class="comment">// ..</span></span><br><span class="line">		&#125;)(<span class="number">1</span>);</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Of course, the compiler could probably also do a similar analysis and rewrite with the <code>baz</code> variable here, too.</p>
<p>When you begin to think about your JS code as being a hint or suggestion to the engine of what to do, rather than a literal requirement, you realize that a lot of the obsession over discrete syntactic minutia is most likely unfounded.</p>
<p>Another example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n * factorial( n - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial( <span class="number">5</span> );		<span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>Ah, the good ol’ fashioned “factorial” algorithm! You might assume that the JS engine will run that code mostly as is. And to be honest, it might – I’m not really sure.</p>
<p>But as an anecdote, the same code expressed in C and compiled with advanced optimizations would result in the compiler realizing that the call <code>factorial(5)</code> can just be replaced with the constant value <code>120</code>, eliminating the function and call entirely!</p>
<p>Moreover, some engines have a practice called “unrolling recursion,” where it can realize that the recursion you’ve expressed can actually be done “easier” (i.e., more optimally) with a loop. It’s possible the preceding code could be <em>rewritten</em> by a JS engine to run as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=n; i&gt;<span class="number">1</span>; i--) &#123;</span><br><span class="line">		res *= i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial( <span class="number">5</span> );		<span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>Now, let’s imagine that in the earlier snippet you had been worried about whether <code>n * factorial(n-1)</code> or <code>n *= factorial(--n)</code> runs faster. Maybe you even did a performance benchmark to try to figure out which was better. But you miss the fact that in the bigger context, the engine may not run either line of code because it may unroll the recursion!</p>
<p>Speaking of <code>--</code>, <code>--n</code> versus <code>n--</code> is often cited as one of those places where you can optimize by choosing the <code>--n</code> version, because theoretically it requires less effort down at the assembly level of processing.</p>
<p>That sort of obsession is basically nonsense in modern JavaScript. That’s the kind of thing you should be letting the engine take care of. You should write the code that makes the most sense. Compare these three <code>for</code> loops:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">-1</span>; ++i&lt;<span class="number">10</span>; ) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Even if you have some theory where the second or third option is more performant than the first option by a tiny bit, which is dubious at best, the third loop is more confusing because you have to start with <code>-1</code> for <code>i</code> to account for the fact that <code>++i</code> pre-increment is used. And the difference between the first and second options is really quite irrelevant.</p>
<p>It’s entirely possible that a JS engine may see a place where <code>i++</code> is used and realize that it can safely replace it with the <code>++i</code> equivalent, which means your time spent deciding which one to pick was completely wasted and the outcome moot.</p>
<p>Here’s another common example of silly microperformance obsession:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [ .. ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len = x.length; i &lt; len; i++) &#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The theory here goes that you should cache the length of the <code>x</code> array in the variable <code>len</code>, because ostensibly it doesn’t change, to avoid paying the price of <code>x.length</code> being consulted for each iteration of the loop.</p>
<p>If you run performance benchmarks around <code>x.length</code> usage compared to caching it in a <code>len</code> variable, you’ll find that while the theory sounds nice, in practice any measured differences are statistically completely irrelevant.</p>
<p>In fact, in some engines like v8, it can be shown (<a href="http://mrale.ph/blog/2014/12/24/array-length-caching.html" target="_blank" rel="noopener">http://mrale.ph/blog/2014/12/24/array-length-caching.html</a>) that you could make things slightly worse by pre-caching the length instead of letting the engine figure it out for you. Don’t try to outsmart your JavaScript engine, you’ll probably lose when it comes to performance optimizations.</p>
<h3 id="Not-All-Engines-Are-Alike"><a href="#Not-All-Engines-Are-Alike" class="headerlink" title="Not All Engines Are Alike"></a>Not All Engines Are Alike</h3><p>The different JS engines in various browsers can all be “spec compliant” while having radically different ways of handling code. The JS specification doesn’t require anything performance related – well, except ES6’s “Tail Call Optimization” covered later in this chapter.</p>
<p>The engines are free to decide that one operation will receive its attention to optimize, perhaps trading off for lesser performance on another operation. It can be very tenuous to find an approach for an operation that always runs faster in all browsers.</p>
<p>There’s a movement among some in the JS dev community, especially those who work with Node.js, to analyze the specific internal implementation details of the v8 JavaScript engine and make decisions about writing JS code that is tailored to take best advantage of how v8 works. You can actually achieve a surprisingly high degree of performance optimization with such endeavors, so the payoff for the effort can be quite high.</p>
<p>Some commonly cited examples (<a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="noopener">https://github.com/petkaantonov/bluebird/wiki/Optimization-killers</a>) for v8:</p>
<ul>
<li>Don’t pass the <code>arguments</code> variable from one function to any other function, as such “leakage” slows down the function implementation.</li>
<li>Isolate a <code>try..catch</code> in its own function. Browsers struggle with optimizing any function with a <code>try..catch</code> in it, so moving that construct to its own function means you contain the de-optimization harm while letting the surrounding code be optimizable.</li>
</ul>
<p>But rather than focus on those tips specifically, let’s sanity check the v8-only optimization approach in a general sense.</p>
<p>Are you genuinely writing code that only needs to run in one JS engine? Even if your code is entirely intended for Node.js <em>right now</em>, is the assumption that v8 will <em>always</em> be the used JS engine reliable? Is it possible that someday a few years from now, there’s another server-side JS platform besides Node.js that you choose to run your code on? What if what you optimized for before is now a much slower way of doing that operation on the new engine?</p>
<p>Or what if your code always stays running on v8 from here on out, but v8 decides at some point to change the way some set of operations works such that what used to be fast is now slow, and vice versa?</p>
<p>These scenarios aren’t just theoretical, either. It used to be that it was faster to put multiple string values into an array and then call <code>join(&quot;&quot;)</code> on the array to concatenate the values than to just use <code>+</code> concatenation directly with the values. The historical reason for this is nuanced, but it has to do with internal implementation details about how string values were stored and managed in memory.</p>
<p>As a result, “best practice” advice at the time disseminated across the industry suggesting developers always use the array <code>join(..)</code> approach. And many followed.</p>
<p>Except, somewhere along the way, the JS engines changed approaches for internally managing strings, and specifically put in optimizations for <code>+</code> concatenation. They didn’t slow down <code>join(..)</code> per se, but they put more effort into helping <code>+</code> usage, as it was still quite a bit more widespread.</p>
<p><strong>Note:</strong> The practice of standardizing or optimizing some particular approach based mostly on its existing widespread usage is often called (metaphorically) “paving the cowpath.”</p>
<p>Once that new approach to handling strings and concatenation took hold, unfortunately all the code out in the wild that was using array <code>join(..)</code> to concatenate strings was then sub-optimal.</p>
<p>Another example: at one time, the Opera browser differed from other browsers in how it handled the boxing/unboxing of primitive wrapper objects (see the <em>Types &amp; Grammar</em> title of this book series). As such, their advice to developers was to use a <code>String</code> object instead of the primitive <code>string</code> value if properties like <code>length</code> or methods like <code>charAt(..)</code> needed to be accessed. This advice may have been correct for Opera at the time, but it was literally completely opposite for other major contemporary browsers, as they had optimizations specifically for the <code>string</code> primitives and not their object wrapper counterparts.</p>
<p>I think these various gotchas are at least possible, if not likely, for code even today. So I’m very cautious about making wide ranging performance optimizations in my JS code based purely on engine implementation details, <strong>especially if those details are only true of a single engine</strong>.</p>
<p>The reverse is also something to be wary of: you shouldn’t necessarily change a piece of code to work around one engine’s difficulty with running a piece of code in an acceptably performant way.</p>
<p>Historically, IE has been the brunt of many such frustrations, given that there have been plenty of scenarios in older IE versions where it struggled with some performance aspect that other major browsers of the time seemed not to have much trouble with. The string concatenation discussion we just had was actually a real concern back in the IE6 and IE7 days, where it was possible to get better performance out of <code>join(..)</code> than <code>+</code>.</p>
<p>But it’s troublesome to suggest that just one browser’s trouble with performance is justification for using a code approach that quite possibly could be sub-optimal in all other browsers. Even if the browser in question has a large market share for your site’s audience, it may be more practical to write the proper code and rely on the browser to update itself with better optimizations eventually.</p>
<p>“There is nothing more permanent than a temporary hack.” Chances are, the code you write now to work around some performance bug will probably outlive the performance bug in the browser itself.</p>
<p>In the days when a browser only updated once every five years, that was a tougher call to make. But as it stands now, browsers across the board are updating at a much more rapid interval (though obviously the mobile world still lags), and they’re all competing to optimize web features better and better.</p>
<p>If you run across a case where a browser <em>does</em> have a performance wart that others don’t suffer from, make sure to report it to them through whatever means you have available. Most browsers have open public bug trackers suitable for this purpose.</p>
<p><strong>Tip:</strong> I’d only suggest working around a performance issue in a browser if it was a really drastic show-stopper, not just an annoyance or frustration. And I’d be very careful to check that the performance hack didn’t have noticeable negative side effects in another browser.</p>
<h3 id="Big-Picture"><a href="#Big-Picture" class="headerlink" title="Big Picture"></a>Big Picture</h3><p>Instead of worrying about all these microperformance nuances, we should instead be looking at big-picture types of optimizations.</p>
<p>How do you know what’s big picture or not? You have to first understand if your code is running on a critical path or not. If it’s not on the critical path, chances are your optimizations are not worth much.</p>
<p>Ever heard the admonition, “that’s premature optimization!”? It comes from a famous quote from Donald Knuth: “premature optimization is the root of all evil.”. Many developers cite this quote to suggest that most optimizations are “premature” and are thus a waste of effort. The truth is, as usual, more nuanced.</p>
<p>Here is Knuth’s quote, in context:</p>
<blockquote>
<p>Programmers waste enormous amounts of time thinking about, or worrying about, the speed of <strong>noncritical</strong> parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that <strong>critical</strong> 3%. [emphasis added]</p>
</blockquote>
<p>(<a href="http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf" target="_blank" rel="noopener">http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf</a>, Computing Surveys, Vol 6, No 4, December 1974)</p>
<p>I believe it’s a fair paraphrasing to say that Knuth <em>meant</em>: “non-critical path optimization is the root of all evil.” So the key is to figure out if your code is on the critical path – you should optimize it! – or not.</p>
<p>I’d even go so far as to say this: no amount of time spent optimizing critical paths is wasted, no matter how little is saved; but no amount of optimization on noncritical paths is justified, no matter how much is saved.</p>
<p>If your code is on the critical path, such as a “hot” piece of code that’s going to be run over and over again, or in UX critical places where users will notice, like an animation loop or CSS style updates, then you should spare no effort in trying to employ relevant, measurably significant optimizations.</p>
<p>For example, consider a critical path animation loop that needs to coerce a string value to a number. There are of course multiple ways to do that (see the <em>Types &amp; Grammar</em> title of this book series), but which one if any is the fastest?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"42"</span>;	<span class="comment">// need number `42`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 1: let implicit coercion automatically happen</span></span><br><span class="line"><span class="keyword">var</span> y = x / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2: use `parseInt(..)`</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">parseInt</span>( x, <span class="number">0</span> ) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 3: use `Number(..)`</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">Number</span>( x ) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 4: use `+` unary operator</span></span><br><span class="line"><span class="keyword">var</span> y = +x / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 5: use `|` unary operator</span></span><br><span class="line"><span class="keyword">var</span> y = (x | <span class="number">0</span>) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> I will leave it as an exercise to the reader to set up a test if you’re interested in examining the minute differences in performance among these options.</p>
<p>When considering these different options, as they say, “One of these things is not like the others.” <code>parseInt(..)</code> does the job, but it also does a lot more – it parses the string rather than just coercing. You can probably guess, correctly, that <code>parseInt(..)</code> is a slower option, and you should probably avoid it.</p>
<p>Of course, if <code>x</code> can ever be a value that <strong>needs parsing</strong>, such as <code>&quot;42px&quot;</code> (like from a CSS style lookup), then <code>parseInt(..)</code> really is the only suitable option!</p>
<p><code>Number(..)</code> is also a function call. From a behavioral perspective, it’s identical to the <code>+</code> unary operator option, but it may in fact be a little slower, requiring more machinery to execute the function. Of course, it’s also possible that the JS engine recognizes this behavioral symmetry and just handles the inlining of <code>Number(..)</code>‘s behavior (aka <code>+x</code>) for you!</p>
<p>But remember, obsessing about <code>+x</code> versus <code>x | 0</code> is in most cases likely a waste of effort. This is a microperformance issue, and one that you shouldn’t let dictate/degrade the readability of your program.</p>
<p>While performance is very important in critical paths of your program, it’s not the only factor. Among several options that are roughly similar in performance, readability should be another important concern.</p>
<h2 id="Tail-Call-Optimization-TCO"><a href="#Tail-Call-Optimization-TCO" class="headerlink" title="Tail Call Optimization (TCO)"></a>Tail Call Optimization (TCO)</h2><p>As we briefly mentioned earlier, ES6 includes a specific requirement that ventures into the world of performance. It’s related to a specific form of optimization that can occur with function calls: <em>tail call optimization</em>.</p>
<p>Briefly, a “tail call” is a function call that appears at the “tail” of another function, such that after the call finishes, there’s nothing left to do (except perhaps return its result value).</p>
<p>For example, here’s a non-recursive setup with tail calls:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> foo( y + <span class="number">1</span> );	<span class="comment">// tail call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + bar( <span class="number">40</span> );	<span class="comment">// not tail call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz();						<span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p><code>foo(y+1)</code> is a tail call in <code>bar(..)</code> because after <code>foo(..)</code> finishes, <code>bar(..)</code> is also finished except in this case returning the result of the <code>foo(..)</code> call. However, <code>bar(40)</code> is <em>not</em> a tail call because after it completes, its result value must be added to <code>1</code> before <code>baz()</code> can return it.</p>
<p>Without getting into too much nitty-gritty detail, calling a new function requires an extra amount of reserved memory to manage the call stack, called a “stack frame.” So the preceding snippet would generally require a stack frame for each of <code>baz()</code>, <code>bar(..)</code>, and <code>foo(..)</code> all at the same time.</p>
<p>However, if a TCO-capable engine can realize that the <code>foo(y+1)</code> call is in <em>tail position</em> meaning <code>bar(..)</code> is basically complete, then when calling <code>foo(..)</code>, it doesn’t need to create a new stack frame, but can instead reuse the existing stack frame from <code>bar(..)</code>. That’s not only faster, but it also uses less memory.</p>
<p>That sort of optimization isn’t a big deal in a simple snippet, but it becomes a <em>much bigger deal</em> when dealing with recursion, especially if the recursion could have resulted in hundreds or thousands of stack frames. With TCO the engine can perform all those calls with a single stack frame!</p>
<p>Recursion is a hairy topic in JS because without TCO, engines have had to implement arbitrary (and different!) limits to how deep they will let the recursion stack get before they stop it, to prevent running out of memory. With TCO, recursive functions with <em>tail position</em> calls can essentially run unbounded, because there’s never any extra usage of memory!</p>
<p>Consider that recursive <code>factorial(..)</code> from before, but rewritten to make it TCO friendly:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n,res</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> fact( n - <span class="number">1</span>, n * res );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fact( n, <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial( <span class="number">5</span> );		<span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>This version of <code>factorial(..)</code> is still recursive, but it’s also optimizable with TCO, because both inner <code>fact(..)</code> calls are in <em>tail position</em>.</p>
<p><strong>Note:</strong> It’s important to note that TCO only applies if there’s actually a tail call. If you write recursive functions without tail calls, the performance will still fall back to normal stack frame allocation, and the engines’ limits on such recursive call stacks will still apply. Many recursive functions can be rewritten as we just showed with <code>factorial(..)</code>, but it takes careful attention to detail.</p>
<p>One reason that ES6 requires engines to implement TCO rather than leaving it up to their discretion is because the <em>lack of TCO</em> actually tends to reduce the chances that certain algorithms will be implemented in JS using recursion, for fear of the call stack limits.</p>
<p>If the lack of TCO in the engine would just gracefully degrade to slower performance in all cases, it wouldn’t probably have been something that ES6 needed to <em>require</em>. But because the lack of TCO can actually make certain programs impractical, it’s more an important feature of the language than just a hidden implementation detail.</p>
<p>ES6 guarantees that from now on, JS developers will be able to rely on this optimization across all ES6+ compliant browsers. That’s a win for JS performance!</p>
<h2 id="Review-5"><a href="#Review-5" class="headerlink" title="Review"></a>Review</h2><p>Effectively benchmarking performance of a piece of code, especially to compare it to another option for that same code to see which approach is faster, requires careful attention to detail.</p>
<p>Rather than rolling your own statistically valid benchmarking logic, just use the Benchmark.js library, which does that for you. But be careful about how you author tests, because it’s far too easy to construct a test that seems valid but that’s actually flawed – even tiny differences can skew the results to be completely unreliable.</p>
<p>It’s important to get as many test results from as many different environments as possible to eliminate hardware/device bias. jsPerf.com is a fantastic website for crowdsourcing performance benchmark test runs.</p>
<p>Many common performance tests unfortunately obsess about irrelevant microperformance details like <code>x++</code> versus <code>++x</code>. Writing good tests means understanding how to focus on big picture concerns, like optimizing on the critical path, and avoiding falling into traps like different JS engines’ implementation details.</p>
<p>Tail call optimization (TCO) is a required optimization as of ES6 that will make some recursive patterns practical in JS where they would have been impossible otherwise. TCO allows a function call in the <em>tail position</em> of another function to execute without needing any extra resources, which means the engine no longer needs to place arbitrary restrictions on call stack depth for recursive algorithms.</p>
<h1 id="Appendix-A-asynquence-Library"><a href="#Appendix-A-asynquence-Library" class="headerlink" title="Appendix A: asynquence Library"></a>Appendix A: <em>asynquence</em> Library</h1><p>Chapters 1 and 2 went into quite a bit of detail about typical asynchronous programming patterns and how they’re commonly solved with callbacks. But we also saw why callbacks are fatally limited in capability, which led us to Chapters 3 and 4, with Promises and generators offering a much more solid, trustable, and reason-able base to build your asynchrony on.</p>
<p>I referenced my own asynchronous library <em>asynquence</em> (<a href="http://github.com/getify/asynquence" target="_blank" rel="noopener">http://github.com/getify/asynquence</a>) – “async” + “sequence” = “asynquence” – several times in this book, and I want to now briefly explain how it works and why its unique design is important and helpful.</p>
<p>In the next appendix, we’ll explore some advanced async patterns, but you’ll probably want a library to make those palatable enough to be useful. We’ll use <em>asynquence</em> to express those patterns, so you’ll want to spend a little time here getting to know the library first.</p>
<p><em>asynquence</em> is obviously not the only option for good async coding; certainly there are many great libraries in this space. But <em>asynquence</em> provides a unique perspective by combining the best of all these patterns into a single library, and moreover is built on a single basic abstraction: the (async) sequence.</p>
<p>My premise is that sophisticated JS programs often need bits and pieces of various different asynchronous patterns woven together, and this is usually left entirely up to each developer to figure out. Instead of having to bring in two or more different async libraries that focus on different aspects of asynchrony, <em>asynquence</em> unifies them into variated sequence steps, with just one core library to learn and deploy.</p>
<p>I believe the value is strong enough with <em>asynquence</em> to make async flow control programming with Promise-style semantics super easy to accomplish, so that’s why we’ll exclusively focus on that library here.</p>
<p>To begin, I’ll explain the design principles behind <em>asynquence</em>, and then we’ll illustrate how its API works with code examples.</p>
<h2 id="Sequences-Abstraction-Design"><a href="#Sequences-Abstraction-Design" class="headerlink" title="Sequences, Abstraction Design"></a>Sequences, Abstraction Design</h2><p>Understanding <em>asynquence</em> begins with understanding a fundamental abstraction: any series of steps for a task, whether they separately are synchronous or asynchronous, can be collectively thought of as a “sequence”. In other words, a sequence is a container that represents a task, and is comprised of individual (potentially async) steps to complete that task.</p>
<p>Each step in the sequence is controlled under the covers by a Promise (see Chapter 3). That is, every step you add to a sequence implicitly creates a Promise that is wired to the previous end of the sequence. Because of the semantics of Promises, every single step advancement in a sequence is asynchronous, even if you synchronously complete the step.</p>
<p>Moreover, a sequence will always proceed linearly from step to step, meaning that step 2 always comes after step 1 finishes, and so on.</p>
<p>Of course, a new sequence can be forked off an existing sequence, meaning the fork only occurs once the main sequence reaches that point in the flow. Sequences can also be combined in various ways, including having one sequence subsumed by another sequence at a particular point in the flow.</p>
<p>A sequence is kind of like a Promise chain. However, with Promise chains, there is no “handle” to grab that references the entire chain. Whichever Promise you have a reference to only represents the current step in the chain plus any other steps hanging off it. Essentially, you cannot hold a reference to a Promise chain unless you hold a reference to the first Promise in the chain.</p>
<p>There are many cases where it turns out to be quite useful to have a handle that references the entire sequence collectively. The most important of those cases is with sequence abort/cancel. As we covered extensively in Chapter 3, Promises themselves should never be able to be canceled, as this violates a fundamental design imperative: external immutability.</p>
<p>But sequences have no such immutability design principle, mostly because sequences are not passed around as future-value containers that need immutable value semantics. So sequences are the proper level of abstraction to handle abort/cancel behavior. <em>asynquence</em> sequences can be <code>abort()</code>ed at any time, and the sequence will stop at that point and not go for any reason.</p>
<p>There’s plenty more reasons to prefer a sequence abstraction on top of Promise chains, for flow control purposes.</p>
<p>First, Promise chaining is a rather manual process – one that can get pretty tedious once you start creating and chaining Promises across a wide swath of your programs – and this tedium can act counterproductively to dissuade the developer from using Promises in places where they are quite appropriate.</p>
<p>Abstractions are meant to reduce boilerplate and tedium, so the sequence abstraction is a good solution to this problem. With Promises, your focus is on the individual step, and there’s little assumption that you will keep the chain going. With sequences, the opposite approach is taken, assuming the sequence will keep having more steps added indefinitely.</p>
<p>This abstraction complexity reduction is especially powerful when you start thinking about higher-order Promise patterns (beyond <code>race([..])</code> and <code>all([..])</code>.</p>
<p>For example, in the middle of a sequence, you may want to express a step that is conceptually like a <code>try..catch</code> in that the step will always result in success, either the intended main success resolution or a positive nonerror signal for the caught error. Or, you might want to express a step that is like a retry/until loop, where it keeps trying the same step over and over until success occurs.</p>
<p>These sorts of abstractions are quite nontrivial to express using only Promise primitives, and doing so in the middle of an existing Promise chain is not pretty. But if you abstract your thinking to a sequence, and consider a step as a wrapper around a Promise, that step wrapper can hide such details, freeing you to think about the flow control in the most sensible way without being bothered by the details.</p>
<p>Second, and perhaps more importantly, thinking of async flow control in terms of steps in a sequence allows you to abstract out the details of what types of asynchronicity are involved with each individual step. Under the covers, a Promise will always control the step, but above the covers, that step can look either like a continuation callback (the simple default), or like a real Promise, or as a run-to-completion generator, or … Hopefully, you get the picture.</p>
<p>Third, sequences can more easily be twisted to adapt to different modes of thinking, such as event-, stream-, or reactive-based coding. <em>asynquence</em> provides a pattern I call “reactive sequences” (which we’ll cover later) as a variation on the “reactive observable” ideas in RxJS (“Reactive Extensions”), that lets a repeatable event fire off a new sequence instance each time. Promises are one-shot-only, so it’s quite awkward to express repetitious asynchrony with Promises alone.</p>
<p>Another alternate mode of thinking inverts the resolution/control capability in a pattern I call “iterable sequences”. Instead of each individual step internally controlling its own completion (and thus advancement of the sequence), the sequence is inverted so the advancement control is through an external iterator, and each step in the <em>iterable sequence</em> just responds to the <code>next(..)</code> <em>iterator</em> control.</p>
<p>We’ll explore all of these different variations as we go throughout the rest of this appendix, so don’t worry if we ran over those bits far too quickly just now.</p>
<p>The takeaway is that sequences are a more powerful and sensible abstraction for complex asynchrony than just Promises (Promise chains) or just generators, and <em>asynquence</em> is designed to express that abstraction with just the right level of sugar to make async programming more understandable and more enjoyable.</p>
<h2 id="asynquence-API"><a href="#asynquence-API" class="headerlink" title="asynquence API"></a><em>asynquence</em> API</h2><p>To start off, the way you create a sequence (an <em>asynquence</em> instance) is with the <code>ASQ(..)</code> function. An <code>ASQ()</code> call with no parameters creates an empty initial sequence, whereas passing one or more values or functions to <code>ASQ(..)</code> sets up the sequence with each argument representing the initial steps of the sequence.</p>
<p><strong>Note:</strong> For the purposes of all code examples here, I will use the <em>asynquence</em> top-level identifier in global browser usage: <code>ASQ</code>. If you include and use <em>asynquence</em> through a module system (browser or server), you of course can define whichever symbol you prefer, and <em>asynquence</em> won’t care!</p>
<p>Many of the API methods discussed here are built into the core of <em>asynquence</em>, but others are provided through including the optional “contrib” plug-ins package. See the documentation for <em>asynquence</em> for whether a method is built in or defined via plug-in: <a href="http://github.com/getify/asynquence" target="_blank" rel="noopener">http://github.com/getify/asynquence</a></p>
<h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><p>If a function represents a normal step in the sequence, that function is invoked with the first parameter being the continuation callback, and any subsequent parameters being any messages passed on from the previous step. The step will not complete until the continuation callback is called. Once it’s called, any arguments you pass to it will be sent along as messages to the next step in the sequence.</p>
<p>To add an additional normal step to the sequence, call <code>then(..)</code> (which has essentially the exact same semantics as the <code>ASQ(..)</code> call):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ASQ(</span><br><span class="line">	<span class="comment">// step 1</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			done( <span class="string">"Hello"</span> );</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// step 2</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">done,greeting</span>) </span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			done( greeting + <span class="string">" World"</span> );</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// step 3</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">done,msg</span>)</span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( msg.toUpperCase() );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// step 4</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">done,msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );			<span class="comment">// HELLO WORLD</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Though the name <code>then(..)</code> is identical to the native Promises API, this <code>then(..)</code> is different. You can pass as few or as many functions or values to <code>then(..)</code> as you’d like, and each is taken as a separate step. There’s no two-callback fulfilled/rejected semantics involved.</p>
<p>Unlike with Promises, where to chain one Promise to the next you have to create and <code>return</code> that Promise from a <code>then(..)</code> fulfillment handler, with <em>asynquence</em>, all you need to do is call the continuation callback – I always call it <code>done()</code> but you can name it whatever suits you – and optionally pass it completion messages as arguments.</p>
<p>Each step defined by <code>then(..)</code> is assumed to be asynchronous. If you have a step that’s synchronous, you can either just call <code>done(..)</code> right away, or you can use the simpler <code>val(..)</code> step helper:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1 (sync)</span></span><br><span class="line">ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	done( <span class="string">"Hello"</span> );	<span class="comment">// manually synchronous</span></span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// step 2 (sync)</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">greeting</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> greeting + <span class="string">" World"</span>;</span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// step 3 (async)</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">done,msg</span>)</span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( msg.toUpperCase() );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// step 4 (sync)</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>As you can see, <code>val(..)</code>-invoked steps don’t receive a continuation callback, as that part is assumed for you – and the parameter list is less cluttered as a result! To send a message along to the next step, you simply use <code>return</code>.</p>
<p>Think of <code>val(..)</code> as representing a synchronous “value-only” step, which is useful for synchronous value operations, logging, and the like.</p>
<h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>One important difference with <em>asynquence</em> compared to Promises is with error handling.</p>
<p>With Promises, each individual Promise (step) in a chain can have its own independent error, and each subsequent step has the ability to handle the error or not. The main reason for this semantic comes (again) from the focus on individual Promises rather than on the chain (sequence) as a whole.</p>
<p>I believe that most of the time, an error in one part of a sequence is generally not recoverable, so the subsequent steps in the sequence are moot and should be skipped. So, by default, an error at any step of a sequence throws the entire sequence into error mode, and the rest of the normal steps are ignored.</p>
<p>If you <em>do</em> need to have a step where its error is recoverable, there are several different API methods that can accommodate, such as <code>try(..)</code> – previously mentioned as a kind of <code>try..catch</code> step – or <code>until(..)</code> – a retry loop that keeps attempting the step until it succeeds or you manually <code>break()</code> the loop. <em>asynquence</em> even has <code>pThen(..)</code> and <code>pCatch(..)</code> methods, which work identically to how normal Promise <code>then(..)</code> and <code>catch(..)</code> work (see Chapter 3), so you can do localized mid-sequence error handling if you so choose.</p>
<p>The point is, you have both options, but the more common one in my experience is the default. With Promises, to get a chain of steps to ignore all steps once an error occurs, you have to take care not to register a rejection handler at any step; otherwise, that error gets swallowed as handled, and the sequence may continue (perhaps unexpectedly). This kind of desired behavior is a bit awkward to properly and reliably handle.</p>
<p>To register a sequence error notification handler, <em>asynquence</em> provides an <code>or(..)</code> sequence method, which also has an alias of <code>onerror(..)</code>. You can call this method anywhere in the sequence, and you can register as many handlers as you’d like. That makes it easy for multiple different consumers to listen in on a sequence to know if it failed or not; it’s kind of like an error event handler in that respect.</p>
<p>Just like with Promises, all JS exceptions become sequence errors, or you can programmatically signal a sequence error:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// signal an error for the sequence</span></span><br><span class="line">		done.fail( <span class="string">"Oops"</span> );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// will never get here</span></span><br><span class="line">&#125; )</span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( err );			<span class="comment">// Oops</span></span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// won't get here either</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"></span><br><span class="line">sq.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( err );			<span class="comment">// Oops</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Another really important difference with error handling in <em>asynquence</em> compared to native Promises is the default behavior of “unhandled exceptions”. As we discussed at length in Chapter 3, a rejected Promise without a registered rejection handler will just silently hold (aka swallow) the error; you have to remember to always end a chain with a final <code>catch(..)</code>.</p>
<p>In <em>asynquence</em>, the assumption is reversed.</p>
<p>If an error occurs on a sequence, and it <strong>at that moment</strong> has no error handlers registered, the error is reported to the <code>console</code>. In other words, unhandled rejections are by default always reported so as not to be swallowed and missed.</p>
<p>As soon as you register an error handler against a sequence, it opts that sequence out of such reporting, to prevent duplicate noise.</p>
<p>There may, in fact, be cases where you want to create a sequence that may go into the error state before you have a chance to register the handler. This isn’t common, but it can happen from time to time.</p>
<p>In those cases, you can also <strong>opt a sequence instance out</strong> of error reporting by calling <code>defer()</code> on the sequence. You should only opt out of error reporting if you are sure that you’re going to eventually handle such errors:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq1 = ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	doesnt.Exist();			<span class="comment">// will throw exception to console</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sq2 = ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	doesnt.Exist();			<span class="comment">// will throw only a sequence error</span></span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// opt-out of error reporting</span></span><br><span class="line">.defer();</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	sq1.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( err );	<span class="comment">// ReferenceError</span></span><br><span class="line">	&#125; );</span><br><span class="line"></span><br><span class="line">	sq2.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( err );	<span class="comment">// ReferenceError</span></span><br><span class="line">	&#125; );</span><br><span class="line">&#125;, <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReferenceError (from sq1)</span></span><br></pre></td></tr></table></figure>
<p>This is better error handling behavior than Promises themselves have, because it’s the Pit of Success, not the Pit of Failure (see Chapter 3).</p>
<p><strong>Note:</strong> If a sequence is piped into (aka subsumed by) another sequence – see “Combining Sequences”  for a complete description – then the source sequence is opted out of error reporting, but now the target sequence’s error reporting or lack thereof must be considered.</p>
<h3 id="Parallel-Steps"><a href="#Parallel-Steps" class="headerlink" title="Parallel Steps"></a>Parallel Steps</h3><p>Not all steps in your sequences will have just a single (async) task to perform; some will need to perform multiple steps “in parallel” (concurrently). A step in a sequence in which multiple substeps are processing concurrently is called a <code>gate(..)</code> – there’s an <code>all(..)</code> alias if you prefer – and is directly symmetric to native <code>Promise.all([..])</code>.</p>
<p>If all the steps in the <code>gate(..)</code> complete successfully, all success messages will be passed to the next sequence step. If any of them generate errors, the whole sequence immediately goes into an error state.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	setTimeout( done, <span class="number">100</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.gate(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			done( <span class="string">"Hello"</span> );</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			done( <span class="string">"World"</span>, <span class="string">"!"</span> );</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg1,msg2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg1 );	<span class="comment">// Hello</span></span><br><span class="line">	<span class="built_in">console</span>.log( msg2 );	<span class="comment">// [ "World", "!" ]</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>For illustration, let’s compare that example to native Promises:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	setTimeout( resolve, <span class="number">100</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">			setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				resolve( <span class="string">"Hello"</span> );</span><br><span class="line">			&#125;, <span class="number">100</span> );</span><br><span class="line">		&#125; ),</span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">			setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="comment">// note: we need a [ ] array here</span></span><br><span class="line">				resolve( [ <span class="string">"World"</span>, <span class="string">"!"</span> ] );</span><br><span class="line">			&#125;, <span class="number">100</span> );</span><br><span class="line">		&#125; )</span><br><span class="line">	] );</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msgs</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msgs[<span class="number">0</span>] );	<span class="comment">// Hello</span></span><br><span class="line">	<span class="built_in">console</span>.log( msgs[<span class="number">1</span>] );	<span class="comment">// [ "World", "!" ]</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Yuck. Promises require a lot more boilerplate overhead to express the same asynchronous flow control. That’s a great illustration of why the <em>asynquence</em> API and abstraction make dealing with Promise steps a lot nicer. The improvement only goes higher the more complex your asynchrony is.</p>
<h4 id="Step-Variations"><a href="#Step-Variations" class="headerlink" title="Step Variations"></a>Step Variations</h4><p>There are several variations in the contrib plug-ins on <em>asynquence</em>‘s <code>gate(..)</code> step type that can be quite helpful:</p>
<ul>
<li><code>any(..)</code> is like <code>gate(..)</code>, except just one segment has to eventually succeed to proceed on the main sequence.</li>
<li><code>first(..)</code> is like <code>any(..)</code>, except as soon as any segment succeeds, the main sequence proceeds (ignoring subsequent results from other segments).</li>
<li><code>race(..)</code> (symmetric with <code>Promise.race([..])</code>) is like <code>first(..)</code>, except the main sequence proceeds as soon as any segment completes (either success or failure).</li>
<li><code>last(..)</code> is like <code>any(..)</code>, except only the latest segment to complete successfully sends its message(s) along to the main sequence.</li>
<li><code>none(..)</code> is the inverse of <code>gate(..)</code>: the main sequence proceeds only if all the segments fail (with all segment error message(s) transposed as success message(s) and vice versa).</li>
</ul>
<p>Let’s first define some helpers to make illustration cleaner:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success1</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( <span class="number">1</span> );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success2</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( <span class="number">2</span> );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">failure3</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done.fail( <span class="number">3</span> );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, let’s demonstrate these <code>gate(..)</code> step variations:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ASQ().race(</span><br><span class="line">	failure3,</span><br><span class="line">	success1</span><br><span class="line">)</span><br><span class="line">.or( output );		<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ASQ().any(</span><br><span class="line">	success1,</span><br><span class="line">	failure3,</span><br><span class="line">	success2</span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [].slice.call( <span class="built_in">arguments</span> );</span><br><span class="line">	<span class="built_in">console</span>.log(</span><br><span class="line">		args		<span class="comment">// [ 1, undefined, 2 ]</span></span><br><span class="line">	);</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ASQ().first(</span><br><span class="line">	failure3,</span><br><span class="line">	success1,</span><br><span class="line">	success2</span><br><span class="line">)</span><br><span class="line">.val( output );		<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ASQ().last(</span><br><span class="line">	failure3,</span><br><span class="line">	success1,</span><br><span class="line">	success2</span><br><span class="line">)</span><br><span class="line">.val( output );		<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">ASQ().none(</span><br><span class="line">	failure3</span><br><span class="line">)</span><br><span class="line">.val( output )		<span class="comment">// 3</span></span><br><span class="line">.none(</span><br><span class="line">	failure3</span><br><span class="line">	success1</span><br><span class="line">)</span><br><span class="line">.or( output );		<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>Another step variation is <code>map(..)</code>, which lets you asynchronously map elements of an array to different values, and the step doesn’t proceed until all the mappings are complete. <code>map(..)</code> is very similar to <code>gate(..)</code>, except it gets the initial values from an array instead of from separately specified functions, and also because you define a single function callback to operate on each value:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x,done</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( x * <span class="number">2</span> );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASQ().map( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], double )</span><br><span class="line">.val( output );					<span class="comment">// [2,4,6]</span></span><br></pre></td></tr></table></figure>
<p>Also, <code>map(..)</code> can receive either of its parameters (the array or the callback) from messages passed from the previous step:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusOne</span>(<span class="params">x,done</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( x + <span class="number">1</span> );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASQ( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] )</span><br><span class="line">.map( double )			<span class="comment">// message `[1,2,3]` comes in</span></span><br><span class="line">.map( plusOne )			<span class="comment">// message `[2,4,6]` comes in</span></span><br><span class="line">.val( output );			<span class="comment">// [3,5,7]</span></span><br></pre></td></tr></table></figure>
<p>Another variation is <code>waterfall(..)</code>, which is kind of like a mixture between <code>gate(..)</code>‘s message collection behavior but <code>then(..)</code>‘s sequential processing.</p>
<p>Step 1 is first executed, then the success message from step 1 is given to step 2, and then both success messages go to step 3, and then all three success messages go to step 4, and so on, such that the messages sort of collect and cascade down the “waterfall”.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</span><br><span class="line">	<span class="built_in">console</span>.log( args );</span><br><span class="line"></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( args[args.length - <span class="number">1</span>] * <span class="number">2</span> );</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ASQ( <span class="number">3</span> )</span><br><span class="line">.waterfall(</span><br><span class="line">	double,					<span class="comment">// [ 3 ]</span></span><br><span class="line">	double,					<span class="comment">// [ 6 ]</span></span><br><span class="line">	double,					<span class="comment">// [ 6, 12 ]</span></span><br><span class="line">	double					<span class="comment">// [ 6, 12, 24 ]</span></span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = [].slice.call( <span class="built_in">arguments</span> );</span><br><span class="line">	<span class="built_in">console</span>.log( args );	<span class="comment">// [ 6, 12, 24, 48 ]</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>If at any point in the “waterfall” an error occurs, the whole sequence immediately goes into an error state.</p>
<h4 id="Error-Tolerance"><a href="#Error-Tolerance" class="headerlink" title="Error Tolerance"></a>Error Tolerance</h4><p>Sometimes you want to manage errors at the step level and not let them necessarily send the whole sequence into the error state. <em>asynquence</em> offers two step variations for that purpose.</p>
<p><code>try(..)</code> attempts a step, and if it succeeds, the sequence proceeds as normal, but if the step fails, the failure is turned into a success message formated as <code>{ catch: .. }</code> with the error message(s) filled in:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ASQ()</span><br><span class="line">.try( success1 )</span><br><span class="line">.val( output )			<span class="comment">// 1</span></span><br><span class="line">.try( failure3 )</span><br><span class="line">.val( output )			<span class="comment">// &#123; catch: 3 &#125;</span></span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// never gets here</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>You could instead set up a retry loop using <code>until(..)</code>, which tries the step and if it fails, retries the step again on the next event loop tick, and so on.</p>
<p>This retry loop can continue indefinitely, but if you want to break out of the loop, you can call the <code>break()</code> flag on the completion trigger, which sends the main sequence into an error state:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ASQ( <span class="number">3</span> )</span><br><span class="line">.until( double )</span><br><span class="line">.val( output )					<span class="comment">// 6</span></span><br><span class="line">.until( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	count++;</span><br><span class="line"></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">			done.fail();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// break out of the `until(..)` retry loop</span></span><br><span class="line">			done.break( <span class="string">"Oops"</span> );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="number">100</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.or( output );					<span class="comment">// Oops</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise-Style-Steps"><a href="#Promise-Style-Steps" class="headerlink" title="Promise-Style Steps"></a>Promise-Style Steps</h4><p>If you would prefer to have, inline in your sequence, Promise-style semantics like Promises’ <code>then(..)</code> and <code>catch(..)</code> (see Chapter 3), you can use the <code>pThen</code> and <code>pCatch</code> plug-ins:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ASQ( <span class="number">21</span> )</span><br><span class="line">.pThen( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msg * <span class="number">2</span>;</span><br><span class="line">&#125; )</span><br><span class="line">.pThen( output )				<span class="comment">// 42</span></span><br><span class="line">.pThen( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// throw an exception</span></span><br><span class="line">	doesnt.Exist();</span><br><span class="line">&#125; )</span><br><span class="line">.pCatch( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// caught the exception (rejection)</span></span><br><span class="line">	<span class="built_in">console</span>.log( err );			<span class="comment">// ReferenceError</span></span><br><span class="line">&#125; )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// main sequence is back in a</span></span><br><span class="line">	<span class="comment">// success state because previous</span></span><br><span class="line">	<span class="comment">// exception was caught by</span></span><br><span class="line">	<span class="comment">// `pCatch(..)`</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>pThen(..)</code> and <code>pCatch(..)</code> are designed to run in the sequence, but behave as if it was a normal Promise chain. As such, you can either resolve genuine Promises or <em>asynquence</em> sequences from the “fulfillment” handler passed to <code>pThen(..)</code> (see Chapter 3).</p>
<h3 id="Forking-Sequences"><a href="#Forking-Sequences" class="headerlink" title="Forking Sequences"></a>Forking Sequences</h3><p>One feature that can be quite useful about Promises is that you can attach multiple <code>then(..)</code> handler registrations to the same promise, effectively “forking” the flow-control at that promise:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">21</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork 1 (from `p`)</span></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msg * <span class="number">2</span>;</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// 42</span></span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork 2 (from `p`)</span></span><br><span class="line">p.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// 21</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The same “forking” is easy in <em>asynquence</em> with <code>fork()</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ(..).then(..).then(..);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sq2 = sq.fork();</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork 1</span></span><br><span class="line">sq.then(..)..;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork 2</span></span><br><span class="line">sq2.then(..)..;</span><br></pre></td></tr></table></figure>
<h3 id="Combining-Sequences"><a href="#Combining-Sequences" class="headerlink" title="Combining Sequences"></a>Combining Sequences</h3><p>The reverse of <code>fork()</code>ing, you can combine two sequences by subsuming one into another, using the <code>seq(..)</code> instance method:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		done( <span class="string">"Hello World"</span> );</span><br><span class="line">	&#125;, <span class="number">200</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	setTimeout( done, <span class="number">100</span> );</span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// subsume `sq` sequence into this sequence</span></span><br><span class="line">.seq( sq )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// Hello World</span></span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure>
<p><code>seq(..)</code> can either accept a sequence itself, as shown here, or a function. If a function, it’s expected that the function when called will return a sequence, so the preceding code could have been done with:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..</span></span><br><span class="line">.seq( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// ..</span></span><br></pre></td></tr></table></figure>
<p>Also, that step could instead have been accomplished with a <code>pipe(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// pipe `sq` into the `done` continuation callback</span></span><br><span class="line">	sq.pipe( done );</span><br><span class="line">&#125; )</span><br><span class="line"><span class="comment">// ..</span></span><br></pre></td></tr></table></figure>
<p>When a sequence is subsumed, both its success message stream and its error stream are piped in.</p>
<p><strong>Note:</strong> As mentioned in an earlier note, piping (manually with <code>pipe(..)</code> or automatically with <code>seq(..)</code>) opts the source sequence out of error-reporting, but doesn’t affect the error reporting status of the target sequence.</p>
<h2 id="Value-and-Error-Sequences"><a href="#Value-and-Error-Sequences" class="headerlink" title="Value and Error Sequences"></a>Value and Error Sequences</h2><p>If any step of a sequence is just a normal value, that value is just mapped to that step’s completion message:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">sq.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>If you want to make a sequence that’s automatically errored:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ.failed( <span class="string">"Oops"</span> );</span><br><span class="line"></span><br><span class="line">ASQ()</span><br><span class="line">.seq( sq )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// won't get here</span></span><br><span class="line">&#125; )</span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( err );		<span class="comment">// Oops</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>You also may want to automatically create a delayed-value or a delayed-error sequence. Using the <code>after</code> and <code>failAfter</code> contrib plug-ins, this is easy:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq1 = ASQ.after( <span class="number">100</span>, <span class="string">"Hello"</span>, <span class="string">"World"</span> );</span><br><span class="line"><span class="keyword">var</span> sq2 = ASQ.failAfter( <span class="number">100</span>, <span class="string">"Oops"</span> );</span><br><span class="line"></span><br><span class="line">sq1.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg1,msg2</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg1, msg2 );		<span class="comment">// Hello World</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">sq2.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( err );				<span class="comment">// Oops</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>You can also insert a delay in the middle of a sequence using <code>after(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ASQ( <span class="number">42</span> )</span><br><span class="line"><span class="comment">// insert a delay into the sequence</span></span><br><span class="line">.after( <span class="number">100</span> )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h2 id="Promises-and-Callbacks"><a href="#Promises-and-Callbacks" class="headerlink" title="Promises and Callbacks"></a>Promises and Callbacks</h2><p>I think <em>asynquence</em> sequences provide a lot of value on top of native Promises, and for the most part you’ll find it more pleasant and more powerful to work at that level of abstraction. However, integrating <em>asynquence</em> with other non-<em>asynquence</em> code will be a reality.</p>
<p>You can easily subsume a promise (e.g., thenable – see Chapter 3) into a sequence using the <code>promise(..)</code> instance method:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">ASQ()</span><br><span class="line">.promise( p )			<span class="comment">// could also: `function()&#123; return p; &#125;`</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );	<span class="comment">// 42</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>And to go the opposite direction and fork/vend a promise from a sequence at a certain step, use the <code>toPromise</code> contrib plug-in:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ.after( <span class="number">100</span>, <span class="string">"Hello World"</span> );</span><br><span class="line"></span><br><span class="line">sq.toPromise()</span><br><span class="line"><span class="comment">// this is a standard promise chain now</span></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> msg.toUpperCase();</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );		<span class="comment">// HELLO WORLD</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>To adapt <em>asynquence</em> to systems using callbacks, there are several helper facilities. To automatically generate an “error-first style” callback from your sequence to wire into a callback-oriented utility, use <code>errfcb</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// note: expecting "error-first style" callback</span></span><br><span class="line">	someAsyncFuncWithCB( <span class="number">1</span>, <span class="number">2</span>, done.errfcb )</span><br><span class="line">&#125; )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125; )</span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: expecting "error-first style" callback</span></span><br><span class="line">anotherAsyncFuncWithCB( <span class="number">1</span>, <span class="number">2</span>, sq.errfcb() );</span><br></pre></td></tr></table></figure>
<p>You also may want to create a sequence-wrapped version of a utility – compare to “promisory” in Chapter 3 and “thunkory” in Chapter 4 – and <em>asynquence</em> provides <code>ASQ.wrap(..)</code> for that purpose:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coolUtility = ASQ.wrap( someAsyncFuncWithCB );</span><br><span class="line"></span><br><span class="line">coolUtility( <span class="number">1</span>, <span class="number">2</span> )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125; )</span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> For the sake of clarity (and for fun!), let’s coin yet another term, for a sequence-producing function that comes from <code>ASQ.wrap(..)</code>, like <code>coolUtility</code> here. I propose “sequory” (“sequence” + “factory”).</p>
<h2 id="Iterable-Sequences"><a href="#Iterable-Sequences" class="headerlink" title="Iterable Sequences"></a>Iterable Sequences</h2><p>The normal paradigm for a sequence is that each step is responsible for completing itself, which is what advances the sequence. Promises work the same way.</p>
<p>The unfortunate part is that sometimes you need external control over a Promise/step, which leads to awkward “capability extraction”.</p>
<p>Consider this Promises example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domready = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// don't want to put this here, because</span></span><br><span class="line">	<span class="comment">// it belongs logically in another part</span></span><br><span class="line">	<span class="comment">// of the code</span></span><br><span class="line">	<span class="built_in">document</span>.addEventListener( <span class="string">"DOMContentLoaded"</span>, resolve );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">domready.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// DOM is ready!</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The “capability extraction” anti-pattern with Promises looks like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ready;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> domready = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// extract the `resolve()` capability</span></span><br><span class="line">	ready = resolve;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">domready.then( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// DOM is ready!</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener( <span class="string">"DOMContentLoaded"</span>, ready );</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> This anti-pattern is an awkward code smell, in my opinion, but some developers like it, for reasons I can’t grasp.</p>
<p><em>asynquence</em> offers an inverted sequence type I call “iterable sequences”, which externalizes the control capability (it’s quite useful in use cases like the <code>domready</code>):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: `domready` here is an *iterator* that</span></span><br><span class="line"><span class="comment">// controls the sequence</span></span><br><span class="line"><span class="keyword">var</span> domready = ASQ.iterable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">domready.val( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// DOM is ready</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener( <span class="string">"DOMContentLoaded"</span>, domready.next );</span><br></pre></td></tr></table></figure>
<p>There’s more to iterable sequences than what we see in this scenario. We’ll come back to them in Appendix B.</p>
<h2 id="Running-Generators"><a href="#Running-Generators" class="headerlink" title="Running Generators"></a>Running Generators</h2><p>In Chapter 4, we derived a utility called <code>run(..)</code> which can run generators to completion, listening for <code>yield</code>ed Promises and using them to async resume the generator. <em>asynquence</em> has just such a utility built in, called <code>runner(..)</code>.</p>
<p>Let’s first set up some helpers for illustration:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doublePr</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			resolve( x * <span class="number">2</span> );</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleSeq</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			done( x * <span class="number">2</span>)</span><br><span class="line">		&#125;, <span class="number">100</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, we can use <code>runner(..)</code> as a step in the middle of a sequence:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ASQ( <span class="number">10</span>, <span class="number">11</span> )</span><br><span class="line">.runner( <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = token.messages[<span class="number">0</span>] + token.messages[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// yield a real promise</span></span><br><span class="line">	x = <span class="keyword">yield</span> doublePr( x );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// yield a sequence</span></span><br><span class="line">	x = <span class="keyword">yield</span> doubleSeq( x );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );			<span class="comment">// 84</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h3 id="Wrapped-Generators"><a href="#Wrapped-Generators" class="headerlink" title="Wrapped Generators"></a>Wrapped Generators</h3><p>You can also create a self-packaged generator – that is, a normal function that runs your specified generator and returns a sequence for its completion – by <code>ASQ.wrap(..)</code>ing it:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = ASQ.wrap( <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = token.messages[<span class="number">0</span>] + token.messages[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// yield a real promise</span></span><br><span class="line">	x = <span class="keyword">yield</span> doublePr( x );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// yield a sequence</span></span><br><span class="line">	x = <span class="keyword">yield</span> doubleSeq( x );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;, &#123; <span class="attr">gen</span>: <span class="literal">true</span> &#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">foo( <span class="number">8</span>, <span class="number">9</span> )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );			<span class="comment">// 68</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>There’s a lot more awesome that <code>runner(..)</code> is capable of, but we’ll come back to that in Appendix B.</p>
<h2 id="Review-6"><a href="#Review-6" class="headerlink" title="Review"></a>Review</h2><p><em>asynquence</em> is a simple abstraction – a sequence is a series of (async) steps – on top of Promises, aimed at making working with various asynchronous patterns much easier, without any compromise in capability.</p>
<p>There are other goodies in the <em>asynquence</em> core API and its contrib plug-ins beyond what we saw in this appendix, but we’ll leave that as an exercise for the reader to go check the rest of the capabilities out.</p>
<p>You’ve now seen the essence and spirit of <em>asynquence</em>. The key take away is that a sequence is comprised of steps, and those steps can be any of dozens of different variations on Promises, or they can be a generator-run, or… The choice is up to you, you have all the freedom to weave together whatever async flow control logic is appropriate for your tasks. No more library switching to catch different async patterns.</p>
<p>If these <em>asynquence</em> snippets have made sense to you, you’re now pretty well up to speed on the library; it doesn’t take that much to learn, actually!</p>
<p>If you’re still a little fuzzy on how it works (or why!), you’ll want to spend a little more time examining the previous examples and playing around with <em>asynquence</em> yourself, before going on to the next appendix. Appendix B will push <em>asynquence</em> into several more advanced and powerful async patterns.</p>
<h1 id="Appendix-B-Advanced-Async-Patterns"><a href="#Appendix-B-Advanced-Async-Patterns" class="headerlink" title="Appendix B: Advanced Async Patterns"></a>Appendix B: Advanced Async Patterns</h1><p>Appendix A introduced the <em>asynquence</em> library for sequence-oriented async flow control, primarily based on Promises and generators.</p>
<p>Now we’ll explore other advanced asynchronous patterns built on top of that existing understanding and functionality, and see how <em>asynquence</em> makes those sophisticated async techniques easy to mix and match in our programs without needing lots of separate libraries.</p>
<h2 id="Iterable-Sequences-1"><a href="#Iterable-Sequences-1" class="headerlink" title="Iterable Sequences"></a>Iterable Sequences</h2><p>We introduced <em>asynquence</em>‘s iterable sequences in the previous appendix, but we want to revisit them in more detail.</p>
<p>To refresh, recall:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domready = ASQ.iterable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">domready.val( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// DOM is ready</span></span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener( <span class="string">"DOMContentLoaded"</span>, domready.next );</span><br></pre></td></tr></table></figure>
<p>Now, let’s define a sequence of multiple steps as an iterable sequence:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> steps = ASQ.iterable();</span><br><span class="line"></span><br><span class="line">steps</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP1</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP2</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP3</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">4</span>;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">steps.next( <span class="number">8</span> ).value;	<span class="comment">// 16</span></span><br><span class="line">steps.next( <span class="number">16</span> ).value;	<span class="comment">// 19</span></span><br><span class="line">steps.next( <span class="number">19</span> ).value;	<span class="comment">// 76</span></span><br><span class="line">steps.next().done;		<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>As you can see, an iterable sequence is a standard-compliant <em>iterator</em> (see Chapter 4). So, it can be iterated with an ES6 <code>for..of</code> loop, just like a generator (or any other <em>iterable</em>) can:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> steps = ASQ.iterable();</span><br><span class="line"></span><br><span class="line">steps</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP1</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP2</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP3</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">6</span>; &#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP4</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP5</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> steps) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 4 6 8 10</span></span><br></pre></td></tr></table></figure>
<p>Beyond the event triggering example shown in the previous appendix, iterable sequences are interesting because in essence they can be seen as a stand-in for generators or Promise chains, but with even more flexibility.</p>
<p>Consider a multiple Ajax request example – we’ve seen the same scenario in Chapters 3 and 4, both as a Promise chain and as a generator, respectively – expressed as an iterable sequence:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequence-aware ajax</span></span><br><span class="line"><span class="keyword">var</span> request = ASQ.wrap( ajax );</span><br><span class="line"></span><br><span class="line">ASQ( <span class="string">"http://some.url.1"</span> )</span><br><span class="line">.runner(</span><br><span class="line">	ASQ.iterable()</span><br><span class="line"></span><br><span class="line">	.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP1</span>(<span class="params">token</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> url = token.messages[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">return</span> request( url );</span><br><span class="line">	&#125; )</span><br><span class="line"></span><br><span class="line">	.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP2</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ASQ().gate(</span><br><span class="line">			request( <span class="string">"http://some.url.2/?v="</span> + resp ),</span><br><span class="line">			request( <span class="string">"http://some.url.3/?v="</span> + resp )</span><br><span class="line">		);</span><br><span class="line">	&#125; )</span><br><span class="line"></span><br><span class="line">	.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP3</span>(<span class="params">r1,r2</span>)</span>&#123; <span class="keyword">return</span> r1 + r2; &#125; )</span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The iterable sequence expresses a sequential series of (sync or async) steps that looks awfully similar to a Promise chain – in other words, it’s much cleaner looking than just plain nested callbacks, but not quite as nice as the <code>yield</code>-based sequential syntax of generators.</p>
<p>But we pass the iterable sequence into <code>ASQ#runner(..)</code>, which runs it to completion the same as if it was a generator. The fact that an iterable sequence behaves essentially the same as a generator is notable for a couple of reasons.</p>
<p>First, iterable sequences are kind of a pre-ES6 equivalent to a certain subset of ES6 generators, which means you can either author them directly (to run anywhere), or you can author ES6 generators and transpile/convert them to iterable sequences (or Promise chains for that matter!).</p>
<p>Thinking of an async-run-to-completion generator as just syntactic sugar for a Promise chain is an important recognition of their isomorphic relationship.</p>
<p>Before we move on, we should note that the previous snippet could have been expressed in <em>asynquence</em> as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ASQ( <span class="string">"http://some.url.1"</span> )</span><br><span class="line">.seq( <span class="comment">/*STEP 1*/</span> request )</span><br><span class="line">.seq( <span class="function"><span class="keyword">function</span> <span class="title">STEP2</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ASQ().gate(</span><br><span class="line">		request( <span class="string">"http://some.url.2/?v="</span> + resp ),</span><br><span class="line">		request( <span class="string">"http://some.url.3/?v="</span> + resp )</span><br><span class="line">	);</span><br><span class="line">&#125; )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span> <span class="title">STEP3</span>(<span class="params">r1,r2</span>)</span>&#123; <span class="keyword">return</span> r1 + r2; &#125; )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Moreover, step 2 could have even been expressed as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.gate(</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">STEP2a</span>(<span class="params">done,resp</span>) </span>&#123;</span><br><span class="line">		request( <span class="string">"http://some.url.2/?v="</span> + resp )</span><br><span class="line">		.pipe( done );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">STEP2b</span>(<span class="params">done,resp</span>) </span>&#123;</span><br><span class="line">		request( <span class="string">"http://some.url.3/?v="</span> + resp )</span><br><span class="line">		.pipe( done );</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>So, why would we go to the trouble of expressing our flow control as an iterable sequence in a <code>ASQ#runner(..)</code> step, when it seems like a simpler/flatter <em>asyquence</em> chain does the job well?</p>
<p>Because the iterable sequence form has an important trick up its sleeve that gives us more capability. Read on.</p>
<h3 id="Extending-Iterable-Sequences"><a href="#Extending-Iterable-Sequences" class="headerlink" title="Extending Iterable Sequences"></a>Extending Iterable Sequences</h3><p>Generators, normal <em>asynquence</em> sequences, and Promise chains, are all <strong>eagerly evaluated</strong> – whatever flow control is expressed initially <em>is</em> the fixed flow that will be followed.</p>
<p>However, iterable sequences are <strong>lazily evaluated</strong>, which means that during execution of the iterable sequence, you can extend the sequence with more steps if desired.</p>
<p><strong>Note:</strong> You can only append to the end of an iterable sequence, not inject into the middle of the sequence.</p>
<p>Let’s first look at a simpler (synchronous) example of that capability to get familiar with it:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	x *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// should we keep extending?</span></span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">500</span>) &#123;</span><br><span class="line">		isq.then( double );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup single-step iterable sequence</span></span><br><span class="line"><span class="keyword">var</span> isq = ASQ.iterable().then( double );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">10</span>, ret;</span><br><span class="line">	(ret = isq.next( v )) &amp;&amp; !ret.done;</span><br><span class="line">) &#123;</span><br><span class="line">	v = ret.value;</span><br><span class="line">	<span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The iterable sequence starts out with only one defined step (<code>isq.then(double)</code>), but the sequence keeps extending itself under certain conditions (<code>x &lt; 500</code>). Both <em>asynquence</em> sequences and Promise chains technically <em>can</em> do something similar, but we’ll see in a little bit why their capability is insufficient.</p>
<p>Though this example is rather trivial and could otherwise be expressed with a <code>while</code> loop in a generator, we’ll consider more sophisticated cases.</p>
<p>For instance, you could examine the response from an Ajax request and if it indicates that more data is needed, you conditionally insert more steps into the iterable sequence to make the additional request(s). Or you could conditionally add a value-formatting step to the end of your Ajax handling.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> steps = ASQ.iterable()</span><br><span class="line"></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP1</span>(<span class="params">token</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> url = token.messages[<span class="number">0</span>].url;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// was an additional formatting step provided?</span></span><br><span class="line">	<span class="keyword">if</span> (token.messages[<span class="number">0</span>].format) &#123;</span><br><span class="line">		steps.then( token.messages[<span class="number">0</span>].format );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> request( url );</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP2</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// add another Ajax request to the sequence?</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="regexp">/x1/</span>.test( resp )) &#123;</span><br><span class="line">		steps.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP5</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> request(</span><br><span class="line">				<span class="string">"http://some.url.4/?v="</span> + text</span><br><span class="line">			);</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ASQ().gate(</span><br><span class="line">		request( <span class="string">"http://some.url.2/?v="</span> + resp ),</span><br><span class="line">		request( <span class="string">"http://some.url.3/?v="</span> + resp )</span><br><span class="line">	);</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line">.then( <span class="function"><span class="keyword">function</span> <span class="title">STEP3</span>(<span class="params">r1,r2</span>)</span>&#123; <span class="keyword">return</span> r1 + r2; &#125; );</span><br></pre></td></tr></table></figure>
<p>You can see in two different places where we conditionally extend <code>steps</code> with <code>steps.then(..)</code>. And to run this <code>steps</code> iterable sequence, we just wire it into our main program flow with an <em>asynquence</em> sequence (called <code>main</code> here) using <code>ASQ#runner(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> main = ASQ( &#123;</span><br><span class="line">	url: <span class="string">"http://some.url.1"</span>,</span><br><span class="line">	format: <span class="function"><span class="keyword">function</span> <span class="title">STEP4</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> text.toUpperCase();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; )</span><br><span class="line">.runner( steps )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Can the flexibility (conditional behavior) of the <code>steps</code> iterable sequence be expressed with a generator? Kind of, but we have to rearrange the logic in a slightly awkward way:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">steps</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// **STEP 1**</span></span><br><span class="line">	<span class="keyword">var</span> resp = <span class="keyword">yield</span> request( token.messages[<span class="number">0</span>].url );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// **STEP 2**</span></span><br><span class="line">	<span class="keyword">var</span> rvals = <span class="keyword">yield</span> ASQ().gate(</span><br><span class="line">		request( <span class="string">"http://some.url.2/?v="</span> + resp ),</span><br><span class="line">		request( <span class="string">"http://some.url.3/?v="</span> + resp )</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// **STEP 3**</span></span><br><span class="line">	<span class="keyword">var</span> text = rvals[<span class="number">0</span>] + rvals[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// **STEP 4**</span></span><br><span class="line">	<span class="comment">// was an additional formatting step provided?</span></span><br><span class="line">	<span class="keyword">if</span> (token.messages[<span class="number">0</span>].format) &#123;</span><br><span class="line">		text = <span class="keyword">yield</span> token.messages[<span class="number">0</span>].format( text );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// **STEP 5**</span></span><br><span class="line">	<span class="comment">// need another Ajax request added to the sequence?</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="regexp">/foobar/</span>.test( resp )) &#123;</span><br><span class="line">		text = <span class="keyword">yield</span> request(</span><br><span class="line">			<span class="string">"http://some.url.4/?v="</span> + text</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: `*steps()` can be run by the same `ASQ` sequence</span></span><br><span class="line"><span class="comment">// as `steps` was previously</span></span><br></pre></td></tr></table></figure>
<p>Setting aside the already identified benefits of the sequential, synchronous-looking syntax of generators (see Chapter 4), the <code>steps</code> logic had to be reordered in the <code>*steps()</code> generator form, to fake the dynamicism of the extendable iterable sequence <code>steps</code>.</p>
<p>What about expressing the functionality with Promises or sequences, though? You <em>can</em> do something like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> steps = something( .. )</span><br><span class="line">.then( .. )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// extending the chain, right?</span></span><br><span class="line">	steps = steps.then( .. );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ..</span></span><br><span class="line">&#125;)</span><br><span class="line">.then( .. );</span><br></pre></td></tr></table></figure>
<p>The problem is subtle but important to grasp. So, consider trying to wire up our <code>steps</code> Promise chain into our main program flow – this time expressed with Promises instead of <em>asynquence</em>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> main = <span class="built_in">Promise</span>.resolve( &#123;</span><br><span class="line">	url: <span class="string">"http://some.url.1"</span>,</span><br><span class="line">	format: <span class="function"><span class="keyword">function</span> <span class="title">STEP4</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> text.toUpperCase();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; )</span><br><span class="line">.then( <span class="function"><span class="keyword">function</span>(<span class="params">..</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> steps;			<span class="comment">// hint!</span></span><br><span class="line">&#125; )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Can you spot the problem now? Look closely!</p>
<p>There’s a race condition for sequence steps ordering. When you <code>return steps</code>, at that moment <code>steps</code> <em>might</em> be the originally defined promise chain, or it might now point to the extended promise chain via the <code>steps = steps.then(..)</code> call, depending on what order things happen.</p>
<p>Here are the two possible outcomes:</p>
<ul>
<li>If <code>steps</code> is still the original promise chain, once it’s later “extended” by <code>steps = steps.then(..)</code>, that extended promise on the end of the chain is <strong>not</strong> considered by the <code>main</code> flow, as it’s already tapped the <code>steps</code> chain. This is the unfortunately limiting <strong>eager evaluation</strong>.</li>
<li>If <code>steps</code> is already the extended promise chain, it works as we expect in that the extended promise is what <code>main</code> taps.</li>
</ul>
<p>Other than the obvious fact that a race condition is intolerable, the first case is the concern; it illustrates <strong>eager evaluation</strong> of the promise chain. By contrast, we easily extended the iterable sequence without such issues, because iterable sequences are <strong>lazily evaluated</strong>.</p>
<p>The more dynamic you need your flow control, the more iterable sequences will shine.</p>
<p><strong>Tip:</strong> Check out more information and examples of iterable sequences on the <em>asynquence</em> site (<a href="https://github.com/getify/asynquence/blob/master/README.md#iterable-sequences)" target="_blank" rel="noopener">https://github.com/getify/asynquence/blob/master/README.md#iterable-sequences)</a>.</p>
<h2 id="Event-Reactive"><a href="#Event-Reactive" class="headerlink" title="Event Reactive"></a>Event Reactive</h2><p>It should be obvious from (at least!) Chapter 3 that Promises are a very powerful tool in your async toolbox. But one thing that’s clearly lacking is in their capability to handle streams of events, as a Promise can only be resolved once. And frankly, this exact same weakness is true of plain <em>asynquence</em> sequences, as well.</p>
<p>Consider a scenario where you want to fire off a series of steps every time a certain event is fired. A single Promise or sequence cannot represent all occurrences of that event. So, you have to create a whole new Promise chain (or sequence) for <em>each</em> event occurrence, such as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listener.on( <span class="string">"foobar"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a new event handling promise chain</span></span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// ..</span></span><br><span class="line">	&#125; )</span><br><span class="line">	.then( .. )</span><br><span class="line">	.then( .. );</span><br><span class="line"></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The base functionality we need is present in this approach, but it’s far from a desirable way to express our intended logic. There are two separate capabilities conflated in this paradigm: the event listening, and responding to the event; separation of concerns would implore us to separate out these capabilities.</p>
<p>The carefully observant reader will see this problem as somewhat symmetrical to the problems we detailed with callbacks in Chapter 2; it’s kind of an inversion of control problem.</p>
<p>Imagine uninverting this paradigm, like so:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = listener.on( <span class="string">"foobar"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line">observable</span><br><span class="line">.then( .. )</span><br><span class="line">.then( .. );</span><br><span class="line"></span><br><span class="line"><span class="comment">// elsewhere</span></span><br><span class="line">observable</span><br><span class="line">.then( .. )</span><br><span class="line">.then( .. );</span><br></pre></td></tr></table></figure>
<p>The <code>observable</code> value is not exactly a Promise, but you can <em>observe</em> it much like you can observe a Promise, so it’s closely related. In fact, it can be observed many times, and it will send out notifications every time its event (<code>&quot;foobar&quot;</code>) occurs.</p>
<p><strong>Tip:</strong> This pattern I’ve just illustrated is a <strong>massive simplification</strong> of the concepts and motivations behind reactive programming (aka RP), which has been implemented/expounded upon by several great projects and languages. A variation on RP is functional reactive programming (FRP), which refers to applying functional programming techniques (immutability, referential integrity, etc.) to streams of data. “Reactive” refers to spreading this functionality out over time in response to events. The interested reader should consider studying “Reactive Observables” in the fantastic “Reactive Extensions” library (“RxJS” for JavaScript) by Microsoft (<a href="http://rxjs.codeplex.com/)" target="_blank" rel="noopener">http://rxjs.codeplex.com/)</a>; it’s much more sophisticated and powerful than I’ve just shown. Also, Andre Staltz has an excellent write-up (<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a>) that pragmatically lays out RP in concrete examples.</p>
<h3 id="ES7-Observables"><a href="#ES7-Observables" class="headerlink" title="ES7 Observables"></a>ES7 Observables</h3><p>At the time of this writing, there’s an early ES7 proposal for a new data type called “Observable” (<a href="https://github.com/jhusain/asyncgenerator#introducing-observable)" target="_blank" rel="noopener">https://github.com/jhusain/asyncgenerator#introducing-observable)</a>, which in spirit is similar to what we’ve laid out here, but is definitely more sophisticated.</p>
<p>The notion of this kind of Observable is that the way you “subscribe” to the events from a stream is to pass in a generator – actually the <em>iterator</em> is the interested party – whose <code>next(..)</code> method will be called for each event.</p>
<p>You could imagine it sort of like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `someEventStream` is a stream of events, like from</span></span><br><span class="line"><span class="comment">// mouse clicks, and the like.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> Observer( someEventStream, <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">var</span> evt = <span class="keyword">yield</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( evt );</span><br><span class="line">	&#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The generator you pass in will <code>yield</code> pause the <code>while</code> loop waiting for the next event. The <em>iterator</em> attached to the generator instance will have its <code>next(..)</code> called each time <code>someEventStream</code> has a new event published, and so that event data will resume your generator/<em>iterator</em> with the <code>evt</code> data.</p>
<p>In the subscription to events functionality here, it’s the <em>iterator</em> part that matters, not the generator. So conceptually you could pass in practically any iterable, including <code>ASQ.iterable()</code> iterable sequences.</p>
<p>Interestingly, there are also proposed adapters to make it easy to construct Observables from certain types of streams, such as <code>fromEvent(..)</code> for DOM events. If you look at a suggested implementation of <code>fromEvent(..)</code> in the earlier linked ES7 proposal, it looks an awful lot like the <code>ASQ.react(..)</code> we’ll see in the next section.</p>
<p>Of course, these are all early proposals, so what shakes out may very well look/behave differently than shown here. But it’s exciting to see the early alignments of concepts across different libraries and language proposals!</p>
<h3 id="Reactive-Sequences"><a href="#Reactive-Sequences" class="headerlink" title="Reactive Sequences"></a>Reactive Sequences</h3><p>With that crazy brief summary of Observables (and F/RP) as our inspiration and motivation, I will now illustrate an adaptation of a small subset of “Reactive Observables,” which I call “Reactive Sequences.”</p>
<p>First, let’s start with how to create an Observable, using an <em>asynquence</em> plug-in utility called <code>react(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = ASQ.react( <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">	listener.on( <span class="string">"foobar"</span>, next );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Now, let’s see how to define a sequence that “reacts” – in F/RP, this is typically called “subscribing” – to that <code>observable</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">observable</span><br><span class="line">.seq( .. )</span><br><span class="line">.then( .. )</span><br><span class="line">.val( .. );</span><br></pre></td></tr></table></figure>
<p>So, you just define the sequence by chaining off the Observable. That’s easy, huh?</p>
<p>In F/RP, the stream of events typically channels through a set of functional transforms, like <code>scan(..)</code>, <code>map(..)</code>, <code>reduce(..)</code>, and so on. With reactive sequences, each event channels through a new instance of the sequence. Let’s look at a more concrete example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ASQ.react( <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.getElementById( <span class="string">"mybtn"</span> )</span><br><span class="line">	.addEventListener( <span class="string">"click"</span>, next, <span class="literal">false</span> );</span><br><span class="line">&#125; )</span><br><span class="line">.seq( <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> btnID = evt.target.id;</span><br><span class="line">	<span class="keyword">return</span> request(</span><br><span class="line">		<span class="string">"http://some.url.1/?id="</span> + btnID</span><br><span class="line">	);</span><br><span class="line">&#125; )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( text );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The “reactive” portion of the reactive sequence comes from assigning one or more event handlers to invoke the event trigger (calling <code>next(..)</code>).</p>
<p>The “sequence” portion of the reactive sequence is exactly like the sequences we’ve already explored: each step can be whatever asynchronous technique makes sense, from continuation callback to Promise to generator.</p>
<p>Once you set up a reactive sequence, it will continue to initiate instances of the sequence as long as the events keep firing. If you want to stop a reactive sequence, you can call <code>stop()</code>.</p>
<p>If a reactive sequence is <code>stop()</code>‘d, you likely want the event handler(s) to be unregistered as well; you can register a teardown handler for this purpose:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq = ASQ.react( <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">next,registerTeardown</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"mybtn"</span> );</span><br><span class="line"></span><br><span class="line">	btn.addEventListener( <span class="string">"click"</span>, next, <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// will be called once `sq.stop()` is called</span></span><br><span class="line">	registerTeardown( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		btn.removeEventListener( <span class="string">"click"</span>, next, <span class="literal">false</span> );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125; )</span><br><span class="line">.seq( .. )</span><br><span class="line">.then( .. )</span><br><span class="line">.val( .. );</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line">sq.stop();</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> The <code>this</code> binding reference inside the <code>setup(..)</code> handler is the same <code>sq</code> reactive sequence, so you can use the <code>this</code> reference to add to the reactive sequence definition, call methods like <code>stop()</code>, and so on.</p>
<p>Here’s an example from the Node.js world, using reactive sequences to handle incoming HTTP requests:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reactive observer</span></span><br><span class="line"><span class="keyword">var</span> request = ASQ.react( <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">next,registerTeardown</span>)</span>&#123;</span><br><span class="line">	server.addListener( <span class="string">"request"</span>, next );</span><br><span class="line">	server.addListener( <span class="string">"close"</span>, <span class="keyword">this</span>.stop );</span><br><span class="line"></span><br><span class="line">	registerTeardown( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		server.removeListener( <span class="string">"request"</span>, next );</span><br><span class="line">		server.removeListener( <span class="string">"close"</span>, request.stop );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// respond to requests</span></span><br><span class="line">request</span><br><span class="line">.seq( pullFromDatabase )</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">data,res</span>)</span>&#123;</span><br><span class="line">	res.end( data );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// node teardown</span></span><br><span class="line">process.on( <span class="string">"SIGINT"</span>, request.stop );</span><br></pre></td></tr></table></figure>
<p>The <code>next(..)</code> trigger can also adapt to node streams easily, using <code>onStream(..)</code> and <code>unStream(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ASQ.react( <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fstream = fs.createReadStream( <span class="string">"/some/file"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pipe the stream's "data" event to `next(..)`</span></span><br><span class="line">	next.onStream( fstream );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// listen for the end of the stream</span></span><br><span class="line">	fstream.on( <span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		next.unStream( fstream );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125; )</span><br><span class="line">.seq( .. )</span><br><span class="line">.then( .. )</span><br><span class="line">.val( .. );</span><br></pre></td></tr></table></figure>
<p>You can also use sequence combinations to compose multiple reactive sequence streams:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sq1 = ASQ.react( .. ).seq( .. ).then( .. );</span><br><span class="line"><span class="keyword">var</span> sq2 = ASQ.react( .. ).seq( .. ).then( .. );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sq3 = ASQ.react(..)</span><br><span class="line">.gate(</span><br><span class="line">	sq1,</span><br><span class="line">	sq2</span><br><span class="line">)</span><br><span class="line">.then( .. );</span><br></pre></td></tr></table></figure>
<p>The main takeaway is that <code>ASQ.react(..)</code> is a lightweight adaptation of F/RP concepts, enabling the wiring of an event stream to a sequence, hence the term “reactive sequence.” Reactive sequences are generally capable enough for basic reactive uses.</p>
<p><strong>Note:</strong> Here’s an example of using <code>ASQ.react(..)</code> in managing UI state (<a href="http://jsbin.com/rozipaki/6/edit?js,output)" target="_blank" rel="noopener">http://jsbin.com/rozipaki/6/edit?js,output)</a>, and another example of handling HTTP request/response streams with <code>ASQ.react(..)</code> (<a href="https://gist.github.com/getify/bba5ec0de9d6047b720e)" target="_blank" rel="noopener">https://gist.github.com/getify/bba5ec0de9d6047b720e)</a>.</p>
<h2 id="Generator-Coroutine"><a href="#Generator-Coroutine" class="headerlink" title="Generator Coroutine"></a>Generator Coroutine</h2><p>Hopefully Chapter 4 helped you get pretty familiar with ES6 generators. In particular, we want to revisit the “Generator Concurrency” discussion, and push it even further.</p>
<p>We imagined a <code>runAll(..)</code> utility that could take two or more generators and run them concurrently, letting them cooperatively <code>yield</code> control from one to the next, with optional message passing.</p>
<p>In addition to being able to run a single generator to completion, the <code>ASQ#runner(..)</code> we discussed in Appendix A is a similar implementation of the concepts of <code>runAll(..)</code>, which can run multiple generators concurrently to completion.</p>
<p>So let’s see how we can implement the concurrent Ajax scenario from Chapter 4:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ASQ(</span><br><span class="line">	<span class="string">"http://some.url.2"</span></span><br><span class="line">)</span><br><span class="line">.runner(</span><br><span class="line">	<span class="function"><span class="keyword">function</span>*(<span class="params">token</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// transfer control</span></span><br><span class="line">		<span class="keyword">yield</span> token;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> url1 = token.messages[<span class="number">0</span>]; <span class="comment">// "http://some.url.1"</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// clear out messages to start fresh</span></span><br><span class="line">		token.messages = [];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> p1 = request( url1 );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// transfer control</span></span><br><span class="line">		<span class="keyword">yield</span> token;</span><br><span class="line"></span><br><span class="line">		token.messages.push( <span class="keyword">yield</span> p1 );</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="keyword">function</span>*(<span class="params">token</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> url2 = token.messages[<span class="number">0</span>]; <span class="comment">// "http://some.url.2"</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// message pass and transfer control</span></span><br><span class="line">		token.messages[<span class="number">0</span>] = <span class="string">"http://some.url.1"</span>;</span><br><span class="line">		<span class="keyword">yield</span> token;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> p2 = request( url2 );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// transfer control</span></span><br><span class="line">		<span class="keyword">yield</span> token;</span><br><span class="line"></span><br><span class="line">		token.messages.push( <span class="keyword">yield</span> p2 );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// pass along results to next sequence step</span></span><br><span class="line">		<span class="keyword">return</span> token.messages;</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// `res[0]` comes from "http://some.url.1"</span></span><br><span class="line">	<span class="comment">// `res[1]` comes from "http://some.url.2"</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The main differences between <code>ASQ#runner(..)</code> and <code>runAll(..)</code> are as follows:</p>
<ul>
<li>Each generator (coroutine) is provided an argument we call <code>token</code>, which is the special value to <code>yield</code> when you want to explicitly transfer control to the next coroutine.</li>
<li><code>token.messages</code> is an array that holds any messages passed in from the previous sequence step. It’s also a data structure that you can use to share messages between coroutines.</li>
<li><code>yield</code>ing a Promise (or sequence) value does not transfer control, but instead pauses the coroutine processing until that value is ready.</li>
<li>The last <code>return</code>ed or <code>yield</code>ed value from the coroutine processing run will be forward passed to the next step in the sequence.</li>
</ul>
<p>It’s also easy to layer helpers on top of the base <code>ASQ#runner(..)</code> functionality to suit different uses.</p>
<h3 id="State-Machines"><a href="#State-Machines" class="headerlink" title="State Machines"></a>State Machines</h3><p>One example that may be familiar to many programmers is state machines. You can, with the help of a simple cosmetic utility, create an easy-to-express state machine processor.</p>
<p>Let’s imagine such a utility. We’ll call it <code>state(..)</code>, and will pass it two arguments: a state value and a generator that handles that state. <code>state(..)</code> will do the dirty work of creating and returning an adapter generator to pass to <code>ASQ#runner(..)</code>.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">state</span>(<span class="params">val,handler</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// make a coroutine handler for this state</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// state transition handler</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">transition</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">			token.messages[<span class="number">0</span>] = to;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// set initial state (if none set yet)</span></span><br><span class="line">		<span class="keyword">if</span> (token.messages.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			token.messages[<span class="number">0</span>] = val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// keep going until final state (false) is reached</span></span><br><span class="line">		<span class="keyword">while</span> (token.messages[<span class="number">0</span>] !== <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="comment">// current state matches this handler?</span></span><br><span class="line">			<span class="keyword">if</span> (token.messages[<span class="number">0</span>] === val) &#123;</span><br><span class="line">				<span class="comment">// delegate to state handler</span></span><br><span class="line">				<span class="keyword">yield</span> *handler( transition );</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// transfer control to another state handler?</span></span><br><span class="line">			<span class="keyword">if</span> (token.messages[<span class="number">0</span>] !== <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">yield</span> token;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you look closely, you’ll see that <code>state(..)</code> returns back a generator that accepts a <code>token</code>, and then it sets up a <code>while</code> loop that will run until the state machine reaches its final state (which we arbitrarily pick as the <code>false</code> value); that’s exactly the kind of generator we want to pass to <code>ASQ#runner(..)</code>!</p>
<p>We also arbitrarily reserve the <code>token.messages[0]</code> slot as the place where the current state of our state machine will be tracked, which means we can even seed the initial state as the value passed in from the previous step in the sequence.</p>
<p>How do we use the <code>state(..)</code> helper along with <code>ASQ#runner(..)</code>?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prevState;</span><br><span class="line"></span><br><span class="line">ASQ(</span><br><span class="line">	<span class="comment">/* optional: initial state value */</span></span><br><span class="line">	<span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// run our state machine</span></span><br><span class="line"><span class="comment">// transitions: 2 -&gt; 3 -&gt; 1 -&gt; 3 -&gt; false</span></span><br><span class="line">.runner(</span><br><span class="line">	<span class="comment">// state `1` handler</span></span><br><span class="line">	state( <span class="number">1</span>, <span class="function"><span class="keyword">function</span> *<span class="title">stateOne</span>(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"in state 1"</span> );</span><br><span class="line"></span><br><span class="line">		prevState = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">yield</span> transition( <span class="number">3</span> );	<span class="comment">// goto state `3`</span></span><br><span class="line">	&#125; ),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// state `2` handler</span></span><br><span class="line">	state( <span class="number">2</span>, <span class="function"><span class="keyword">function</span> *<span class="title">stateTwo</span>(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"in state 2"</span> );</span><br><span class="line"></span><br><span class="line">		prevState = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">yield</span> transition( <span class="number">3</span> );	<span class="comment">// goto state `3`</span></span><br><span class="line">	&#125; ),</span><br><span class="line"></span><br><span class="line">	<span class="comment">// state `3` handler</span></span><br><span class="line">	state( <span class="number">3</span>, <span class="function"><span class="keyword">function</span> *<span class="title">stateThree</span>(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"in state 3"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prevState === <span class="number">2</span>) &#123;</span><br><span class="line">			prevState = <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">yield</span> transition( <span class="number">1</span> ); <span class="comment">// goto state `1`</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// all done!</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">yield</span> <span class="string">"That's all folks!"</span>;</span><br><span class="line"></span><br><span class="line">			prevState = <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">yield</span> transition( <span class="literal">false</span> ); <span class="comment">// terminal state</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; )</span><br><span class="line">)</span><br><span class="line"><span class="comment">// state machine complete, so move on</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( msg );	<span class="comment">// That's all folks!</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>It’s important to note that the <code>*stateOne(..)</code>, <code>*stateTwo(..)</code>, and <code>*stateThree(..)</code> generators themselves are reinvoked each time that state is entered, and they finish when you <code>transition(..)</code> to another value. While not shown here, of course these state generator handlers can be asynchronously paused by <code>yield</code>ing Promises/sequences/thunks.</p>
<p>The underneath hidden generators produced by the <code>state(..)</code> helper and actually passed to <code>ASQ#runner(..)</code> are the ones that continue to run concurrently for the length of the state machine, and each of them handles cooperatively <code>yield</code>ing control to the next, and so on.</p>
<p><strong>Note:</strong> See this “ping pong” example (<a href="http://jsbin.com/qutabu/1/edit?js,output" target="_blank" rel="noopener">http://jsbin.com/qutabu/1/edit?js,output</a>) for more illustration of using cooperative concurrency with generators driven by <code>ASQ#runner(..)</code>.</p>
<h2 id="Communicating-Sequential-Processes-CSP"><a href="#Communicating-Sequential-Processes-CSP" class="headerlink" title="Communicating Sequential Processes (CSP)"></a>Communicating Sequential Processes (CSP)</h2><p>“Communicating Sequential Processes” (CSP) was first described by C. A. R. Hoare in a 1978 academic paper (<a href="http://dl.acm.org/citation.cfm?doid=359576.359585)" target="_blank" rel="noopener">http://dl.acm.org/citation.cfm?doid=359576.359585)</a>, and later in a 1985 book (<a href="http://www.usingcsp.com/" target="_blank" rel="noopener">http://www.usingcsp.com/</a>) of the same name. CSP describes a formal method for concurrent “processes” to interact (aka “communicate”) during processing.</p>
<p>You may recall that we examined concurrent “processes” back in Chapter 1, so our exploration of CSP here will build upon that understanding.</p>
<p>Like most great concepts in computer science, CSP is heavily steeped in academic formalism, expressed as a process algebra. However, I suspect symbolic algebra theorems won’t make much practical difference to the reader, so we will want to find some other way of wrapping our brains around CSP.</p>
<p>I will leave much of the formal description and proof of CSP to Hoare’s writing, and to many other fantastic writings since. Instead, we will try to just briefly explain the idea of CSP in as un-academic and hopefully intuitively understandable a way as possible.</p>
<h3 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h3><p>The core principle in CSP is that all communication/interaction between otherwise independent processes must be through formal message passing. Perhaps counter to your expectations, CSP message passing is described as a synchronous action, where the sender process and the receiver process have to mutually be ready for the message to be passed.</p>
<p>How could such synchronous messaging possibly be related to asynchronous programming in JavaScript?</p>
<p>The concreteness of relationship comes from the nature of how ES6 generators are used to produce synchronous-looking actions that under the covers can indeed either be synchronous or (more likely) asynchronous.</p>
<p>In other words, two or more concurrently running generators can appear to synchronously message each other while preserving the fundamental asynchrony of the system because each generator’s code is paused (aka “blocked”) waiting on resumption of an asynchronous action.</p>
<p>How does this work?</p>
<p>Imagine a generator (aka “process”) called “A” that wants to send a message to generator “B.” First, “A” <code>yield</code>s the message (thus pausing “A”) to be sent to “B.” When “B” is ready and takes the message, “A” is then resumed (unblocked).</p>
<p>Symmetrically, imagine a generator “A” that wants a message <strong>from</strong> “B.” “A” <code>yield</code>s its request (thus pausing “A”) for the message from “B,” and once “B” sends a message, “A” takes the message and is resumed.</p>
<p>One of the more popular expressions of this CSP message passing theory comes from ClojureScript’s core.async library, and also from the <em>go</em> language. These takes on CSP embody the described communication semantics in a conduit that is opened between processes called a “channel.”</p>
<p><strong>Note:</strong> The term <em>channel</em> is used in part because there are modes in which more than one value can be sent at once into the “buffer” of the channel; this is similar to what you may think of as a stream. We won’t go into depth about it here, but it can be a very powerful technique for managing streams of data.</p>
<p>In the simplest notion of CSP, a channel that we create between “A” and “B” would have a method called <code>take(..)</code> for blocking to receive a value, and a method called <code>put(..)</code> for blocking to send a value.</p>
<p>This might look like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = channel();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> msg = <span class="keyword">yield</span> take( ch );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> put( ch, <span class="string">"Hello World"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"message sent"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run( foo );</span><br><span class="line">run( bar );</span><br><span class="line"><span class="comment">// Hello World</span></span><br><span class="line"><span class="comment">// "message sent"</span></span><br></pre></td></tr></table></figure>
<p>Compare this structured, synchronous(-looking) message passing interaction to the informal and unstructured message sharing that <code>ASQ#runner(..)</code> provides through the <code>token.messages</code> array and cooperative <code>yield</code>ing. In essence, <code>yield put(..)</code> is a single operation that both sends the value and pauses execution to transfer control, whereas in earlier examples we did those as separate steps.</p>
<p>Moreover, CSP stresses that you don’t really explicitly “transfer control,” but rather you design your concurrent routines to block expecting either a value received from the channel, or to block expecting to try to send a message on the channel. The blocking around receiving or sending messages is how you coordinate sequencing of behavior between the coroutines.</p>
<p><strong>Note:</strong> Fair warning: this pattern is very powerful but it’s also a little mind twisting to get used to at first. You will want to practice this a bit to get used to this new way of thinking about coordinating your concurrency.</p>
<p>There are several great libraries that have implemented this flavor of CSP in JavaScript, most notably “js-csp” (<a href="https://github.com/ubolonton/js-csp)" target="_blank" rel="noopener">https://github.com/ubolonton/js-csp)</a>, which James Long (<a href="http://twitter.com/jlongster" target="_blank" rel="noopener">http://twitter.com/jlongster</a>) forked (<a href="https://github.com/jlongster/js-csp" target="_blank" rel="noopener">https://github.com/jlongster/js-csp</a>) and has written extensively about (<a href="http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript)" target="_blank" rel="noopener">http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript)</a>. Also, it cannot be stressed enough how amazing the many writings of David Nolen (<a href="http://twitter.com/swannodette" target="_blank" rel="noopener">http://twitter.com/swannodette</a>) are on the topic of adapting ClojureScript’s go-style core.async CSP into JS generators (<a href="http://swannodette.github.io/2013/08/24/es6-generators-and-csp)" target="_blank" rel="noopener">http://swannodette.github.io/2013/08/24/es6-generators-and-csp)</a>.</p>
<h3 id="asynquence-CSP-emulation"><a href="#asynquence-CSP-emulation" class="headerlink" title="asynquence CSP emulation"></a>asynquence CSP emulation</h3><p>Because we’ve been discussing async patterns here in the context of my <em>asynquence</em> library, you might be interested to see that we can fairly easily add an emulation layer on top of <code>ASQ#runner(..)</code> generator handling as a nearly perfect porting of the CSP API and behavior. This emulation layer ships as an optional part of the “asynquence-contrib” package alongside <em>asynquence</em>.</p>
<p>Very similar to the <code>state(..)</code> helper from earlier, <code>ASQ.csp.go(..)</code> takes a generator – in go/core.async terms, it’s known as a goroutine – and adapts it to use with <code>ASQ#runner(..)</code> by returning a new generator.</p>
<p>Instead of being passed a <code>token</code>, your goroutine receives an initially created channel (<code>ch</code> below) that all goroutines in this run will share. You can create more channels (which is often quite helpful!) with <code>ASQ.csp.chan(..)</code>.</p>
<p>In CSP, we model all asynchrony in terms of blocking on channel messages, rather than blocking waiting for a Promise/sequence/thunk to complete.</p>
<p>So, instead of <code>yield</code>ing the Promise returned from <code>request(..)</code>, <code>request(..)</code> should return a channel that you <code>take(..)</code> a value from. In other words, a single-value channel is roughly equivalent in this context/usage to a Promise/sequence.</p>
<p>Let’s first make a channel-aware version of <code>request(..)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ch = ASQ.csp.channel();</span><br><span class="line">	ajax( url ).then( <span class="function"><span class="keyword">function</span>(<span class="params">content</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// `putAsync(..)` is a version of `put(..)` that</span></span><br><span class="line">		<span class="comment">// can be used outside of a generator. It returns</span></span><br><span class="line">		<span class="comment">// a promise for the operation's completion. We</span></span><br><span class="line">		<span class="comment">// don't use that promise here, but we could if</span></span><br><span class="line">		<span class="comment">// we needed to be notified when the value had</span></span><br><span class="line">		<span class="comment">// been `take(..)`n.</span></span><br><span class="line">		ASQ.csp.putAsync( ch, content );</span><br><span class="line">	&#125; );</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From Chapter 3, “promisory” is a Promise-producing utility, “thunkory” from Chapter 4 is a thunk-producing utility, and finally, in Appendix A we invented “sequory” for a sequence-producing utility.</p>
<p>Naturally, we need to coin a symmetric term here for a channel-producing utility. So let’s unsurprisingly call it a “chanory” (“channel” + “factory”). As an exercise for the reader, try your hand at defining a <code>channelify(..)</code> utility similar to <code>Promise.wrap(..)</code>/<code>promisify(..)</code> (Chapter 3), <code>thunkify(..)</code> (Chapter 4), and <code>ASQ.wrap(..)</code> (Appendix A).</p>
<p>Now consider the concurrent Ajax example using <em>asyquence</em>-flavored CSP:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ASQ()</span><br><span class="line">.runner(</span><br><span class="line">	ASQ.csp.go( <span class="function"><span class="keyword">function</span>*(<span class="params">ch</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">yield</span> ASQ.csp.put( ch, <span class="string">"http://some.url.2"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> url1 = <span class="keyword">yield</span> ASQ.csp.take( ch );</span><br><span class="line">		<span class="comment">// "http://some.url.1"</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> res1 = <span class="keyword">yield</span> ASQ.csp.take( request( url1 ) );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">yield</span> ASQ.csp.put( ch, res1 );</span><br><span class="line">	&#125; ),</span><br><span class="line">	ASQ.csp.go( <span class="function"><span class="keyword">function</span>*(<span class="params">ch</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> url2 = <span class="keyword">yield</span> ASQ.csp.take( ch );</span><br><span class="line">		<span class="comment">// "http://some.url.2"</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">yield</span> ASQ.csp.put( ch, <span class="string">"http://some.url.1"</span> );</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> res2 = <span class="keyword">yield</span> ASQ.csp.take( request( url2 ) );</span><br><span class="line">		<span class="keyword">var</span> res1 = <span class="keyword">yield</span> ASQ.csp.take( ch );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// pass along results to next sequence step</span></span><br><span class="line">		ch.buffer_size = <span class="number">2</span>;</span><br><span class="line">		ASQ.csp.put( ch, res1 );</span><br><span class="line">		ASQ.csp.put( ch, res2 );</span><br><span class="line">	&#125; )</span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">res1,res2</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// `res1` comes from "http://some.url.1"</span></span><br><span class="line">	<span class="comment">// `res2` comes from "http://some.url.2"</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>The message passing that trades the URL strings between the two goroutines is pretty straightforward. The first goroutine makes an Ajax request to the first URL, and that response is put onto the <code>ch</code> channel. The second goroutine makes an Ajax request to the second URL, then gets the first response <code>res1</code> off the <code>ch</code> channel. At that point, both responses <code>res1</code> and <code>res2</code> are completed and ready.</p>
<p>If there are any remaining values in the <code>ch</code> channel at the end of the goroutine run, they will be passed along to the next step in the sequence. So, to pass out message(s) from the final goroutine, <code>put(..)</code> them into <code>ch</code>. As shown, to avoid the blocking of those final <code>put(..)</code>s, we switch <code>ch</code> into buffering mode by setting its <code>buffer_size</code> to <code>2</code> (default: <code>0</code>).</p>
<p><strong>Note:</strong> See many more examples of using <em>asynquence</em>-flavored CSP here (<a href="https://gist.github.com/getify/e0d04f1f5aa24b1947ae)" target="_blank" rel="noopener">https://gist.github.com/getify/e0d04f1f5aa24b1947ae)</a>.</p>
<h2 id="Review-7"><a href="#Review-7" class="headerlink" title="Review"></a>Review</h2><p>Promises and generators provide the foundational building blocks upon which we can build much more sophisticated and capable asynchrony.</p>
<p><em>asynquence</em> has utilities for implementing <em>iterable sequences</em>, <em>reactive sequences</em> (aka “Observables”), <em>concurrent coroutines</em>, and even <em>CSP goroutines</em>.</p>
<p>Those patterns, combined with the continuation-callback and Promise capabilities, gives <em>asynquence</em> a powerful mix of different asynchronous functionalities, all integrated in one clean async flow control abstraction: the sequence.</p>
<h1 id="Appendix-C-Acknowledgments"><a href="#Appendix-C-Acknowledgments" class="headerlink" title="Appendix C: Acknowledgments"></a>Appendix C: Acknowledgments</h1><p>I have many people to thank for making this book title and the overall series happen.</p>
<p>First, I must thank my wife Christen Simpson, and my two kids Ethan and Emily, for putting up with Dad always pecking away at the computer. Even when not writing books, my obsession with JavaScript glues my eyes to the screen far more than it should. That time I borrow from my family is the reason these books can so deeply and completely explain JavaScript to you, the reader. I owe my family everything.</p>
<p>I’d like to thank my editors at O’Reilly, namely Simon St.Laurent and Brian MacDonald, as well as the rest of the editorial and marketing staff. They are fantastic to work with, and have been especially accommodating during this experiment into “open source” book writing, editing, and production.</p>
<p>Thank you to the many folks who have participated in making this book series better by providing editorial suggestions and corrections, including Shelley Powers, Tim Ferro, Evan Borden, Forrest L. Norvell, Jennifer Davis, Jesse Harlin, Kris Kowal, Rick Waldron, Jordan Harband, Benjamin Gruenbaum, Vyacheslav Egorov, David Nolen, and many others. A big thank you to Jake Archibald for writing the Foreword for this title.</p>
<p>Thank you to the countless folks in the community, including members of the TC39 committee, who have shared so much knowledge with the rest of us, and especially tolerated my incessant questions and explorations with patience and detail. John-David Dalton, Juriy “kangax” Zaytsev, Mathias Bynens, Axel Rauschmayer, Nicholas Zakas, Angus Croll, Reginald Braithwaite, Dave Herman, Brendan Eich, Allen Wirfs-Brock, Bradley Meck, Domenic Denicola, David Walsh, Tim Disney, Peter van der Zee, Andrea Giammarchi, Kit Cambridge, Eric Elliott, and so many others, I can’t even scratch the surface.</p>
<p>The <em>You Don’t Know JS</em> book series was born on Kickstarter, so I also wish to thank all my (nearly) 500 generous backers, without whom this book series could not have happened:</p>
<blockquote>
<p>Jan Szpila, nokiko, Murali Krishnamoorthy, Ryan Joy, Craig Patchett, pdqtrader, Dale Fukami, ray hatfield, R0drigo Perez [Mx], Dan Petitt, Jack Franklin, Andrew Berry, Brian Grinstead, Rob Sutherland, Sergi Meseguer, Phillip Gourley, Mark Watson, Jeff Carouth, Alfredo Sumaran, Martin Sachse, Marcio Barrios, Dan, AimelyneM, Matt Sullivan, Delnatte Pierre-Antoine, Jake Smith, Eugen Tudorancea, Iris, David Trinh, simonstl, Ray Daly, Uros Gruber, Justin Myers, Shai Zonis, Mom &amp; Dad, Devin Clark, Dennis Palmer, Brian Panahi Johnson, Josh Marshall, Marshall, Dennis Kerr, Matt Steele, Erik Slagter, Sacah, Justin Rainbow, Christian Nilsson, Delapouite, D.Pereira, Nicolas Hoizey, George V. Reilly, Dan Reeves, Bruno Laturner, Chad Jennings, Shane King, Jeremiah Lee Cohick, od3n, Stan Yamane, Marko Vucinic, Jim B, Stephen Collins, Ægir Þorsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, Alexandre ELISÉ, Chris Peterson, Rik Watson, Luke Matthews, Justin Lowery, Morten Nielsen, Vernon Kesner, Chetan Shenoy, Paul Tregoing, Marc Grabanski, Dion Almaer, Andrew Sullivan, Keith Elsass, Tom Burke, Brian Ashenfelter, David Stuart, Karl Swedberg, Graeme, Brandon Hays, John Christopher, Gior, manoj reddy, Chad Smith, Jared Harbour, Minoru TODA, Chris Wigley, Daniel Mee, Mike, Handyface, Alex Jahraus, Carl Furrow, Rob Foulkrod, Max Shishkin, Leigh Penny Jr., Robert Ferguson, Mike van Hoenselaar, Hasse Schougaard, rajan venkataguru, Jeff Adams, Trae Robbins, Rolf Langenhuijzen, Jorge Antunes, Alex Koloskov, Hugh Greenish, Tim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish Muvva, Barkóczi Dávid, Kitt Hodsden, Paul McGraw, Sascha Goldhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt Jared, Juanfran, Georgie Kirschner, Kenny Lee, Ted Zhang, Amit Pahwa, Inbal Sinai, Dan Raine, Schabse Laks, Michael Tervoort, Alexandre Abreu, Alan Joseph Williams, NicolasD, Cindy Wong, Reg Braithwaite, LocalPCGuy, Jon Friskics, Chris Merriman, John Pena, Jacob Katz, Sue Lockwood, Magnus Johansson, Jeremy Crapsey, Grzegorz Pawłowski, nico nuzzaci, Christine Wilks, Hans Bergren, charles montgomery, Ariel בר-לבב Fogel, Ivan Kolev, Daniel Campos, Hugh Wood, Christian Bradford, Frédéric Harper, Ionuţ Dan Popa, Jeff Trimble, Rupert Wood, Trey Carrico, Pancho Lopez, Joël kuijten, Tom A Marra, Jeff Jewiss, Jacob Rios, Paolo Di Stefano, Soledad Penades, Chris Gerber, Andrey Dolganov, Wil Moore III, Thomas Martineau, Kareem, Ben Thouret, Udi Nir, Morgan Laupies, jory carson-burson, Nathan L Smith, Eric Damon Walters, Derry Lozano-Hoyland, Geoffrey Wiseman, mkeehner, KatieK, Scott MacFarlane, Brian LaShomb, Adrien Mas, christopher ross, Ian Littman, Dan Atkinson, Elliot Jobe, Nick Dozier, Peter Wooley, John Hoover, dan, Martin A. Jackson, Héctor Fernando Hurtado, andy ennamorato, Paul Seltmann, Melissa Gore, Dave Pollard, Jack Smith, Philip Da Silva, Guy Israeli, @megalithic, Damian Crawford, Felix Gliesche, April Carter Grant, Heidi, jim tierney, Andrea Giammarchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john gibbon, David J. Groom, BBox, Yu ‘Dilys’ Sun, Nate Steiner, Brandon Satrom, Brian Wyant, Wesley Hales, Ian Pouncey, Timothy Kevin Oxley, George Terezakis, sanjay raj, Jordan Harband, Marko McLion, Wolfgang Kaufmann, Pascal Peuckert, Dave Nugent, Markus Liebelt, Welling Guzman, Nick Cooley, Daniel Mesquita, Robert Syvarth, Chris Coyier, Rémy Bach, Adam Dougal, Alistair Duggin, David Loidolt, Ed Richer, Brian Chenault, GoldFire Studios, Carles Andrés, Carlos Cabo, Yuya Saito, roberto ricardo, Barnett Klane, Mike Moore, Kevin Marx, Justin Love, Joe Taylor, Paul Dijou, Michael Kohler, Rob Cassie, Mike Tierney, Cody Leroy Lindley, tofuji, Shimon Schwartz, Raymond, Luc De Brouwer, David Hayes, Rhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - Level Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael Corral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph C., SwiftOne, Jan Hohner, Derick Bailey, getify, Daniel Cousineau, Chris Charlton, Eric Turner, David Turner, Joël Galeran, Dharma Vagabond, adam, Dirk van Bergen, dave ♥♫★ furf, Vedran Zakanj, Ryan McAllen, Natalie Patrice Tucker, Eric J. Bivona, Adam Spooner, Aaron Cavano, Kelly Packer, Eric J, Martin Drenovac, Emilis, Michael Pelikan, Scott F. Walter, Josh Freeman, Brandon Hudgeons, vijay chennupati, Bill Glennon, Robin R., Troy Forster, otaku_coder, Brad, Scott, Frederick Ostrander, Adam Brill, Seb Flippence, Michael Anderson, Jacob, Adam Randlett, Standard, Joshua Clanton, Sebastian Kouba, Chris Deck, SwordFire, Hannes Papenberg, Richard Woeber, hnzz, Rob Crowther, Jedidiah Broadbent, Sergey Chernyshev, Jay-Ar Jamon, Ben Combee, luciano bonachela, Mark Tomlinson, Kit Cambridge, Michael Melgares, Jacob Adams, Adrian Bruinhout, Bev Wieber, Scott Puleo, Thomas Herzog, April Leone, Daniel Mizieliński, Kees van Ginkel, Jon Abrams, Erwin Heiser, Avi Laviad, David newell, Jean-Francois Turcot, Niko Roberts, Erik Dana, Charles Neill, Aaron Holmes, Grzegorz Ziółkowski, Nathan Youngman, Timothy, Jacob Mather, Michael Allan, Mohit Seth, Ryan Ewing, Benjamin Van Treese, Marcelo Santos, Denis Wolf, Phil Keys, Chris Yung, Timo Tijhof, Martin Lekvall, Agendine, Greg Whitworth, Helen Humphrey, Dougal Campbell, Johannes Harth, Bruno Girin, Brian Hough, Darren Newton, Craig McPheat, Olivier Tille, Dennis Roethig, Mathias Bynens, Brendan Stromberger, sundeep, John Meyer, Ron Male, John F Croston III, gigante, Carl Bergenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry Suitor, afeliz, Tom Kiefer, Darragh Duffy, Kevin Vanderbeken, Andy Pearson, Simon Mac Donald, Abid Din, Chris Joel, Tomas Theunissen, David Dick, Paul Grock, Brandon Wood, John Weis, dgrebb, Nick Jenkins, Chuck Lane, Johnny Megahan, marzsman, Tatu Tamminen, Geoffrey Knauth, Alexander Tarmolov, Jeremy Tymes, Chad Auld, Sean Parmelee, Rob Staenke, Dan Bender, Yannick derwa, Joshua Jones, Geert Plaisier, Tom LeZotte, Christen Simpson, Stefan Bruvik, Justin Falcone, Carlos Santana, Michael Weiss, Pablo Villoslada, Peter deHaan, Dimitris Iliopoulos, seyDoggy, Adam Jordens, Noah Kantrowitz, Amol M, Matthew Winnard, Dirk Ginader, Phinam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael George, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, Robert Kowalski, David I. Teixeira (@ditma, Charles Carpenter, Justin Yost, Sam S, Denis Ciccale, Kevin Sheurs, Yannick Croissant, Pau Fracés, Stephen McGowan, Shawn Searcy, Chris Ruppel, Kevin Lamping, Jessica Campbell, Christopher Schmitt, Sablons, Jonathan Reisdorf, Bunni Gek, Teddy Huff, Michael Mullany, Michael Fürstenberg, Carl Henderson, Rick Yoesting, Scott Nichols, Hernán Ciudad, Andrew Maier, Mike Stapp, Jesse Shawl, Sérgio Lopes, jsulak, Shawn Price, Joel Clermont, Chris Ridmann, Sean Timm, Jason Finch, Aiden Montgomery, Elijah Manor, Derek Gathright, Jesse Harlin, Dillon Curry, Courtney Myers, Diego Cadenas, Arne de Bree, João Paulo Dubas, James Taylor, Philipp Kraeutli, Mihai Păun, Sam Gharegozlou, joshjs, Matt Murchison, Eric Windham, Timo Behrmann, Andrew Hall, joshua price, Théophile Villard</p>
</blockquote>
<p>This book series is being produced in an open source fashion, including editing and production. We owe GitHub a debt of gratitude for making that sort of thing possible for the community!</p>
<p>Thank you again to all the countless folks I didn’t name but who I nonetheless owe thanks. May this book series be “owned” by all of us and serve to contribute to increasing awareness and understanding of the JavaScript language, to the benefit of all current and future community contributors.</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/02/27/Async-Performence/">Async&amp;Performence</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">LAOJIA</a></p>
        <p><span>发布时间:</span>2018-02-27, 18:35:27</p>
        <p><span>最后更新:</span>2018-04-15, 14:20:50</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/02/27/Async-Performence/" title="Async&amp;Performence">https://jiamh2005.github.io/2018/02/27/Async-Performence/</a>
            <span class="copy-path" data-clipboard-text="原文: https://jiamh2005.github.io/2018/02/27/Async-Performence/　　作者: LAOJIA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/03/01/scope-closures/">
                    scope &amp; closures
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/02/27/充分利用青春期大脑的学习潜力/">
                    充分利用青春期大脑的学习潜力
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Foreword"><span class="toc-number">1.</span> <span class="toc-text">Foreword</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Asynchrony-Now-amp-Later"><span class="toc-number">2.</span> <span class="toc-text">Chapter 1: Asynchrony: Now &amp; Later</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Program-in-Chunks"><span class="toc-number">2.1.</span> <span class="toc-text">A Program in Chunks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-Console"><span class="toc-number">2.1.1.</span> <span class="toc-text">Async Console</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-Loop"><span class="toc-number">2.2.</span> <span class="toc-text">Event Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel-Threading"><span class="toc-number">2.3.</span> <span class="toc-text">Parallel Threading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Run-to-Completion"><span class="toc-number">2.3.1.</span> <span class="toc-text">Run-to-Completion</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Concurrency"><span class="toc-number">2.4.</span> <span class="toc-text">Concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Noninteracting"><span class="toc-number">2.4.1.</span> <span class="toc-text">Noninteracting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interaction"><span class="toc-number">2.4.2.</span> <span class="toc-text">Interaction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cooperation"><span class="toc-number">2.4.3.</span> <span class="toc-text">Cooperation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jobs"><span class="toc-number">2.5.</span> <span class="toc-text">Jobs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Statement-Ordering"><span class="toc-number">2.6.</span> <span class="toc-text">Statement Ordering</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review"><span class="toc-number">2.7.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Callbacks"><span class="toc-number">3.</span> <span class="toc-text">Chapter 2: Callbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Continuations"><span class="toc-number">3.1.</span> <span class="toc-text">Continuations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sequential-Brain"><span class="toc-number">3.2.</span> <span class="toc-text">Sequential Brain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Doing-Versus-Planning"><span class="toc-number">3.2.1.</span> <span class="toc-text">Doing Versus Planning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nested-Chained-Callbacks"><span class="toc-number">3.2.2.</span> <span class="toc-text">Nested/Chained Callbacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trust-Issues"><span class="toc-number">3.3.</span> <span class="toc-text">Trust Issues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tale-of-Five-Callbacks"><span class="toc-number">3.3.1.</span> <span class="toc-text">Tale of Five Callbacks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Not-Just-Others’-Code"><span class="toc-number">3.3.2.</span> <span class="toc-text">Not Just Others’ Code</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trying-to-Save-Callbacks"><span class="toc-number">3.4.</span> <span class="toc-text">Trying to Save Callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-1"><span class="toc-number">3.5.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Promises"><span class="toc-number">4.</span> <span class="toc-text">Chapter 3: Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#What-Is-a-Promise"><span class="toc-number">4.1.</span> <span class="toc-text">What Is a Promise?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-Value"><span class="toc-number">4.1.1.</span> <span class="toc-text">Future Value</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Values-Now-and-Later"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">Values Now and Later</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-Value"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">Promise Value</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Completion-Event"><span class="toc-number">4.1.2.</span> <span class="toc-text">Completion Event</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-“Events”"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">Promise “Events”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thenable-Duck-Typing"><span class="toc-number">4.2.</span> <span class="toc-text">Thenable Duck Typing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-Trust"><span class="toc-number">4.3.</span> <span class="toc-text">Promise Trust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Calling-Too-Early"><span class="toc-number">4.3.1.</span> <span class="toc-text">Calling Too Early</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calling-Too-Late"><span class="toc-number">4.3.2.</span> <span class="toc-text">Calling Too Late</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-Scheduling-Quirks"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">Promise Scheduling Quirks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Never-Calling-the-Callback"><span class="toc-number">4.3.3.</span> <span class="toc-text">Never Calling the Callback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calling-Too-Few-or-Too-Many-Times"><span class="toc-number">4.3.4.</span> <span class="toc-text">Calling Too Few or Too Many Times</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Failing-to-Pass-Along-Any-Parameters-Environment"><span class="toc-number">4.3.5.</span> <span class="toc-text">Failing to Pass Along Any Parameters/Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swallowing-Any-Errors-Exceptions"><span class="toc-number">4.3.6.</span> <span class="toc-text">Swallowing Any Errors/Exceptions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trustable-Promise"><span class="toc-number">4.3.7.</span> <span class="toc-text">Trustable Promise?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trust-Built"><span class="toc-number">4.3.8.</span> <span class="toc-text">Trust Built</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chain-Flow"><span class="toc-number">4.4.</span> <span class="toc-text">Chain Flow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Terminology-Resolve-Fulfill-and-Reject"><span class="toc-number">4.4.1.</span> <span class="toc-text">Terminology: Resolve, Fulfill, and Reject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error-Handling"><span class="toc-number">4.5.</span> <span class="toc-text">Error Handling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pit-of-Despair"><span class="toc-number">4.5.1.</span> <span class="toc-text">Pit of Despair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Uncaught-Handling"><span class="toc-number">4.5.2.</span> <span class="toc-text">Uncaught Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pit-of-Success"><span class="toc-number">4.5.3.</span> <span class="toc-text">Pit of Success</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-Patterns"><span class="toc-number">4.6.</span> <span class="toc-text">Promise Patterns</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all"><span class="toc-number">4.6.1.</span> <span class="toc-text">Promise.all([ .. ])</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-race"><span class="toc-number">4.6.2.</span> <span class="toc-text">Promise.race([ .. ])</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Timeout-Race"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">Timeout Race</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#“Finally”"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">“Finally”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Variations-on-all-and-race"><span class="toc-number">4.6.3.</span> <span class="toc-text">Variations on all([ .. ]) and race([ .. ])</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concurrent-Iterations"><span class="toc-number">4.6.4.</span> <span class="toc-text">Concurrent Iterations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-API-Recap"><span class="toc-number">4.7.</span> <span class="toc-text">Promise API Recap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-Promise-Constructor"><span class="toc-number">4.7.1.</span> <span class="toc-text">new Promise(..) Constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-resolve-and-Promise-reject"><span class="toc-number">4.7.2.</span> <span class="toc-text">Promise.resolve(..) and Promise.reject(..)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#then-and-catch"><span class="toc-number">4.7.3.</span> <span class="toc-text">then(..) and catch(..)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all-and-Promise-race"><span class="toc-number">4.7.4.</span> <span class="toc-text">Promise.all([ .. ]) and Promise.race([ .. ])</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-Limitations"><span class="toc-number">4.8.</span> <span class="toc-text">Promise Limitations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sequence-Error-Handling"><span class="toc-number">4.8.1.</span> <span class="toc-text">Sequence Error Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Single-Value"><span class="toc-number">4.8.2.</span> <span class="toc-text">Single Value</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Splitting-Values"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">Splitting Values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unwrap-Spread-Arguments"><span class="toc-number">4.8.2.2.</span> <span class="toc-text">Unwrap/Spread Arguments</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Single-Resolution"><span class="toc-number">4.8.3.</span> <span class="toc-text">Single Resolution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inertia"><span class="toc-number">4.8.4.</span> <span class="toc-text">Inertia</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-Uncancelable"><span class="toc-number">4.8.5.</span> <span class="toc-text">Promise Uncancelable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-Performance"><span class="toc-number">4.8.6.</span> <span class="toc-text">Promise Performance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-2"><span class="toc-number">4.9.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-Generators"><span class="toc-number">5.</span> <span class="toc-text">Chapter 4: Generators</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Breaking-Run-to-Completion"><span class="toc-number">5.1.</span> <span class="toc-text">Breaking Run-to-Completion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Input-and-Output"><span class="toc-number">5.1.1.</span> <span class="toc-text">Input and Output</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Iteration-Messaging"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">Iteration Messaging</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Tale-of-Two-Questions"><span class="toc-number">5.1.1.1.1.</span> <span class="toc-text">Tale of Two Questions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiple-Iterators"><span class="toc-number">5.1.2.</span> <span class="toc-text">Multiple Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Interleaving"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">Interleaving</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator’ing-Values"><span class="toc-number">5.2.</span> <span class="toc-text">Generator’ing Values</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Producers-and-Iterators"><span class="toc-number">5.2.1.</span> <span class="toc-text">Producers and Iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterables"><span class="toc-number">5.2.2.</span> <span class="toc-text">Iterables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generator-Iterator"><span class="toc-number">5.2.3.</span> <span class="toc-text">Generator Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stopping-the-Generator"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">Stopping the Generator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterating-Generators-Asynchronously"><span class="toc-number">5.3.</span> <span class="toc-text">Iterating Generators Asynchronously</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronous-Error-Handling"><span class="toc-number">5.3.1.</span> <span class="toc-text">Synchronous Error Handling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generators-Promises"><span class="toc-number">5.4.</span> <span class="toc-text">Generators + Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-Aware-Generator-Runner"><span class="toc-number">5.4.1.</span> <span class="toc-text">Promise-Aware Generator Runner</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES7-async-and-await"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">ES7: async and await?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-Concurrency-in-Generators"><span class="toc-number">5.4.2.</span> <span class="toc-text">Promise Concurrency in Generators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promises-Hidden"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">Promises, Hidden</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-Delegation"><span class="toc-number">5.5.</span> <span class="toc-text">Generator Delegation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Why-Delegation"><span class="toc-number">5.5.1.</span> <span class="toc-text">Why Delegation?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegating-Messages"><span class="toc-number">5.5.2.</span> <span class="toc-text">Delegating Messages</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exceptions-Delegated-Too"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">Exceptions Delegated, Too!</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegating-Asynchrony"><span class="toc-number">5.5.3.</span> <span class="toc-text">Delegating Asynchrony</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegating-“Recursion”"><span class="toc-number">5.5.4.</span> <span class="toc-text">Delegating “Recursion”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-Concurrency"><span class="toc-number">5.6.</span> <span class="toc-text">Generator Concurrency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thunks"><span class="toc-number">5.7.</span> <span class="toc-text">Thunks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#s-promise-thunk"><span class="toc-number">5.7.1.</span> <span class="toc-text">s/promise/thunk/</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pre-ES6-Generators"><span class="toc-number">5.8.</span> <span class="toc-text">Pre-ES6 Generators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Manual-Transformation"><span class="toc-number">5.8.1.</span> <span class="toc-text">Manual Transformation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Automatic-Transpilation"><span class="toc-number">5.8.2.</span> <span class="toc-text">Automatic Transpilation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-3"><span class="toc-number">5.9.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-Program-Performance"><span class="toc-number">6.</span> <span class="toc-text">Chapter 5: Program Performance</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Workers"><span class="toc-number">6.1.</span> <span class="toc-text">Web Workers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Worker-Environment"><span class="toc-number">6.1.1.</span> <span class="toc-text">Worker Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Transfer"><span class="toc-number">6.1.2.</span> <span class="toc-text">Data Transfer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shared-Workers"><span class="toc-number">6.1.3.</span> <span class="toc-text">Shared Workers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Polyfilling-Web-Workers"><span class="toc-number">6.1.4.</span> <span class="toc-text">Polyfilling Web Workers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIMD"><span class="toc-number">6.2.</span> <span class="toc-text">SIMD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asm-js"><span class="toc-number">6.3.</span> <span class="toc-text">asm.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-Optimize-with-asm-js"><span class="toc-number">6.3.1.</span> <span class="toc-text">How to Optimize with asm.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asm-js-Modules"><span class="toc-number">6.3.2.</span> <span class="toc-text">asm.js Modules</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-4"><span class="toc-number">6.4.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-Benchmarking-amp-Tuning"><span class="toc-number">7.</span> <span class="toc-text">Chapter 6: Benchmarking &amp; Tuning</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Benchmarking"><span class="toc-number">7.1.</span> <span class="toc-text">Benchmarking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Repetition"><span class="toc-number">7.1.1.</span> <span class="toc-text">Repetition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Benchmark-js"><span class="toc-number">7.1.2.</span> <span class="toc-text">Benchmark.js</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Setup-Teardown"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">Setup/Teardown</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-Is-King"><span class="toc-number">7.2.</span> <span class="toc-text">Context Is King</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Engine-Optimizations"><span class="toc-number">7.2.1.</span> <span class="toc-text">Engine Optimizations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jsPerf-com"><span class="toc-number">7.3.</span> <span class="toc-text">jsPerf.com</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sanity-Check"><span class="toc-number">7.3.1.</span> <span class="toc-text">Sanity Check</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Writing-Good-Tests"><span class="toc-number">7.4.</span> <span class="toc-text">Writing Good Tests</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Microperformance"><span class="toc-number">7.5.</span> <span class="toc-text">Microperformance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Not-All-Engines-Are-Alike"><span class="toc-number">7.5.1.</span> <span class="toc-text">Not All Engines Are Alike</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Big-Picture"><span class="toc-number">7.5.2.</span> <span class="toc-text">Big Picture</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tail-Call-Optimization-TCO"><span class="toc-number">7.6.</span> <span class="toc-text">Tail Call Optimization (TCO)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-5"><span class="toc-number">7.7.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-A-asynquence-Library"><span class="toc-number">8.</span> <span class="toc-text">Appendix A: asynquence Library</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sequences-Abstraction-Design"><span class="toc-number">8.1.</span> <span class="toc-text">Sequences, Abstraction Design</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#asynquence-API"><span class="toc-number">8.2.</span> <span class="toc-text">asynquence API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Steps"><span class="toc-number">8.2.1.</span> <span class="toc-text">Steps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Errors"><span class="toc-number">8.2.2.</span> <span class="toc-text">Errors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Steps"><span class="toc-number">8.2.3.</span> <span class="toc-text">Parallel Steps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-Variations"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">Step Variations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Error-Tolerance"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">Error Tolerance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-Style-Steps"><span class="toc-number">8.2.3.3.</span> <span class="toc-text">Promise-Style Steps</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Forking-Sequences"><span class="toc-number">8.2.4.</span> <span class="toc-text">Forking Sequences</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combining-Sequences"><span class="toc-number">8.2.5.</span> <span class="toc-text">Combining Sequences</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Value-and-Error-Sequences"><span class="toc-number">8.3.</span> <span class="toc-text">Value and Error Sequences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promises-and-Callbacks"><span class="toc-number">8.4.</span> <span class="toc-text">Promises and Callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterable-Sequences"><span class="toc-number">8.5.</span> <span class="toc-text">Iterable Sequences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Running-Generators"><span class="toc-number">8.6.</span> <span class="toc-text">Running Generators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Wrapped-Generators"><span class="toc-number">8.6.1.</span> <span class="toc-text">Wrapped Generators</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-6"><span class="toc-number">8.7.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-B-Advanced-Async-Patterns"><span class="toc-number">9.</span> <span class="toc-text">Appendix B: Advanced Async Patterns</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterable-Sequences-1"><span class="toc-number">9.1.</span> <span class="toc-text">Iterable Sequences</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extending-Iterable-Sequences"><span class="toc-number">9.1.1.</span> <span class="toc-text">Extending Iterable Sequences</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-Reactive"><span class="toc-number">9.2.</span> <span class="toc-text">Event Reactive</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES7-Observables"><span class="toc-number">9.2.1.</span> <span class="toc-text">ES7 Observables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reactive-Sequences"><span class="toc-number">9.2.2.</span> <span class="toc-text">Reactive Sequences</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-Coroutine"><span class="toc-number">9.3.</span> <span class="toc-text">Generator Coroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#State-Machines"><span class="toc-number">9.3.1.</span> <span class="toc-text">State Machines</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Communicating-Sequential-Processes-CSP"><span class="toc-number">9.4.</span> <span class="toc-text">Communicating Sequential Processes (CSP)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Message-Passing"><span class="toc-number">9.4.1.</span> <span class="toc-text">Message Passing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asynquence-CSP-emulation"><span class="toc-number">9.4.2.</span> <span class="toc-text">asynquence CSP emulation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-7"><span class="toc-number">9.5.</span> <span class="toc-text">Review</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-C-Acknowledgments"><span class="toc-number">10.</span> <span class="toc-text">Appendix C: Acknowledgments</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    

    
</div>




    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/03/01/scope-closures/" title="上一篇: scope &amp; closures">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/02/27/充分利用青春期大脑的学习潜力/" title="下一篇: 充分利用青春期大脑的学习潜力">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/关于中风的及时治疗/">关于中风的及时治疗</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/01/两次全球大危机的比较研究/">两次全球大危机的比较研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/01/scope-closures/">scope & closures</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Async-Performence/">Async&Performence</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/充分利用青春期大脑的学习潜力/">充分利用青春期大脑的学习潜力</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/2007年的访谈/">2007年的访谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/27/又一篇BLOG/">又一篇BLOG</a></li></ul>




    <script>
        
    </script>
</div>
      <nav id="mobile-nav">
  <div class="intrude-less">
      <header id="header" class="inner">
          <a href="/" class="profilepic">
              <img src="/img/avatar.png" class="animated zoomIn">
          </a>
          <hgroup>
            <h1 class="header-author"><a href="/" title="回到主页">LAOJIA</a></h1>
          </hgroup>
          
          <nav class="header-menu">
              <ul>
              
                  <li><a href="/">主页</a></li>
              
                  <li><a href="/tags/">标签云</a></li>
              
                  <li><a href="/about/">关于我</a></li>
              
              <div class="clearfix"></div>
              </ul>
          </nav>
          <nav class="header-nav">
                      <ul class="social">
                          
                              <a class="fa Email" target="_blank" href="mailto:jia@jiamh.top" title="Email"></a>
                          
                              <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                          
                              <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                          
                      </ul>
          </nav>
      </header>
  </div>
  <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>

      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
          
              <div class="visit">
                  
                      <span id="busuanzi_container_site_pv" style='display:none'>
                          <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                          </span>
                      </span>
                  
                  
                      <span>| </span>
                  
                  
                      <span id="busuanzi_container_page_pv" style='display:none'>
                          <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                          </span>
                      </span>
                  
              </div>
          
          <div class="footer-left">
              <i class="fa fa-copyright"></i>
              2018 LAOJIA
          </div>
          <div class="footer-right">
              <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
          </div>
        </div>
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
