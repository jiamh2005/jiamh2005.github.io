<!DOCTYPE html>
<html lang=":lang">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="LAOJIA" />



<meta name="description" content="Chapter 1: What is Scope?One of the most fundamental paradigms of nearly all programming languages is the ability to store values in variables, and later retrieve or modify those values. In fact, the">
<meta property="og:type" content="article">
<meta property="og:title" content="scope &amp; closures">
<meta property="og:url" content="https://jiamh2005.github.io/2018/03/01/scope-closures/index.html">
<meta property="og:site_name" content="Spaces of Jia">
<meta property="og:description" content="Chapter 1: What is Scope?One of the most fundamental paradigms of nearly all programming languages is the ability to store values in variables, and later retrieve or modify those values. In fact, the">
<meta property="og:locale" content=":lang">
<meta property="og:image" content="https://jiamh2005.github.io/2018/03/01/scope-closures/fig1.png">
<meta property="og:image" content="https://jiamh2005.github.io/2018/03/01/scope-closures/fig2.png">
<meta property="og:updated_time" content="2018-03-04T04:58:27.532Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="scope &amp; closures">
<meta name="twitter:description" content="Chapter 1: What is Scope?One of the most fundamental paradigms of nearly all programming languages is the ability to store values in variables, and later retrieve or modify those values. In fact, the">
<meta name="twitter:image" content="https://jiamh2005.github.io/2018/03/01/scope-closures/fig1.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Spaces of Jia" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>scope &amp; closures | Spaces of Jia</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">LAOJIA</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:jia@jiamh.top" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZTE/">ZTE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/健康/">健康</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/创业/">创业</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/情感/">情感</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端、后端的新方案，向专业进发！</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <div class="body-wrap"><article id="post-scope-closures" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/01/scope-closures/" class="article-date">
      <time datetime="2018-03-01T03:34:20.000Z" itemprop="datePublished">2018-03-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      scope &amp; closures
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="Chapter-1-What-is-Scope"><a href="#Chapter-1-What-is-Scope" class="headerlink" title="Chapter 1: What is Scope?"></a>Chapter 1: What is Scope?</h1><p>One of the most fundamental paradigms of nearly all programming languages is the ability to store values in variables, and later retrieve or modify those values. In fact, the ability to store values and pull values out of variables is what gives a program <em>state</em>.</p>
<p>Without such a concept, a program could perform some tasks, but they would be extremely limited and not terribly interesting.</p>
<p>But the inclusion of variables into our program begets the most interesting questions we will now address: where do those variables <em>live</em>? In other words, where are they stored? And, most importantly, how does our program find them when it needs them?</p>
<p>These questions speak to the need for a well-defined set of rules for storing variables in some location, and for finding those variables at a later time. We’ll call that set of rules: <em>Scope</em>.</p>
<p>But, where and how do these <em>Scope</em> rules get set?</p>
<h2 id="Compiler-Theory"><a href="#Compiler-Theory" class="headerlink" title="Compiler Theory"></a>Compiler Theory</h2><p>It may be self-evident, or it may be surprising, depending on your level of interaction with various languages, but despite the fact that JavaScript falls under the general category of “dynamic” or “interpreted” languages, it is in fact a compiled language. It is <em>not</em> compiled well in advance, as are many traditionally-compiled languages, nor are the results of compilation portable among various distributed systems.</p>
<p>But, nevertheless, the JavaScript engine performs many of the same steps, albeit in more sophisticated ways than we may commonly be aware, of any traditional language-compiler.</p>
<p>In a traditional compiled-language process, a chunk of source code, your program, will undergo typically three steps <em>before</em> it is executed, roughly called “compilation”:</p>
<ol>
<li><p><strong>Tokenizing/Lexing:</strong> breaking up a string of characters into meaningful (to the language) chunks, called tokens. For instance, consider the program: <code>var a = 2;</code>. This program would likely be broken up into the following tokens: <code>var</code>, <code>a</code>, <code>=</code>, <code>2</code>, and <code>;</code>. Whitespace may or may not be persisted as a token, depending on whether it’s meaningful or not.</p>
<p> <strong>Note:</strong> The difference between tokenizing and lexing is subtle and academic, but it centers on whether or not these tokens are identified in a <em>stateless</em> or <em>stateful</em> way. Put simply, if the tokenizer were to invoke stateful parsing rules to figure out whether <code>a</code> should be considered a distinct token or just part of another token, <em>that</em> would be <strong>lexing</strong>.</p>
</li>
<li><p><strong>Parsing:</strong> taking a stream (array) of tokens and turning it into a tree of nested elements, which collectively represent the grammatical structure of the program. This tree is called an “AST” (<b>A</b>bstract <b>S</b>yntax <b>T</b>ree).</p>
<p> The tree for <code>var a = 2;</code> might start with a top-level node called <code>VariableDeclaration</code>, with a child node called <code>Identifier</code> (whose value is <code>a</code>), and another child called <code>AssignmentExpression</code> which itself has a child called <code>NumericLiteral</code> (whose value is <code>2</code>).</p>
</li>
<li><p><strong>Code-Generation:</strong> the process of taking an AST and turning it into executable code. This part varies greatly depending on the language, the platform it’s targeting, etc.</p>
<p> So, rather than get mired in details, we’ll just handwave and say that there’s a way to take our above described AST for <code>var a = 2;</code> and turn it into a set of machine instructions to actually <em>create</em> a variable called <code>a</code> (including reserving memory, etc.), and then store a value into <code>a</code>.</p>
<p> <strong>Note:</strong> The details of how the engine manages system resources are deeper than we will dig, so we’ll just take it for granted that the engine is able to create and store variables as needed.</p>
</li>
</ol>
<p>The JavaScript engine is vastly more complex than <em>just</em> those three steps, as are most other language compilers. For instance, in the process of parsing and code-generation, there are certainly steps to optimize the performance of the execution, including collapsing redundant elements, etc.</p>
<p>So, I’m painting only with broad strokes here. But I think you’ll see shortly why <em>these</em> details we <em>do</em> cover, even at a high level, are relevant.</p>
<p>For one thing, JavaScript engines don’t get the luxury (like other language compilers) of having plenty of time to optimize, because JavaScript compilation doesn’t happen in a build step ahead of time, as with other languages.</p>
<p>For JavaScript, the compilation that occurs happens, in many cases, mere microseconds (or less!) before the code is executed. To ensure the fastest performance, JS engines use all kinds of tricks (like JITs, which lazy compile and even hot re-compile, etc.) which are well beyond the “scope” of our discussion here.</p>
<p>Let’s just say, for simplicity’s sake, that any snippet of JavaScript has to be compiled before (usually <em>right</em> before!) it’s executed. So, the JS compiler will take the program <code>var a = 2;</code> and compile it <em>first</em>, and then be ready to execute it, usually right away.</p>
<h2 id="Understanding-Scope"><a href="#Understanding-Scope" class="headerlink" title="Understanding Scope"></a>Understanding Scope</h2><p>The way we will approach learning about scope is to think of the process in terms of a conversation. But, <em>who</em> is having the conversation?</p>
<h3 id="The-Cast"><a href="#The-Cast" class="headerlink" title="The Cast"></a>The Cast</h3><p>Let’s meet the cast of characters that interact to process the program <code>var a = 2;</code>, so we understand their conversations that we’ll listen in on shortly:</p>
<ol>
<li><p><em>Engine</em>: responsible for start-to-finish compilation and execution of our JavaScript program.</p>
</li>
<li><p><em>Compiler</em>: one of <em>Engine</em>‘s friends; handles all the dirty work of parsing and code-generation (see previous section).</p>
</li>
<li><p><em>Scope</em>: another friend of <em>Engine</em>; collects and maintains a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.</p>
</li>
</ol>
<p>For you to <em>fully understand</em> how JavaScript works, you need to begin to <em>think</em> like <em>Engine</em> (and friends) think, ask the questions they ask, and answer those questions the same.</p>
<h3 id="Back-amp-Forth"><a href="#Back-amp-Forth" class="headerlink" title="Back &amp; Forth"></a>Back &amp; Forth</h3><p>When you see the program <code>var a = 2;</code>, you most likely think of that as one statement. But that’s not how our new friend <em>Engine</em> sees it. In fact, <em>Engine</em> sees two distinct statements, one which <em>Compiler</em> will handle during compilation, and one which <em>Engine</em> will handle during execution.</p>
<p>So, let’s break down how <em>Engine</em> and friends will approach the program <code>var a = 2;</code>.</p>
<p>The first thing <em>Compiler</em> will do with this program is perform lexing to break it down into tokens, which it will then parse into a tree. But when <em>Compiler</em> gets to code-generation, it will treat this program somewhat differently than perhaps assumed.</p>
<p>A reasonable assumption would be that <em>Compiler</em> will produce code that could be summed up by this pseudo-code: “Allocate memory for a variable, label it <code>a</code>, then stick the value <code>2</code> into that variable.” Unfortunately, that’s not quite accurate.</p>
<p><em>Compiler</em> will instead proceed as:</p>
<ol>
<li><p>Encountering <code>var a</code>, <em>Compiler</em> asks <em>Scope</em> to see if a variable <code>a</code> already exists for that particular scope collection. If so, <em>Compiler</em> ignores this declaration and moves on. Otherwise, <em>Compiler</em> asks <em>Scope</em> to declare a new variable called <code>a</code> for that scope collection.</p>
</li>
<li><p><em>Compiler</em> then produces code for <em>Engine</em> to later execute, to handle the <code>a = 2</code> assignment. The code <em>Engine</em> runs will first ask <em>Scope</em> if there is a variable called <code>a</code> accessible in the current scope collection. If so, <em>Engine</em> uses that variable. If not, <em>Engine</em> looks <em>elsewhere</em> (see nested <em>Scope</em> section below).</p>
</li>
</ol>
<p>If <em>Engine</em> eventually finds a variable, it assigns the value <code>2</code> to it. If not, <em>Engine</em> will raise its hand and yell out an error!</p>
<p>To summarize: two distinct actions are taken for a variable assignment: First, <em>Compiler</em> declares a variable (if not previously declared in the current scope), and second, when executing, <em>Engine</em> looks up the variable in <em>Scope</em> and assigns to it, if found.</p>
<h3 id="Compiler-Speak"><a href="#Compiler-Speak" class="headerlink" title="Compiler Speak"></a>Compiler Speak</h3><p>We need a little bit more compiler terminology to proceed further with understanding.</p>
<p>When <em>Engine</em> executes the code that <em>Compiler</em> produced for step (2), it has to look-up the variable <code>a</code> to see if it has been declared, and this look-up is consulting <em>Scope</em>. But the type of look-up <em>Engine</em> performs affects the outcome of the look-up.</p>
<p>In our case, it is said that <em>Engine</em> would be performing an “LHS” look-up for the variable <code>a</code>. The other type of look-up is called “RHS”.</p>
<p>I bet you can guess what the “L” and “R” mean. These terms stand for “Left-hand Side” and “Right-hand Side”.</p>
<p>Side… of what? <strong>Of an assignment operation.</strong></p>
<p>In other words, an LHS look-up is done when a variable appears on the left-hand side of an assignment operation, and an RHS look-up is done when a variable appears on the right-hand side of an assignment operation.</p>
<p>Actually, let’s be a little more precise. An RHS look-up is indistinguishable, for our purposes, from simply a look-up of the value of some variable, whereas the LHS look-up is trying to find the variable container itself, so that it can assign. In this way, RHS doesn’t <em>really</em> mean “right-hand side of an assignment” per se, it just, more accurately, means “not left-hand side”.</p>
<p>Being slightly glib for a moment, you could also think “RHS” instead means “retrieve his/her source (value)”, implying that RHS means “go get the value of…”.</p>
<p>Let’s dig into that deeper.</p>
<p>When I say:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>The reference to <code>a</code> is an RHS reference, because nothing is being assigned to <code>a</code> here. Instead, we’re looking-up to retrieve the value of <code>a</code>, so that the value can be passed to <code>console.log(..)</code>.</p>
<p>By contrast:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>The reference to <code>a</code> here is an LHS reference, because we don’t actually care what the current value is, we simply want to find the variable as a target for the <code>= 2</code> assignment operation.</p>
<p><strong>Note:</strong> LHS and RHS meaning “left/right-hand side of an assignment” doesn’t necessarily literally mean “left/right side of the <code>=</code> assignment operator”. There are several other ways that assignments happen, and so it’s better to conceptually think about it as: “who’s the target of the assignment (LHS)” and “who’s the source of the assignment (RHS)”.</p>
<p>Consider this program, which has both LHS and RHS references:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p>The last line that invokes <code>foo(..)</code> as a function call requires an RHS reference to <code>foo</code>, meaning, “go look-up the value of <code>foo</code>, and give it to me.” Moreover, <code>(..)</code> means the value of <code>foo</code> should be executed, so it’d better actually be a function!</p>
<p>There’s a subtle but important assignment here. <strong>Did you spot it?</strong></p>
<p>You may have missed the implied <code>a = 2</code> in this code snippet. It happens when the value <code>2</code> is passed as an argument to the <code>foo(..)</code> function, in which case the <code>2</code> value is <strong>assigned</strong> to the parameter <code>a</code>. To (implicitly) assign to parameter <code>a</code>, an LHS look-up is performed.</p>
<p>There’s also an RHS reference for the value of <code>a</code>, and that resulting value is passed to <code>console.log(..)</code>. <code>console.log(..)</code> needs a reference to execute. It’s an RHS look-up for the <code>console</code> object, then a property-resolution occurs to see if it has a method called <code>log</code>.</p>
<p>Finally, we can conceptualize that there’s an LHS/RHS exchange of passing the value <code>2</code> (by way of variable <code>a</code>‘s RHS look-up) into <code>log(..)</code>. Inside of the native implementation of <code>log(..)</code>, we can assume it has parameters, the first of which (perhaps called <code>arg1</code>) has an LHS reference look-up, before assigning <code>2</code> to it.</p>
<p><strong>Note:</strong> You might be tempted to conceptualize the function declaration <code>function foo(a) {...</code> as a normal variable declaration and assignment, such as <code>var foo</code> and <code>foo = function(a){...</code>. In so doing, it would be tempting to think of this function declaration as involving an LHS look-up.</p>
<p>However, the subtle but important difference is that <em>Compiler</em> handles both the declaration and the value definition during code-generation, such that when <em>Engine</em> is executing code, there’s no processing necessary to “assign” a function value to <code>foo</code>. Thus, it’s not really appropriate to think of a function declaration as an LHS look-up assignment in the way we’re discussing them here.</p>
<h3 id="Engine-Scope-Conversation"><a href="#Engine-Scope-Conversation" class="headerlink" title="Engine/Scope Conversation"></a>Engine/Scope Conversation</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p>Let’s imagine the above exchange (which processes this code snippet) as a conversation. The conversation would go a little something like this:</p>
<blockquote>
<p><strong><em>Engine</em></strong>: Hey <em>Scope</em>, I have an RHS reference for <code>foo</code>. Ever heard of it?</p>
</blockquote>
<blockquote>
<p><strong><em>Scope</em></strong>: Why yes, I have. <em>Compiler</em> declared it just a second ago. He’s a function. Here you go.</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: Great, thanks! OK, I’m executing <code>foo</code>.</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: Hey, <em>Scope</em>, I’ve got an LHS reference for <code>a</code>, ever heard of it?</p>
</blockquote>
<blockquote>
<p><strong><em>Scope</em></strong>: Why yes, I have. <em>Compiler</em> declared it as a formal parameter to <code>foo</code> just recently. Here you go.</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: Helpful as always, <em>Scope</em>. Thanks again. Now, time to assign <code>2</code> to <code>a</code>.</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: Hey, <em>Scope</em>, sorry to bother you again. I need an RHS look-up for <code>console</code>. Ever heard of it?</p>
</blockquote>
<blockquote>
<p><strong><em>Scope</em></strong>: No problem, <em>Engine</em>, this is what I do all day. Yes, I’ve got <code>console</code>. He’s built-in. Here ya go.</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: Perfect. Looking up <code>log(..)</code>. OK, great, it’s a function.</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: Yo, <em>Scope</em>. Can you help me out with an RHS reference to <code>a</code>. I think I remember it, but just want to double-check.</p>
</blockquote>
<blockquote>
<p><strong><em>Scope</em></strong>: You’re right, <em>Engine</em>. Same guy, hasn’t changed. Here ya go.</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: Cool. Passing the value of <code>a</code>, which is <code>2</code>, into <code>log(..)</code>.</p>
</blockquote>
<blockquote>
<p>…</p>
</blockquote>
<h3 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h3><p>Check your understanding so far. Make sure to play the part of <em>Engine</em> and have a “conversation” with the <em>Scope</em>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = a;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Identify all the LHS look-ups (there are 3!).</p>
</li>
<li><p>Identify all the RHS look-ups (there are 4!).</p>
</li>
</ol>
<p><strong>Note:</strong> See the chapter review for the quiz answers!</p>
<h2 id="Nested-Scope"><a href="#Nested-Scope" class="headerlink" title="Nested Scope"></a>Nested Scope</h2><p>We said that <em>Scope</em> is a set of rules for looking up variables by their identifier name. There’s usually more than one <em>Scope</em> to consider, however.</p>
<p>Just as a block or function is nested inside another block or function, scopes are nested inside other scopes. So, if a variable cannot be found in the immediate scope, <em>Engine</em> consults the next outer containing scope, continuing until found or until the outermost (aka, global) scope has been reached.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a + b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>The RHS reference for <code>b</code> cannot be resolved inside the function <code>foo</code>, but it can be resolved in the <em>Scope</em> surrounding it (in this case, the global).</p>
<p>So, revisiting the conversations between <em>Engine</em> and <em>Scope</em>, we’d overhear:</p>
<blockquote>
<p><strong><em>Engine</em></strong>: “Hey, <em>Scope</em> of <code>foo</code>, ever heard of <code>b</code>? Got an RHS reference for it.”</p>
</blockquote>
<blockquote>
<p><strong><em>Scope</em></strong>: “Nope, never heard of it. Go fish.”</p>
</blockquote>
<blockquote>
<p><strong><em>Engine</em></strong>: “Hey, <em>Scope</em> outside of <code>foo</code>, oh you’re the global <em>Scope</em>, ok cool. Ever heard of <code>b</code>? Got an RHS reference for it.”</p>
</blockquote>
<blockquote>
<p><strong><em>Scope</em></strong>: “Yep, sure have. Here ya go.”</p>
</blockquote>
<p>The simple rules for traversing nested <em>Scope</em>: <em>Engine</em> starts at the currently executing <em>Scope</em>, looks for the variable there, then if not found, keeps going up one level, and so on. If the outermost global scope is reached, the search stops, whether it finds the variable or not.</p>
<h3 id="Building-on-Metaphors"><a href="#Building-on-Metaphors" class="headerlink" title="Building on Metaphors"></a>Building on Metaphors</h3><p>To visualize the process of nested <em>Scope</em> resolution, I want you to think of this tall building.</p>
<p><img src="/2018/03/01/scope-closures/fig1.png" width="250"></p>
<p>The building represents our program’s nested <em>Scope</em> rule set. The first floor of the building represents your currently executing <em>Scope</em>, wherever you are. The top level of the building is the global <em>Scope</em>.</p>
<p>You resolve LHS and RHS references by looking on your current floor, and if you don’t find it, taking the elevator to the next floor, looking there, then the next, and so on. Once you get to the top floor (the global <em>Scope</em>), you either find what you’re looking for, or you don’t. But you have to stop regardless.</p>
<h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><p>Why does it matter whether we call it LHS or RHS?</p>
<p>Because these two types of look-ups behave differently in the circumstance where the variable has not yet been declared (is not found in any consulted <em>Scope</em>).</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a + b );</span><br><span class="line">	b = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<p>When the RHS look-up occurs for <code>b</code> the first time, it will not be found. This is said to be an “undeclared” variable, because it is not found in the scope.</p>
<p>If an RHS look-up fails to ever find a variable, anywhere in the nested <em>Scope</em>s, this results in a <code>ReferenceError</code> being thrown by the <em>Engine</em>. It’s important to note that the error is of the type <code>ReferenceError</code>.</p>
<p>By contrast, if the <em>Engine</em> is performing an LHS look-up and arrives at the top floor (global <em>Scope</em>) without finding it, and if the program is not running in “Strict Mode” [^note-strictmode], then the global <em>Scope</em> will create a new variable of that name <strong>in the global scope</strong>, and hand it back to <em>Engine</em>.</p>
<p><em>“No, there wasn’t one before, but I was helpful and created one for you.”</em></p>
<p>“Strict Mode” [^note-strictmode], which was added in ES5, has a number of different behaviors from normal/relaxed/lazy mode. One such behavior is that it disallows the automatic/implicit global variable creation. In that case, there would be no global <em>Scope</em>‘d variable to hand back from an LHS look-up, and <em>Engine</em> would throw a <code>ReferenceError</code> similarly to the RHS case.</p>
<p>Now, if a variable is found for an RHS look-up, but you try to do something with its value that is impossible, such as trying to execute-as-function a non-function value, or reference a property on a <code>null</code> or <code>undefined</code> value, then <em>Engine</em> throws a different kind of error, called a <code>TypeError</code>.</p>
<p><code>ReferenceError</code> is <em>Scope</em> resolution-failure related, whereas <code>TypeError</code> implies that <em>Scope</em> resolution was successful, but that there was an illegal/impossible action attempted against the result.</p>
<h2 id="Review-TL-DR"><a href="#Review-TL-DR" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><p>Scope is the set of rules that determines where and how a variable (identifier) can be looked-up. This look-up may be for the purposes of assigning to the variable, which is an LHS (left-hand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (right-hand-side) reference.</p>
<p>LHS references result from assignment operations. <em>Scope</em>-related assignments can occur either with the <code>=</code> operator or by passing arguments to (assign to) function parameters.</p>
<p>The JavaScript <em>Engine</em> first compiles code before it executes, and in so doing, it splits up statements like <code>var a = 2;</code> into two separate steps:</p>
<ol>
<li><p>First, <code>var a</code> to declare it in that <em>Scope</em>. This is performed at the beginning, before code execution.</p>
</li>
<li><p>Later, <code>a = 2</code> to look up the variable (LHS reference) and assign to it if found.</p>
</li>
</ol>
<p>Both LHS and RHS reference look-ups start at the currently executing <em>Scope</em>, and if need be (that is, they don’t find what they’re looking for there), they work their way up the nested <em>Scope</em>, one scope (floor) at a time, looking for the identifier, until they get to the global (top floor) and stop, and either find it, or don’t.</p>
<p>Unfulfilled RHS references result in <code>ReferenceError</code>s being thrown. Unfulfilled LHS references result in an automatic, implicitly-created global of that name (if not in “Strict Mode” [^note-strictmode]), or a <code>ReferenceError</code> (if in “Strict Mode” [^note-strictmode]).</p>
<h3 id="Quiz-Answers"><a href="#Quiz-Answers" class="headerlink" title="Quiz Answers"></a>Quiz Answers</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = a;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Identify all the LHS look-ups (there are 3!).</p>
<p> <strong><code>c = ..</code>, <code>a = 2</code> (implicit param assignment) and <code>b = ..</code></strong></p>
</li>
<li><p>Identify all the RHS look-ups (there are 4!).</p>
<p> <strong><code>foo(2..</code>, <code>= a;</code>, <code>a + ..</code> and <code>.. + b</code></strong></p>
</li>
</ol>
<p>[^note-strictmode]: MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode" target="_blank" rel="noopener">Strict Mode</a></p>
<h1 id="Chapter-2-Lexical-Scope"><a href="#Chapter-2-Lexical-Scope" class="headerlink" title="Chapter 2: Lexical Scope"></a>Chapter 2: Lexical Scope</h1><p>In Chapter 1, we defined “scope” as the set of rules that govern how the <em>Engine</em> can look up a variable by its identifier name and find it, either in the current <em>Scope</em>, or in any of the <em>Nested Scopes</em> it’s contained within.</p>
<p>There are two predominant models for how scope works. The first of these is by far the most common, used by the vast majority of programming languages. It’s called <strong>Lexical Scope</strong>, and we will examine it in-depth. The other model, which is still used by some languages (such as Bash scripting, some modes in Perl, etc.) is called <strong>Dynamic Scope</strong>.</p>
<p>Dynamic Scope is covered in Appendix A. I mention it here only to provide a contrast with Lexical Scope, which is the scope model that JavaScript employs.</p>
<h2 id="Lex-time"><a href="#Lex-time" class="headerlink" title="Lex-time"></a>Lex-time</h2><p>As we discussed in Chapter 1, the first traditional phase of a standard language compiler is called lexing (aka, tokenizing). If you recall, the lexing process examines a string of source code characters and assigns semantic meaning to the tokens as a result of some stateful parsing.</p>
<p>It is this concept which provides the foundation to understand what lexical scope is and where the name comes from.</p>
<p>To define it somewhat circularly, lexical scope is scope that is defined at lexing time. In other words, lexical scope is based on where variables and blocks of scope are authored, by you, at write time, and thus is (mostly) set in stone by the time the lexer processes your code.</p>
<p><strong>Note:</strong> We will see in a little bit there are some ways to cheat lexical scope, thereby modifying it after the lexer has passed by, but these are frowned upon. It is considered best practice to treat lexical scope as, in fact, lexical-only, and thus entirely author-time in nature.</p>
<p>Let’s consider this block of code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a, b, c );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> ); <span class="comment">// 2 4 12</span></span><br></pre></td></tr></table></figure>
<p>There are three nested scopes inherent in this code example. It may be helpful to think about these scopes as bubbles inside of each other.</p>
<p><img src="/2018/03/01/scope-closures/fig2.png" width="500"></p>
<p><strong>Bubble 1</strong> encompasses the global scope, and has just one identifier in it: <code>foo</code>.</p>
<p><strong>Bubble 2</strong> encompasses the scope of <code>foo</code>, which includes the three identifiers: <code>a</code>, <code>bar</code> and <code>b</code>.</p>
<p><strong>Bubble 3</strong> encompasses the scope of <code>bar</code>, and it includes just one identifier: <code>c</code>.</p>
<p>Scope bubbles are defined by where the blocks of scope are written, which one is nested inside the other, etc. In the next chapter, we’ll discuss different units of scope, but for now, let’s just assume that each function creates a new bubble of scope.</p>
<p>The bubble for <code>bar</code> is entirely contained within the bubble for <code>foo</code>, because (and only because) that’s where we chose to define the function <code>bar</code>.</p>
<p>Notice that these nested bubbles are strictly nested. We’re not talking about Venn diagrams where the bubbles can cross boundaries. In other words, no bubble for some function can simultaneously exist (partially) inside two other outer scope bubbles, just as no function can partially be inside each of two parent functions.</p>
<h3 id="Look-ups"><a href="#Look-ups" class="headerlink" title="Look-ups"></a>Look-ups</h3><p>The structure and relative placement of these scope bubbles fully explains to the <em>Engine</em> all the places it needs to look to find an identifier.</p>
<p>In the above code snippet, the <em>Engine</em> executes the <code>console.log(..)</code> statement and goes looking for the three referenced variables <code>a</code>, <code>b</code>, and <code>c</code>. It first starts with the innermost scope bubble, the scope of the <code>bar(..)</code> function. It won’t find <code>a</code> there, so it goes up one level, out to the next nearest scope bubble, the scope of <code>foo(..)</code>. It finds <code>a</code> there, and so it uses that <code>a</code>. Same thing for <code>b</code>. But <code>c</code>, it does find inside of <code>bar(..)</code>.</p>
<p>Had there been a <code>c</code> both inside of <code>bar(..)</code> and inside of <code>foo(..)</code>, the <code>console.log(..)</code> statement would have found and used the one in <code>bar(..)</code>, never getting to the one in <code>foo(..)</code>.</p>
<p><strong>Scope look-up stops once it finds the first match</strong>. The same identifier name can be specified at multiple layers of nested scope, which is called “shadowing” (the inner identifier “shadows” the outer identifier). Regardless of shadowing, scope look-up always starts at the innermost scope being executed at the time, and works its way outward/upward until the first match, and stops.</p>
<p><strong>Note:</strong> Global variables are also automatically properties of the global object (<code>window</code> in browsers, etc.), so it <em>is</em> possible to reference a global variable not directly by its lexical name, but instead indirectly as a property reference of the global object.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a</span><br></pre></td></tr></table></figure>
<p>This technique gives access to a global variable which would otherwise be inaccessible due to it being shadowed. However, non-global shadowed variables cannot be accessed.</p>
<p>No matter <em>where</em> a function is invoked from, or even <em>how</em> it is invoked, its lexical scope is <strong>only</strong> defined by where the function was declared.</p>
<p>The lexical scope look-up process <em>only</em> applies to first-class identifiers, such as the <code>a</code>, <code>b</code>, and <code>c</code>. If you had a reference to <code>foo.bar.baz</code> in a piece of code, the lexical scope look-up would apply to finding the <code>foo</code> identifier, but once it locates that variable, object property-access rules take over to resolve the <code>bar</code> and <code>baz</code> properties, respectively.</p>
<h2 id="Cheating-Lexical"><a href="#Cheating-Lexical" class="headerlink" title="Cheating Lexical"></a>Cheating Lexical</h2><p>If lexical scope is defined only by where a function is declared, which is entirely an author-time decision, how could there possibly be a way to “modify” (aka, cheat) lexical scope at run-time?</p>
<p>JavaScript has two such mechanisms. Both of them are equally frowned-upon in the wider community as bad practices to use in your code. But the typical arguments against them are often missing the most important point: <strong>cheating lexical scope leads to poorer performance.</strong></p>
<p>Before I explain the performance issue, though, let’s look at how these two mechanisms work.</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a><code>eval</code></h3><p>The <code>eval(..)</code> function in JavaScript takes a string as an argument, and treats the contents of the string as if it had actually been authored code at that point in the program. In other words, you can programmatically generate code inside of your authored code, and run the generated code as if it had been there at author time.</p>
<p>Evaluating <code>eval(..)</code> (pun intended) in that light, it should be clear how <code>eval(..)</code> allows you to modify the lexical scope environment by cheating and pretending that author-time (aka, lexical) code was there all along.</p>
<p>On subsequent lines of code after an <code>eval(..)</code> has executed, the <em>Engine</em> will not “know” or “care” that the previous code in question was dynamically interpreted and thus modified the lexical scope environment. The <em>Engine</em> will simply perform its lexical scope look-ups as it always does.</p>
<p>Consider the following code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">eval</span>( str ); <span class="comment">// cheating!</span></span><br><span class="line">	<span class="built_in">console</span>.log( a, b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var b = 3;"</span>, <span class="number">1</span> ); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>
<p>The string <code>&quot;var b = 3;&quot;</code> is treated, at the point of the <code>eval(..)</code> call, as code that was there all along. Because that code happens to declare a new variable <code>b</code>, it modifies the existing lexical scope of <code>foo(..)</code>. In fact, as mentioned above, this code actually creates variable <code>b</code> inside of <code>foo(..)</code> that shadows the <code>b</code> that was declared in the outer (global) scope.</p>
<p>When the <code>console.log(..)</code> call occurs, it finds both <code>a</code> and <code>b</code> in the scope of <code>foo(..)</code>, and never finds the outer <code>b</code>. Thus, we print out “1 3” instead of “1 2” as would have normally been the case.</p>
<p><strong>Note:</strong> In this example, for simplicity’s sake, the string of “code” we pass in was a fixed literal. But it could easily have been programmatically created by adding characters together based on your program’s logic. <code>eval(..)</code> is usually used to execute dynamically created code, as dynamically evaluating essentially static code from a string literal would provide no real benefit to just authoring the code directly.</p>
<p>By default, if a string of code that <code>eval(..)</code> executes contains one or more declarations (either variables or functions), this action modifies the existing lexical scope in which the <code>eval(..)</code> resides. Technically, <code>eval(..)</code> can be invoked “indirectly”, through various tricks (beyond our discussion here), which causes it to instead execute in the context of the global scope, thus modifying it. But in either case, <code>eval(..)</code> can at runtime modify an author-time lexical scope.</p>
<p><strong>Note:</strong> <code>eval(..)</code> when used in a strict-mode program operates in its own lexical scope, which means declarations made inside of the <code>eval()</code> do not actually modify the enclosing scope.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="meta">   "use strict"</span>;</span><br><span class="line">   <span class="built_in">eval</span>( str );</span><br><span class="line">   <span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var a = 2"</span> );</span><br></pre></td></tr></table></figure>
<p>There are other facilities in JavaScript which amount to a very similar effect to <code>eval(..)</code>. <code>setTimeout(..)</code> and <code>setInterval(..)</code> <em>can</em> take a string for their respective first argument, the contents of which are <code>eval</code>uated as the code of a dynamically-generated function. This is old, legacy behavior and long-since deprecated. Don’t do it!</p>
<p>The <code>new Function(..)</code> function constructor similarly takes a string of code in its <strong>last</strong> argument to turn into a dynamically-generated function (the first argument(s), if any, are the named parameters for the new function). This function-constructor syntax is slightly safer than <code>eval(..)</code>, but it should still be avoided in your code.</p>
<p>The use-cases for dynamically generating code inside your program are incredibly rare, as the performance degradations are almost never worth the capability.</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a><code>with</code></h3><p>The other frowned-upon (and now deprecated!) feature in JavaScript which cheats lexical scope is the <code>with</code> keyword. There are multiple valid ways that <code>with</code> can be explained, but I will choose here to explain it from the perspective of how it interacts with and affects lexical scope.</p>
<p><code>with</code> is typically explained as a short-hand for making multiple property references against an object <em>without</em> repeating the object reference itself each time.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">	b: <span class="number">2</span>,</span><br><span class="line">	c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// more "tedious" to repeat "obj"</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "easier" short-hand</span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">	a = <span class="number">3</span>;</span><br><span class="line">	b = <span class="number">4</span>;</span><br><span class="line">	c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, there’s much more going on here than just a convenient short-hand for object property access. Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">with</span> (obj) &#123;</span><br><span class="line">		a = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">	a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">	b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo( o1 );</span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">foo( o2 );</span><br><span class="line"><span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2 -- Oops, leaked global!</span></span><br></pre></td></tr></table></figure>
<p>In this code example, two objects <code>o1</code> and <code>o2</code> are created. One has an <code>a</code> property, and the other does not. The <code>foo(..)</code> function takes an object reference <code>obj</code> as an argument, and calls <code>with (obj) { .. }</code> on the reference. Inside the <code>with</code> block, we make what appears to be a normal lexical reference to a variable <code>a</code>, an LHS reference in fact (see Chapter 1), to assign to it the value of <code>2</code>.</p>
<p>When we pass in <code>o1</code>, the <code>a = 2</code> assignment finds the property <code>o1.a</code> and assigns it the value <code>2</code>, as reflected in the subsequent <code>console.log(o1.a)</code> statement. However, when we pass in <code>o2</code>, since it does not have an <code>a</code> property, no such property is created, and <code>o2.a</code> remains <code>undefined</code>.</p>
<p>But then we note a peculiar side-effect, the fact that a global variable <code>a</code> was created by the <code>a = 2</code> assignment. How can this be?</p>
<p>The <code>with</code> statement takes an object, one which has zero or more properties, and <strong>treats that object as if <em>it</em> is a wholly separate lexical scope</strong>, and thus the object’s properties are treated as lexically defined identifiers in that “scope”.</p>
<p><strong>Note:</strong> Even though a <code>with</code> block treats an object like a lexical scope, a normal <code>var</code> declaration inside that <code>with</code> block will not be scoped to that <code>with</code> block, but instead the containing function scope.</p>
<p>While the <code>eval(..)</code> function can modify existing lexical scope if it takes a string of code with one or more declarations in it, the <code>with</code> statement actually creates a <strong>whole new lexical scope</strong> out of thin air, from the object you pass to it.</p>
<p>Understood in this way, the “scope” declared by the <code>with</code> statement when we passed in <code>o1</code> was <code>o1</code>, and that “scope” had an “identifier” in it which corresponds to the <code>o1.a</code> property. But when we used <code>o2</code> as the “scope”, it had no such <code>a</code> “identifier” in it, and so the normal rules of LHS identifier look-up (see Chapter 1) occurred.</p>
<p>Neither the “scope” of <code>o2</code>, nor the scope of <code>foo(..)</code>, nor the global scope even, has an <code>a</code> identifier to be found, so when <code>a = 2</code> is executed, it results in the automatic-global being created (since we’re in non-strict mode).</p>
<p>It is a strange sort of mind-bending thought to see <code>with</code> turning, at runtime, an object and its properties into a “scope” <em>with</em> “identifiers”. But that is the clearest explanation I can give for the results we see.</p>
<p><strong>Note:</strong> In addition to being a bad idea to use, both <code>eval(..)</code> and <code>with</code> are affected (restricted) by Strict Mode. <code>with</code> is outright disallowed, whereas various forms of indirect or unsafe <code>eval(..)</code> are disallowed while retaining the core functionality.</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>Both <code>eval(..)</code> and <code>with</code> cheat the otherwise author-time defined lexical scope by modifying or creating new lexical scope at runtime.</p>
<p>So, what’s the big deal, you ask? If they offer more sophisticated functionality and coding flexibility, aren’t these <em>good</em> features? <strong>No.</strong></p>
<p>The JavaScript <em>Engine</em> has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.</p>
<p>But if the <em>Engine</em> finds an <code>eval(..)</code> or <code>with</code> in the code, it essentially has to <em>assume</em> that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to <code>eval(..)</code> to modify the lexical scope, or the contents of the object you may pass to <code>with</code> to create a new lexical scope to be consulted.</p>
<p>In other words, in the pessimistic sense, most of those optimizations it <em>would</em> make are pointless if <code>eval(..)</code> or <code>with</code> are present, so it simply doesn’t perform the optimizations <em>at all</em>.</p>
<p>Your code will almost certainly tend to run slower simply by the fact that you include an <code>eval(..)</code> or <code>with</code> anywhere in the code. No matter how smart the <em>Engine</em> may be about trying to limit the side-effects of these pessimistic assumptions, <strong>there’s no getting around the fact that without the optimizations, code runs slower.</strong></p>
<h2 id="Review-TL-DR-1"><a href="#Review-TL-DR-1" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><p>Lexical scope means that scope is defined by author-time decisions of where functions are declared. The lexing phase of compilation is essentially able to know where and how all identifiers are declared, and thus predict how they will be looked-up during execution.</p>
<p>Two mechanisms in JavaScript can “cheat” lexical scope: <code>eval(..)</code> and <code>with</code>. The former can modify existing lexical scope (at runtime) by evaluating a string of “code” which has one or more declarations in it. The latter essentially creates a whole new lexical scope (again, at runtime) by treating an object reference <em>as</em> a “scope” and that object’s properties as scoped identifiers.</p>
<p>The downside to these mechanisms is that it defeats the <em>Engine</em>‘s ability to perform compile-time optimizations regarding scope look-up, because the <em>Engine</em> has to assume pessimistically that such optimizations will be invalid. Code <em>will</em> run slower as a result of using either feature. <strong>Don’t use them.</strong></p>
<h1 id="Chapter-3-Function-vs-Block-Scope"><a href="#Chapter-3-Function-vs-Block-Scope" class="headerlink" title="Chapter 3: Function vs. Block Scope"></a>Chapter 3: Function vs. Block Scope</h1><p>As we explored in Chapter 2, scope consists of a series of “bubbles” that each act as a container or bucket, in which identifiers (variables, functions) are declared. These bubbles nest neatly inside each other, and this nesting is defined at author-time.</p>
<p>But what exactly makes a new bubble? Is it only the function? Can other structures in JavaScript create bubbles of scope?</p>
<h2 id="Scope-From-Functions"><a href="#Scope-From-Functions" class="headerlink" title="Scope From Functions"></a>Scope From Functions</h2><p>The most common answer to those questions is that JavaScript has function-based scope. That is, each function you declare creates a bubble for itself, but no other structures create their own scope bubbles. As we’ll see in just a little bit, this is not quite true.</p>
<p>But first, let’s explore function scope and its implications.</p>
<p>Consider this code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// more code</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this snippet, the scope bubble for <code>foo(..)</code> includes identifiers <code>a</code>, <code>b</code>, <code>c</code> and <code>bar</code>. <strong>It doesn’t matter</strong> <em>where</em> in the scope a declaration appears, the variable or function belongs to the containing scope bubble, regardless. We’ll explore how exactly <em>that</em> works in the next chapter.</p>
<p><code>bar(..)</code> has its own scope bubble. So does the global scope, which has just one identifier attached to it: <code>foo</code>.</p>
<p>Because <code>a</code>, <code>b</code>, <code>c</code>, and <code>bar</code> all belong to the scope bubble of <code>foo(..)</code>, they are not accessible outside of <code>foo(..)</code>. That is, the following code would all result in <code>ReferenceError</code> errors, as the identifiers are not available to the global scope:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar(); <span class="comment">// fails</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a, b, c ); <span class="comment">// all 3 fail</span></span><br></pre></td></tr></table></figure>
<p>However, all these identifiers (<code>a</code>, <code>b</code>, <code>c</code>, <code>foo</code>, and <code>bar</code>) are accessible <em>inside</em> of <code>foo(..)</code>, and indeed also available inside of <code>bar(..)</code> (assuming there are no shadow identifier declarations inside <code>bar(..)</code>).</p>
<p>Function scope encourages the idea that all variables belong to the function, and can be used and reused throughout the entirety of the function (and indeed, accessible even to nested scopes). This design approach can be quite useful, and certainly can make full use of the “dynamic” nature of JavaScript variables to take on values of different types as needed.</p>
<p>On the other hand, if you don’t take careful precautions, variables existing across the entirety of a scope can lead to some unexpected pitfalls.</p>
<h2 id="Hiding-In-Plain-Scope"><a href="#Hiding-In-Plain-Scope" class="headerlink" title="Hiding In Plain Scope"></a>Hiding In Plain Scope</h2><p>The traditional way of thinking about functions is that you declare a function, and then add code inside it. But the inverse thinking is equally powerful and useful: take any arbitrary section of code you’ve written, and wrap a function declaration around it, which in effect “hides” the code.</p>
<p>The practical result is to create a scope bubble around the code in question, which means that any declarations (variable or function) in that code will now be tied to the scope of the new wrapping function, rather than the previously enclosing scope. In other words, you can “hide” variables and functions by enclosing them in the scope of a function.</p>
<p>Why would “hiding” variables and functions be a useful technique?</p>
<p>There’s a variety of reasons motivating this scope-based hiding. They tend to arise from the software design principle “Principle of Least Privilege” [^note-leastprivilege], also sometimes called “Least Authority” or “Least Exposure”. This principle states that in the design of software, such as the API for a module/object, you should expose only what is minimally necessary, and “hide” everything else.</p>
<p>This principle extends to the choice of which scope to contain variables and functions. If all variables and functions were in the global scope, they would of course be accessible to any nested scope. But this would violate the “Least…” principle in that you are (likely) exposing many variables or functions which you should otherwise keep private, as proper use of the code would discourage access to those variables/functions.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>In this snippet, the <code>b</code> variable and the <code>doSomethingElse(..)</code> function are likely “private” details of how <code>doSomething(..)</code> does its job. Giving the enclosing scope “access” to <code>b</code> and <code>doSomethingElse(..)</code> is not only unnecessary but also possibly “dangerous”, in that they may be used in unexpected ways, intentionally or not, and this may violate pre-condition assumptions of <code>doSomething(..)</code>.</p>
<p>A more “proper” design would hide these private details inside the scope of <code>doSomething(..)</code>, such as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line">	b = a + doSomethingElse( a * <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( b * <span class="number">3</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething( <span class="number">2</span> ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>Now, <code>b</code> and <code>doSomethingElse(..)</code> are not accessible to any outside influence, instead controlled only by <code>doSomething(..)</code>. The functionality and end-result has not been affected, but the design keeps private details private, which is usually considered better software.</p>
<h3 id="Collision-Avoidance"><a href="#Collision-Avoidance" class="headerlink" title="Collision Avoidance"></a>Collision Avoidance</h3><p>Another benefit of “hiding” variables and functions inside a scope is to avoid unintended collision between two different identifiers with the same name but different intended usages. Collision results often in unexpected overwriting of values.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">		i = <span class="number">3</span>; <span class="comment">// changing the `i` in the enclosing scope's for-loop</span></span><br><span class="line">		<span class="built_in">console</span>.log( a + i );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		bar( i * <span class="number">2</span> ); <span class="comment">// oops, infinite loop ahead!</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>The <code>i = 3</code> assignment inside of <code>bar(..)</code> overwrites, unexpectedly, the <code>i</code> that was declared in <code>foo(..)</code> at the for-loop. In this case, it will result in an infinite loop, because <code>i</code> is set to a fixed value of <code>3</code> and that will forever remain <code>&lt; 10</code>.</p>
<p>The assignment inside <code>bar(..)</code> needs to declare a local variable to use, regardless of what identifier name is chosen. <code>var i = 3;</code> would fix the problem (and would create the previously mentioned “shadowed variable” declaration for <code>i</code>). An <em>additional</em>, not alternate, option is to pick another identifier name entirely, such as <code>var j = 3;</code>. But your software design may naturally call for the same identifier name, so utilizing scope to “hide” your inner declaration is your best/only option in that case.</p>
<h4 id="Global-“Namespaces”"><a href="#Global-“Namespaces”" class="headerlink" title="Global “Namespaces”"></a>Global “Namespaces”</h4><p>A particularly strong example of (likely) variable collision occurs in the global scope. Multiple libraries loaded into your program can quite easily collide with each other if they don’t properly hide their internal/private functions and variables.</p>
<p>Such libraries typically will create a single variable declaration, often an object, with a sufficiently unique name, in the global scope. This object is then used as a “namespace” for that library, where all specific exposures of functionality are made as properties of that object (namespace), rather than as top-level lexically scoped identifiers themselves.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyReallyCoolLibrary = &#123;</span><br><span class="line">	awesome: <span class="string">"stuff"</span>,</span><br><span class="line">	doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;,</span><br><span class="line">	doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Module-Management"><a href="#Module-Management" class="headerlink" title="Module Management"></a>Module Management</h4><p>Another option for collision avoidance is the more modern “module” approach, using any of various dependency managers. Using these tools, no libraries ever add any identifiers to the global scope, but are instead required to have their identifier(s) be explicitly imported into another specific scope through usage of the dependency manager’s various mechanisms.</p>
<p>It should be observed that these tools do not possess “magic” functionality that is exempt from lexical scoping rules. They simply use the rules of scoping as explained here to enforce that no identifiers are injected into any shared scope, and are instead kept in private, non-collision-susceptible scopes, which prevents any accidental scope collisions.</p>
<p>As such, you can code defensively and achieve the same results as the dependency managers do without actually needing to use them, if you so choose. See the Chapter 5 for more information about the module pattern.</p>
<h2 id="Functions-As-Scopes"><a href="#Functions-As-Scopes" class="headerlink" title="Functions As Scopes"></a>Functions As Scopes</h2><p>We’ve seen that we can take any snippet of code and wrap a function around it, and that effectively “hides” any enclosed variable or function declarations from the outside scope inside that function’s inner scope.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;-- insert this</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// &lt;-- and this</span></span><br><span class="line">foo(); <span class="comment">// &lt;-- and this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>While this technique “works”, it is not necessarily very ideal. There are a few problems it introduces. The first is that we have to declare a named-function <code>foo()</code>, which means that the identifier name <code>foo</code> itself “pollutes” the enclosing scope (global, in this case). We also have to explicitly call the function by name (<code>foo()</code>) so that the wrapped code actually executes.</p>
<p>It would be more ideal if the function didn’t need a name (or, rather, the name didn’t pollute the enclosing scope), and if the function could automatically be executed.</p>
<p>Fortunately, JavaScript offers a solution to both problems.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- insert this</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125;)(); <span class="comment">// &lt;-- and this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Let’s break down what’s happening here.</p>
<p>First, notice that the wrapping function statement starts with <code>(function...</code> as opposed to just <code>function...</code>. While this may seem like a minor detail, it’s actually a major change. Instead of treating the function as a standard declaration, the function is treated as a function-expression.</p>
<p><strong>Note:</strong> The easiest way to distinguish declaration vs. expression is the position of the word “function” in the statement (not just a line, but a distinct statement). If “function” is the very first thing in the statement, then it’s a function declaration. Otherwise, it’s a function expression.</p>
<p>The key difference we can observe here between a function declaration and a function expression relates to where its name is bound as an identifier.</p>
<p>Compare the previous two snippets. In the first snippet, the name <code>foo</code> is bound in the enclosing scope, and we call it directly with <code>foo()</code>. In the second snippet, the name <code>foo</code> is not bound in the enclosing scope, but instead is bound only inside of its own function.</p>
<p>In other words, <code>(function foo(){ .. })</code> as an expression means the identifier <code>foo</code> is found <em>only</em> in the scope where the <code>..</code> indicates, not in the outer scope. Hiding the name <code>foo</code> inside itself means it does not pollute the enclosing scope unnecessarily.</p>
<h3 id="Anonymous-vs-Named"><a href="#Anonymous-vs-Named" class="headerlink" title="Anonymous vs. Named"></a>Anonymous vs. Named</h3><p>You are probably most familiar with function expressions as callback parameters, such as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>
<p>This is called an “anonymous function expression”, because <code>function()...</code> has no name identifier on it. Function expressions can be anonymous, but function declarations cannot omit the name – that would be illegal JS grammar.</p>
<p>Anonymous function expressions are quick and easy to type, and many libraries and tools tend to encourage this idiomatic style of code. However, they have several draw-backs to consider:</p>
<ol>
<li><p>Anonymous functions have no useful name to display in stack traces, which can make debugging more difficult.</p>
</li>
<li><p>Without a name, if the function needs to refer to itself, for recursion, etc., the <strong>deprecated</strong> <code>arguments.callee</code> reference is unfortunately required. Another example of needing to self-reference is when an event handler function wants to unbind itself after it fires.</p>
</li>
<li><p>Anonymous functions omit a name that is often helpful in providing more readable/understandable code. A descriptive name helps self-document the code in question.</p>
</li>
</ol>
<p><strong>Inline function expressions</strong> are powerful and useful – the question of anonymous vs. named doesn’t detract from that. Providing a name for your function expression quite effectively addresses all these draw-backs, but has no tangible downsides. The best practice is to always name your function expressions:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>)</span>&#123; <span class="comment">// &lt;-- Look, I have a name!</span></span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"I waited 1 second!"</span> );</span><br><span class="line">&#125;, <span class="number">1000</span> );</span><br></pre></td></tr></table></figure>
<h3 id="Invoking-Function-Expressions-Immediately"><a href="#Invoking-Function-Expressions-Immediately" class="headerlink" title="Invoking Function Expressions Immediately"></a>Invoking Function Expressions Immediately</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Now that we have a function as an expression by virtue of wrapping it in a <code>( )</code> pair, we can execute that function by adding another <code>()</code> on the end, like <code>(function foo(){ .. })()</code>. The first enclosing <code>( )</code> pair makes the function an expression, and the second <code>()</code> executes the function.</p>
<p>This pattern is so common, a few years ago the community agreed on a term for it: <strong>IIFE</strong>, which stands for <strong>I</strong>mmediately <strong>I</strong>nvoked <strong>F</strong>unction <strong>E</strong>xpression.</p>
<p>Of course, IIFE’s don’t need names, necessarily – the most common form of IIFE is to use an anonymous function expression. While certainly less common, naming an IIFE has all the aforementioned benefits over anonymous function expressions, so it’s a good practice to adopt.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>There’s a slight variation on the traditional IIFE form, which some prefer: <code>(function(){ .. }())</code>. Look closely to see the difference. In the first form, the function expression is wrapped in <code>( )</code>, and then the invoking <code>()</code> pair is on the outside right after it. In the second form, the invoking <code>()</code> pair is moved to the inside of the outer <code>( )</code> wrapping pair.</p>
<p>These two forms are identical in functionality. <strong>It’s purely a stylistic choice which you prefer.</strong></p>
<p>Another variation on IIFE’s which is quite common is to use the fact that they are, in fact, just function calls, and pass in argument(s).</p>
<p>For instance:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> global </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">console</span>.log( global.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>We pass in the <code>window</code> object reference, but we name the parameter <code>global</code>, so that we have a clear stylistic delineation for global vs. non-global references. Of course, you can pass in anything from an enclosing scope you want, and you can name the parameter(s) anything that suits you. This is mostly just stylistic choice.</p>
<p>Another application of this pattern addresses the (minor niche) concern that the default <code>undefined</code> identifier might have its value incorrectly overwritten, causing unexpected results. By naming a parameter <code>undefined</code>, but not passing any value for that argument, we can guarantee that the <code>undefined</code> identifier is in fact the undefined value in a block of code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="literal">true</span>; <span class="comment">// setting a land-mine for other code! avoid!</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> undefined </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line">	<span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"Undefined is safe here!"</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>Still another variation of the IIFE inverts the order of things, where the function to execute is given second, <em>after</em> the invocation and parameters to pass to it. This pattern is used in the UMD (Universal Module Definition) project. Some people find it a little cleaner to understand, though it is slightly more verbose.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>)</span>&#123;</span><br><span class="line">	def( <span class="built_in">window</span> );</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">console</span>.log( global.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The <code>def</code> function expression is defined in the second-half of the snippet, and then passed as a parameter (also called <code>def</code>) to the <code>IIFE</code> function defined in the first half of the snippet. Finally, the parameter <code>def</code> (the function) is invoked, passing <code>window</code> in as the <code>global</code> parameter.</p>
<h2 id="Blocks-As-Scopes"><a href="#Blocks-As-Scopes" class="headerlink" title="Blocks As Scopes"></a>Blocks As Scopes</h2><p>While functions are the most common unit of scope, and certainly the most wide-spread of the design approaches in the majority of JS in circulation, other units of scope are possible, and the usage of these other scope units can lead to even better, cleaner to maintain code.</p>
<p>Many languages other than JavaScript support Block Scope, and so developers from those languages are accustomed to the mindset, whereas those who’ve primarily only worked in JavaScript may find the concept slightly foreign.</p>
<p>But even if you’ve never written a single line of code in block-scoped fashion, you are still probably familiar with this extremely common idiom in JavaScript:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We declare the variable <code>i</code> directly inside the for-loop head, most likely because our <em>intent</em> is to use <code>i</code> only within the context of that for-loop, and essentially ignore the fact that the variable actually scopes itself to the enclosing scope (function or global).</p>
<p>That’s what block-scoping is all about. Declaring variables as close as possible, as local as possible, to where they will be used. Another example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">	bar = something( bar );</span><br><span class="line">	<span class="built_in">console</span>.log( bar );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We are using a <code>bar</code> variable only in the context of the if-statement, so it makes a kind of sense that we would declare it inside the if-block. However, where we declare variables is not relevant when using <code>var</code>, because they will always belong to the enclosing scope. This snippet is essentially “fake” block-scoping, for stylistic reasons, and relying on self-enforcement not to accidentally use <code>bar</code> in another place in that scope.</p>
<p>Block scope is a tool to extend the earlier “Principle of Least <del>Privilege</del> Exposure” [^note-leastprivilege] from hiding information in functions to hiding information in blocks of our code.</p>
<p>Consider the for-loop example again:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Why pollute the entire scope of a function with the <code>i</code> variable that is only going to be (or only <em>should be</em>, at least) used for the for-loop?</p>
<p>But more importantly, developers may prefer to <em>check</em> themselves against accidentally (re)using variables outside of their intended purpose, such as being issued an error about an unknown variable if you try to use it in the wrong place. Block-scoping (if it were possible) for the <code>i</code> variable would make <code>i</code> available only for the for-loop, causing an error if <code>i</code> is accessed elsewhere in the function. This helps ensure variables are not re-used in confusing or hard-to-maintain ways.</p>
<p>But, the sad reality is that, on the surface, JavaScript has no facility for block scope.</p>
<p>That is, until you dig a little further.</p>
<h3 id="with-1"><a href="#with-1" class="headerlink" title="with"></a><code>with</code></h3><p>We learned about <code>with</code> in Chapter 2. While it is a frowned upon construct, it <em>is</em> an example of (a form of) block scope, in that the scope that is created from the object only exists for the lifetime of that <code>with</code> statement, and not in the enclosing scope.</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a><code>try/catch</code></h3><p>It’s a <em>very</em> little known fact that JavaScript in ES3 specified the variable declaration in the <code>catch</code> clause of a <code>try/catch</code> to be block-scoped to the <code>catch</code> block.</p>
<p>For instance:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="literal">undefined</span>(); <span class="comment">// illegal operation to force an exception!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( err ); <span class="comment">// works!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( err ); <span class="comment">// ReferenceError: `err` not found</span></span><br></pre></td></tr></table></figure>
<p>As you can see, <code>err</code> exists only in the <code>catch</code> clause, and throws an error when you try to reference it elsewhere.</p>
<p><strong>Note:</strong> While this behavior has been specified and true of practically all standard JS environments (except perhaps old IE), many linters seem to still complain if you have two or more <code>catch</code> clauses in the same scope which each declare their error variable with the same identifier name. This is not actually a re-definition, since the variables are safely block-scoped, but the linters still seem to, annoyingly, complain about this fact.</p>
<p>To avoid these unnecessary warnings, some devs will name their <code>catch</code> variables <code>err1</code>, <code>err2</code>, etc. Other devs will simply turn off the linting check for duplicate variable names.</p>
<p>The block-scoping nature of <code>catch</code> may seem like a useless academic fact, but see Appendix B for more information on just how useful it might be.</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a><code>let</code></h3><p>Thus far, we’ve seen that JavaScript only has some strange niche behaviors which expose block scope functionality. If that were all we had, and <em>it was</em> for many, many years, then block scoping would not be terribly useful to the JavaScript developer.</p>
<p>Fortunately, ES6 changes that, and introduces a new keyword <code>let</code> which sits alongside <code>var</code> as another way to declare variables.</p>
<p>The <code>let</code> keyword attaches the variable declaration to the scope of whatever block (commonly a <code>{ .. }</code> pair) it’s contained in. In other words, <code>let</code> implicitly hijacks any block’s scope for its variable declaration.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">	bar = something( bar );</span><br><span class="line">	<span class="built_in">console</span>.log( bar );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>Using <code>let</code> to attach a variable to an existing block is somewhat implicit. It can confuse you if you’re not paying close attention to which blocks have variables scoped to them, and are in the habit of moving blocks around, wrapping them in other blocks, etc., as you develop and evolve code.</p>
<p>Creating explicit blocks for block-scoping can address some of these concerns, making it more obvious where variables are attached and not. Usually, explicit code is preferable over implicit or subtle code. This explicit block-scoping style is easy to achieve, and fits more naturally with how block-scoping works in other languages:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	&#123; <span class="comment">// &lt;-- explicit block</span></span><br><span class="line">		<span class="keyword">let</span> bar = foo * <span class="number">2</span>;</span><br><span class="line">		bar = something( bar );</span><br><span class="line">		<span class="built_in">console</span>.log( bar );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>We can create an arbitrary block for <code>let</code> to bind to by simply including a <code>{ .. }</code> pair anywhere a statement is valid grammar. In this case, we’ve made an explicit block <em>inside</em> the if-statement, which may be easier as a whole block to move around later in refactoring, without affecting the position and semantics of the enclosing if-statement.</p>
<p><strong>Note:</strong> For another way to express explicit block scopes, see Appendix B.</p>
<p>In Chapter 4, we will address hoisting, which talks about declarations being taken as existing for the entire scope in which they occur.</p>
<p>However, declarations made with <code>let</code> will <em>not</em> hoist to the entire scope of the block they appear in. Such declarations will not observably “exist” in the block until the declaration statement.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError!</span></span><br><span class="line">   <span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h4><p>Another reason block-scoping is useful relates to closures and garbage collection to reclaim memory. We’ll briefly illustrate here, but the closure mechanism is explained in detail in Chapter 5.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// do something interesting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line"></span><br><span class="line">process( someReallyBigData );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line"></span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>The <code>click</code> function click handler callback doesn’t <em>need</em> the <code>someReallyBigData</code> variable at all. That means, theoretically, after <code>process(..)</code> runs, the big memory-heavy data structure could be garbage collected. However, it’s quite likely (though implementation dependent) that the JS engine will still have to keep the structure around, since the <code>click</code> function has a closure over the entire scope.</p>
<p>Block-scoping can address this concern, making it clearer to the engine that it does not need to keep <code>someReallyBigData</code> around:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// do something interesting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// anything declared inside this block can go away after!</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line"></span><br><span class="line">	process( someReallyBigData );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">"my_button"</span> );</span><br><span class="line"></span><br><span class="line">btn.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;, <span class="comment">/*capturingPhase=*/</span><span class="literal">false</span> );</span><br></pre></td></tr></table></figure>
<p>Declaring explicit blocks for variables to locally bind to is a powerful tool that you can add to your code toolbox.</p>
<h4 id="let-Loops"><a href="#let-Loops" class="headerlink" title="let Loops"></a><code>let</code> Loops</h4><p>A particular case where <code>let</code> shines is in the for-loop case as we discussed previously.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>Not only does <code>let</code> in the for-loop header bind the <code>i</code> to the for-loop body, but in fact, it <strong>re-binds it</strong> to each <em>iteration</em> of the loop, making sure to re-assign it the value from the end of the previous loop iteration.</p>
<p>Here’s another way of illustrating the per-iteration binding behavior that occurs:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">let</span> i = j; <span class="comment">// re-bound for each iteration!</span></span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reason why this per-iteration binding is interesting will become clear in Chapter 5 when we discuss closures.</p>
<p>Because <code>let</code> declarations attach to arbitrary blocks rather than to the enclosing function’s scope (or global), there can be gotchas where existing code has a hidden reliance on function-scoped <code>var</code> declarations, and replacing the <code>var</code> with <code>let</code> may require additional care when refactoring code.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log( baz );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code is fairly easily re-factored as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (baz &gt; bar) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( baz );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>But, be careful of such changes when using block-scoped variables:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>, baz = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">let</span> bar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (baz &gt; bar) &#123; <span class="comment">// &lt;-- don't forget `bar` when moving!</span></span><br><span class="line">		<span class="built_in">console</span>.log( baz );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See Appendix B for an alternate (more explicit) style of block-scoping which may provide easier to maintain/refactor code that’s more robust to these scenarios.</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h3><p>In addition to <code>let</code>, ES6 introduces <code>const</code>, which also creates a block-scoped variable, but whose value is fixed (constant). Any attempt to change that value at a later time results in an error.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">const</span> b = <span class="number">3</span>; <span class="comment">// block-scoped to the containing `if`</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">3</span>; <span class="comment">// just fine!</span></span><br><span class="line">	b = <span class="number">4</span>; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// ReferenceError!</span></span><br></pre></td></tr></table></figure>
<h2 id="Review-TL-DR-2"><a href="#Review-TL-DR-2" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><p>Functions are the most common unit of scope in JavaScript. Variables and functions that are declared inside another function are essentially “hidden” from any of the enclosing “scopes”, which is an intentional design principle of good software.</p>
<p>But functions are by no means the only unit of scope. Block-scope refers to the idea that variables and functions can belong to an arbitrary block (generally, any <code>{ .. }</code> pair) of code, rather than only to the enclosing function.</p>
<p>Starting with ES3, the <code>try/catch</code> structure has block-scope in the <code>catch</code> clause.</p>
<p>In ES6, the <code>let</code> keyword (a cousin to the <code>var</code> keyword) is introduced to allow declarations of variables in any arbitrary block of code. <code>if (..) { let a = 2; }</code> will declare a variable <code>a</code> that essentially hijacks the scope of the <code>if</code>‘s <code>{ .. }</code> block and attaches itself there.</p>
<p>Though some seem to believe so, block scope should not be taken as an outright replacement of <code>var</code> function scope. Both functionalities co-exist, and developers can and should use both function-scope and block-scope techniques where respectively appropriate to produce better, more readable/maintainable code.</p>
<p>[^note-leastprivilege]: <a href="http://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener">Principle of Least Privilege</a></p>
<h1 id="Chapter-4-Hoisting"><a href="#Chapter-4-Hoisting" class="headerlink" title="Chapter 4: Hoisting"></a>Chapter 4: Hoisting</h1><p>By now, you should be fairly comfortable with the idea of scope, and how variables are attached to different levels of scope depending on where and how they are declared. Both function scope and block scope behave by the same rules in this regard: any variable declared within a scope is attached to that scope.</p>
<p>But there’s a subtle detail of how scope attachment works with declarations that appear in various locations within a scope, and that detail is what we will examine here.</p>
<h2 id="Chicken-Or-The-Egg"><a href="#Chicken-Or-The-Egg" class="headerlink" title="Chicken Or The Egg?"></a>Chicken Or The Egg?</h2><p>There’s a temptation to think that all of the code you see in a JavaScript program is interpreted line-by-line, top-down in order, as the program executes. While that is substantially true, there’s one part of that assumption which can lead to incorrect thinking about your program.</p>
<p>Consider this code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>What do you expect to be printed in the <code>console.log(..)</code> statement?</p>
<p>Many developers would expect <code>undefined</code>, since the <code>var a</code> statement comes after the <code>a = 2</code>, and it would seem natural to assume that the variable is re-defined, and thus assigned the default <code>undefined</code>. However, the output will be <code>2</code>.</p>
<p>Consider another piece of code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>You might be tempted to assume that, since the previous snippet exhibited some less-than-top-down looking behavior, perhaps in this snippet, <code>2</code> will also be printed. Others may think that since the <code>a</code> variable is used before it is declared, this must result in a <code>ReferenceError</code> being thrown.</p>
<p>Unfortunately, both guesses are incorrect. <code>undefined</code> is the output.</p>
<p><strong>So, what’s going on here?</strong> It would appear we have a chicken-and-the-egg question. Which comes first, the declaration (“egg”), or the assignment (“chicken”)?</p>
<h2 id="The-Compiler-Strikes-Again"><a href="#The-Compiler-Strikes-Again" class="headerlink" title="The Compiler Strikes Again"></a>The Compiler Strikes Again</h2><p>To answer this question, we need to refer back to Chapter 1, and our discussion of compilers. Recall that the <em>Engine</em> actually will compile your JavaScript code before it interprets it. Part of the compilation phase was to find and associate all declarations with their appropriate scopes. Chapter 2 showed us that this is the heart of Lexical Scope.</p>
<p>So, the best way to think about things is that all declarations, both variables and functions, are processed first, before any part of your code is executed.</p>
<p>When you see <code>var a = 2;</code>, you probably think of that as one statement. But JavaScript actually thinks of it as two statements: <code>var a;</code> and <code>a = 2;</code>. The first statement, the declaration, is processed during the compilation phase. The second statement, the assignment, is left <strong>in place</strong> for the execution phase.</p>
<p>Our first snippet then should be thought of as being handled like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>…where the first part is the compilation and the second part is the execution.</p>
<p>Similarly, our second snippet is actually processed as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>So, one way of thinking, sort of metaphorically, about this process, is that variable and function declarations are “moved” from where they appear in the flow of the code to the top of the code. This gives rise to the name “Hoisting”.</p>
<p>In other words, <strong>the egg (declaration) comes before the chicken (assignment)</strong>.</p>
<p><strong>Note:</strong> Only the declarations themselves are hoisted, while any assignments or other executable logic are left <em>in place</em>. If hoisting were to re-arrange the executable logic of our code, that could wreak havoc.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>foo</code>‘s declaration (which in this case <em>includes</em> the implied value of it as an actual function) is hoisted, such that the call on the first line is able to execute.</p>
<p>It’s also important to note that hoisting is <strong>per-scope</strong>. So while our previous snippets were simplified in that they only included global scope, the <code>foo(..)</code> function we are now examining itself exhibits that <code>var a</code> is hoisted to the top of <code>foo(..)</code> (not, obviously, to the top of the program). So the program can perhaps be more accurately interpreted like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>Function declarations are hoisted, as we just saw. But function expressions are not.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// not ReferenceError, but TypeError!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The variable identifier <code>foo</code> is hoisted and attached to the enclosing scope (global) of this program, so <code>foo()</code> doesn’t fail as a <code>ReferenceError</code>. But <code>foo</code> has no value yet (as it would if it had been a true function declaration instead of expression). So, <code>foo()</code> is attempting to invoke the <code>undefined</code> value, which is a <code>TypeError</code> illegal operation.</p>
<p>Also recall that even though it’s a named function expression, the name identifier is not available in the enclosing scope:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This snippet is more accurately interpreted (with hoisting) as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> bar = ...self...</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions-First"><a href="#Functions-First" class="headerlink" title="Functions First"></a>Functions First</h2><p>Both function declarations and variable declarations are hoisted. But a subtle detail (that <em>can</em> show up in code with multiple “duplicate” declarations) is that functions are hoisted first, and then variables.</p>
<p>Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>1</code> is printed instead of <code>2</code>! This snippet is interpreted by the <em>Engine</em> as:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Notice that <code>var foo</code> was the duplicate (and thus ignored) declaration, even though it came before the <code>function foo()...</code> declaration, because function declarations are hoisted before normal variables.</p>
<p>While multiple/duplicate <code>var</code> declarations are effectively ignored, subsequent function declarations <em>do</em> override previous ones.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="number">3</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While this all may sound like nothing more than interesting academic trivia, it highlights the fact that duplicate definitions in the same scope are a really bad idea and will often lead to confusing results.</p>
<p>Function declarations that appear inside of normal blocks typically hoist to the enclosing scope, rather than being conditional as this code implies:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// "b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"a"</span> ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">"b"</span> ); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, it’s important to note that this behavior is not reliable and is subject to change in future versions of JavaScript, so it’s probably best to avoid declaring functions in blocks.</p>
<h2 id="Review-TL-DR-3"><a href="#Review-TL-DR-3" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><p>We can be tempted to look at <code>var a = 2;</code> as one statement, but the JavaScript <em>Engine</em> does not see it that way. It sees <code>var a</code> and <code>a = 2</code> as two separate statements, the first one a compiler-phase task, and the second one an execution-phase task.</p>
<p>What this leads to is that all declarations in a scope, regardless of where they appear, are processed <em>first</em> before the code itself is executed. You can visualize this as declarations (variables and functions) being “moved” to the top of their respective scopes, which we call “hoisting”.</p>
<p>Declarations themselves are hoisted, but assignments, even assignments of function expressions, are <em>not</em> hoisted.</p>
<p>Be careful about duplicate declarations, especially mixed between normal var declarations and function declarations – peril awaits if you do!</p>
<h1 id="Chapter-5-Scope-Closure"><a href="#Chapter-5-Scope-Closure" class="headerlink" title="Chapter 5: Scope Closure"></a>Chapter 5: Scope Closure</h1><p>We arrive at this point with hopefully a very healthy, solid understanding of how scope works.</p>
<p>We turn our attention to an incredibly important, but persistently elusive, <em>almost mythological</em>, part of the language: <strong>closure</strong>. If you have followed our discussion of lexical scope thus far, the payoff is that closure is going to be, largely, anticlimactic, almost self-obvious. <em>There’s a man behind the wizard’s curtain, and we’re about to see him</em>. No, his name is not Crockford!</p>
<p>If however you have nagging questions about lexical scope, now would be a good time to go back and review Chapter 2 before proceeding.</p>
<h2 id="Enlightenment"><a href="#Enlightenment" class="headerlink" title="Enlightenment"></a>Enlightenment</h2><p>For those who are somewhat experienced in JavaScript, but have perhaps never fully grasped the concept of closures, <em>understanding closure</em> can seem like a special nirvana that one must strive and sacrifice to attain.</p>
<p>I recall years back when I had a firm grasp on JavaScript, but had no idea what closure was. The hint that there was <em>this other side</em> to the language, one which promised even more capability than I already possessed, teased and taunted me. I remember reading through the source code of early frameworks trying to understand how it actually worked. I remember the first time something of the “module pattern” began to emerge in my mind. I remember the <em>a-ha!</em> moments quite vividly.</p>
<p>What I didn’t know back then, what took me years to understand, and what I hope to impart to you presently, is this secret: <strong>closure is all around you in JavaScript, you just have to recognize and embrace it.</strong> Closures are not a special opt-in tool that you must learn new syntax and patterns for. No, closures are not even a weapon that you must learn to wield and master as Luke trained in The Force.</p>
<p>Closures happen as a result of writing code that relies on lexical scope. They just happen. You do not even really have to intentionally create closures to take advantage of them. Closures are created and used for you all over your code. What you are <em>missing</em> is the proper mental context to recognize, embrace, and leverage closures for your own will.</p>
<p>The enlightenment moment should be: <strong>oh, closures are already occurring all over my code, I can finally <em>see</em> them now.</strong> Understanding closures is like when Neo sees the Matrix for the first time.</p>
<h2 id="Nitty-Gritty"><a href="#Nitty-Gritty" class="headerlink" title="Nitty Gritty"></a>Nitty Gritty</h2><p>OK, enough hyperbole and shameless movie references.</p>
<p>Here’s a down-n-dirty definition of what you need to know to understand and recognize closures:</p>
<blockquote>
<p>Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.</p>
</blockquote>
<p>Let’s jump into some code to illustrate that definition.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>This code should look familiar from our discussions of Nested Scope. Function <code>bar()</code> has <em>access</em> to the variable <code>a</code> in the outer enclosing scope because of lexical scope look-up rules (in this case, it’s an RHS reference look-up).</p>
<p>Is this “closure”?</p>
<p>Well, technically… <em>perhaps</em>. But by our what-you-need-to-know definition above… <em>not exactly</em>. I think the most accurate way to explain <code>bar()</code> referencing <code>a</code> is via lexical scope look-up rules, and those rules are <em>only</em> (an important!) <strong>part</strong> of what closure is.</p>
<p>From a purely academic perspective, what is said of the above snippet is that the function <code>bar()</code> has a <em>closure</em> over the scope of <code>foo()</code> (and indeed, even over the rest of the scopes it has access to, such as the global scope in our case). Put slightly differently, it’s said that <code>bar()</code> closes over the scope of <code>foo()</code>. Why? Because <code>bar()</code> appears nested inside of <code>foo()</code>. Plain and simple.</p>
<p>But, closure defined in this way is not directly <em>observable</em>, nor do we see closure <em>exercised</em> in that snippet. We clearly see lexical scope, but closure remains sort of a mysterious shifting shadow behind the code.</p>
<p>Let us then consider code which brings closure into full light:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">// 2 -- Whoa, closure was just observed, man.</span></span><br></pre></td></tr></table></figure>
<p>The function <code>bar()</code> has lexical scope access to the inner scope of <code>foo()</code>. But then, we take <code>bar()</code>, the function itself, and pass it <em>as</em> a value. In this case, we <code>return</code> the function object itself that <code>bar</code> references.</p>
<p>After we execute <code>foo()</code>, we assign the value it returned (our inner <code>bar()</code> function) to a variable called <code>baz</code>, and then we actually invoke <code>baz()</code>, which of course is invoking our inner function <code>bar()</code>, just by a different identifier reference.</p>
<p><code>bar()</code> is executed, for sure. But in this case, it’s executed <em>outside</em> of its declared lexical scope.</p>
<p>After <code>foo()</code> executed, normally we would expect that the entirety of the inner scope of <code>foo()</code> would go away, because we know that the <em>Engine</em> employs a <em>Garbage Collector</em> that comes along and frees up memory once it’s no longer in use. Since it would appear that the contents of <code>foo()</code> are no longer in use, it would seem natural that they should be considered <em>gone</em>.</p>
<p>But the “magic” of closures does not let this happen. That inner scope is in fact <em>still</em> “in use”, and thus does not go away. Who’s using it? <strong>The function <code>bar()</code> itself</strong>.</p>
<p>By virtue of where it was declared, <code>bar()</code> has a lexical scope closure over that inner scope of <code>foo()</code>, which keeps that scope alive for <code>bar()</code> to reference at any later time.</p>
<p><strong><code>bar()</code> still has a reference to that scope, and that reference is called closure.</strong></p>
<p>So, a few microseconds later, when the variable <code>baz</code> is invoked (invoking the inner function we initially labeled <code>bar</code>), it duly has <em>access</em> to author-time lexical scope, so it can access the variable <code>a</code> just as we’d expect.</p>
<p>The function is being invoked well outside of its author-time lexical scope. <strong>Closure</strong> lets the function continue to access the lexical scope it was defined in at author-time.</p>
<p>Of course, any of the various ways that functions can be <em>passed around</em> as values, and indeed invoked in other locations, are all examples of observing/exercising closure.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar( baz );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	fn(); <span class="comment">// look ma, I saw closure!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We pass the inner function <code>baz</code> over to <code>bar</code>, and call that inner function (labeled <code>fn</code> now), and when we do, its closure over the inner scope of <code>foo()</code> is observed, by accessing <code>a</code>.</p>
<p>These passings-around of functions can be indirect, too.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fn = baz; <span class="comment">// assign `baz` to global variable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	fn(); <span class="comment">// look ma, I saw closure!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Whatever facility we use to <em>transport</em> an inner function outside of its lexical scope, it will maintain a scope reference to where it was originally declared, and wherever we execute it, that closure will be exercised.</p>
<h2 id="Now-I-Can-See"><a href="#Now-I-Can-See" class="headerlink" title="Now I Can See"></a>Now I Can See</h2><p>The previous code snippets are somewhat academic and artificially constructed to illustrate <em>using closure</em>. But I promised you something more than just a cool new toy. I promised that closure was something all around you in your existing code. Let us now <em>see</em> that truth.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( message );</span><br><span class="line">	&#125;, <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait( <span class="string">"Hello, closure!"</span> );</span><br></pre></td></tr></table></figure>
<p>We take an inner function (named <code>timer</code>) and pass it to <code>setTimeout(..)</code>. But <code>timer</code> has a scope closure over the scope of <code>wait(..)</code>, indeed keeping and using a reference to the variable <code>message</code>.</p>
<p>A thousand milliseconds after we have executed <code>wait(..)</code>, and its inner scope should otherwise be long gone, that inner function <code>timer</code> still has closure over that scope.</p>
<p>Deep down in the guts of the <em>Engine</em>, the built-in utility <code>setTimeout(..)</code> has reference to some parameter, probably called <code>fn</code> or <code>func</code> or something like that. <em>Engine</em> goes to invoke that function, which is invoking our inner <code>timer</code> function, and the lexical scope reference is still intact.</p>
<p><strong>Closure.</strong></p>
<p>Or, if you’re of the jQuery persuasion (or any JS framework, for that matter):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupBot</span>(<span class="params">name,selector</span>) </span>&#123;</span><br><span class="line">	$( selector ).click( <span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"Activating: "</span> + name );</span><br><span class="line">	&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupBot( <span class="string">"Closure Bot 1"</span>, <span class="string">"#bot_1"</span> );</span><br><span class="line">setupBot( <span class="string">"Closure Bot 2"</span>, <span class="string">"#bot_2"</span> );</span><br></pre></td></tr></table></figure>
<p>I am not sure what kind of code you write, but I regularly write code which is responsible for controlling an entire global drone army of closure bots, so this is totally realistic!</p>
<p>(Some) joking aside, essentially <em>whenever</em> and <em>wherever</em> you treat functions (which access their own respective lexical scopes) as first-class values and pass them around, you are likely to see those functions exercising closure. Be that timers, event handlers, Ajax requests, cross-window messaging, web workers, or any of the other asynchronous (or synchronous!) tasks, when you pass in a <em>callback function</em>, get ready to sling some closure around!</p>
<p><strong>Note:</strong> Chapter 3 introduced the IIFE pattern. While it is often said that IIFE (alone) is an example of observed closure, I would somewhat disagree, by our definition above.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>This code “works”, but it’s not strictly an observation of closure. Why? Because the function (which we named “IIFE” here) is not executed outside its lexical scope. It’s still invoked right there in the same scope as it was declared (the enclosing/global scope that also holds <code>a</code>). <code>a</code> is found via normal lexical scope look-up, not really via closure.</p>
<p>While closure might technically be happening at declaration time, it is <em>not</em> strictly observable, and so, as they say, <em>it’s a tree falling in the forest with no one around to hear it.</em></p>
<p>Though an IIFE is not <em>itself</em> an example of closure, it absolutely creates scope, and it’s one of the most common tools we use to create scope which can be closed over. So IIFEs are indeed heavily related to closure, even if not exercising closure themselves.</p>
<p>Put this book down right now, dear reader. I have a task for you. Go open up some of your recent JavaScript code. Look for your functions-as-values and identify where you are already using closure and maybe didn’t even know it before.</p>
<p>I’ll wait.</p>
<p>Now… you see!</p>
<h2 id="Loops-Closure"><a href="#Loops-Closure" class="headerlink" title="Loops + Closure"></a>Loops + Closure</h2><p>The most common canonical example used to illustrate closure involves the humble for-loop.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Linters often complain when you put functions inside of loops, because the mistakes of not understanding closure are <strong>so common among developers</strong>. We explain how to do so properly here, leveraging the full power of closure. But that subtlety is often lost on linters and they will complain regardless, assuming you don’t <em>actually</em> know what you’re doing.</p>
<p>The spirit of this code snippet is that we would normally <em>expect</em> for the behavior to be that the numbers “1”, “2”, .. “5” would be printed out, one at a time, one per second, respectively.</p>
<p>In fact, if you run this code, you get “6” printed out 5 times, at the one-second intervals.</p>
<p><strong>Huh?</strong></p>
<p>Firstly, let’s explain where <code>6</code> comes from. The terminating condition of the loop is when <code>i</code> is <em>not</em> <code>&lt;=5</code>. The first time that’s the case is when <code>i</code> is 6. So, the output is reflecting the final value of the <code>i</code> after the loop terminates.</p>
<p>This actually seems obvious on second glance. The timeout function callbacks are all running well after the completion of the loop. In fact, as timers go, even if it was <code>setTimeout(.., 0)</code> on each iteration, all those function callbacks would still run strictly after the completion of the loop, and thus print <code>6</code> each time.</p>
<p>But there’s a deeper question at play here. What’s <em>missing</em> from our code to actually have it behave as we semantically have implied?</p>
<p>What’s missing is that we are trying to <em>imply</em> that each iteration of the loop “captures” its own copy of <code>i</code>, at the time of the iteration. But, the way scope works, all 5 of those functions, though they are defined separately in each loop iteration, all <strong>are closed over the same shared global scope</strong>, which has, in fact, only one <code>i</code> in it.</p>
<p>Put that way, <em>of course</em> all functions share a reference to the same <code>i</code>. Something about the loop structure tends to confuse us into thinking there’s something else more sophisticated at work. There is not. There’s no difference than if each of the 5 timeout callbacks were just declared one right after the other, with no loop at all.</p>
<p>OK, so, back to our burning question. What’s missing? We need more <del>cowbell</del> closured scope. Specifically, we need a new closured scope for each iteration of the loop.</p>
<p>We learned in Chapter 3 that the IIFE creates scope by declaring a function and immediately executing it.</p>
<p>Let’s try:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( i );</span><br><span class="line">		&#125;, i*<span class="number">1000</span> );</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Does that work? Try it. Again, I’ll wait.</p>
<p>I’ll end the suspense for you. <strong>Nope.</strong> But why? We now obviously have more lexical scope. Each timeout function callback is indeed closing over its own per-iteration scope created respectively by each IIFE.</p>
<p>It’s not enough to have a scope to close over <strong>if that scope is empty</strong>. Look closely. Our IIFE is just an empty do-nothing scope. It needs <em>something</em> in it to be useful to us.</p>
<p>It needs its own variable, with a copy of the <code>i</code> value at each iteration.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> j = i;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( j );</span><br><span class="line">		&#125;, j*<span class="number">1000</span> );</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Eureka! It works!</strong></p>
<p>A slight variation some prefer is:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( j );</span><br><span class="line">		&#125;, j*<span class="number">1000</span> );</span><br><span class="line">	&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Of course, since these IIFEs are just functions, we can pass in <code>i</code>, and we can call it <code>j</code> if we prefer, or we can even call it <code>i</code> again. Either way, the code works now.</p>
<p>The use of an IIFE inside each iteration created a new scope for each iteration, which gave our timeout function callbacks the opportunity to close over a new scope for each iteration, one which had a variable with the right per-iteration value in it for us to access.</p>
<p>Problem solved!</p>
<h3 id="Block-Scoping-Revisited"><a href="#Block-Scoping-Revisited" class="headerlink" title="Block Scoping Revisited"></a>Block Scoping Revisited</h3><p>Look carefully at our analysis of the previous solution. We used an IIFE to create new scope per-iteration. In other words, we actually <em>needed</em> a per-iteration <strong>block scope</strong>. Chapter 3 showed us the <code>let</code> declaration, which hijacks a block and declares a variable right there in the block.</p>
<p><strong>It essentially turns a block into a scope that we can close over.</strong> So, the following awesome code “just works”:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">let</span> j = i; <span class="comment">// yay, block-scope for closure!</span></span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( j );</span><br><span class="line">	&#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>But, that’s not all!</em> (in my best Bob Barker voice). There’s a special behavior defined for <code>let</code> declarations used in the head of a for-loop. This behavior says that the variable will be declared not just once for the loop, <strong>but each iteration</strong>. And, it will, helpfully, be initialized at each subsequent iteration with the value from the end of the previous iteration.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How cool is that? Block scoping and closure working hand-in-hand, solving all the world’s problems. I don’t know about you, but that makes me a happy JavaScripter.</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>There are other code patterns which leverage the power of closure but which do not on the surface appear to be about callbacks. Let’s examine the most powerful of them: <em>the module</em>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">	<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( something );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As this code stands right now, there’s no observable closure going on. We simply have some private data variables <code>something</code> and <code>another</code>, and a couple of inner functions <code>doSomething()</code> and <code>doAnother()</code>, which both have lexical scope (and thus closure!) over the inner scope of <code>foo()</code>.</p>
<p>But now consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">	<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( something );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		doSomething: doSomething,</span><br><span class="line">		doAnother: doAnother</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>This is the pattern in JavaScript we call <em>module</em>. The most common way of implementing the module pattern is often called “Revealing Module”, and it’s the variation we present here.</p>
<p>Let’s examine some things about this code.</p>
<p>Firstly, <code>CoolModule()</code> is just a function, but it <em>has to be invoked</em> for there to be a module instance created. Without the execution of the outer function, the creation of the inner scope and the closures would not occur.</p>
<p>Secondly, the <code>CoolModule()</code> function returns an object, denoted by the object-literal syntax <code>{ key: value, ... }</code>. The object we return has references on it to our inner functions, but <em>not</em> to our inner data variables. We keep those hidden and private. It’s appropriate to think of this object return value as essentially a <strong>public API for our module</strong>.</p>
<p>This object return value is ultimately assigned to the outer variable <code>foo</code>, and then we can access those property methods on the API, like <code>foo.doSomething()</code>.</p>
<p><strong>Note:</strong> It is not required that we return an actual object (literal) from our module. We could just return back an inner function directly. jQuery is actually a good example of this. The <code>jQuery</code> and <code>$</code> identifiers are the public API for the jQuery “module”, but they are, themselves, just a function (which can itself have properties, since all functions are objects).</p>
<p>The <code>doSomething()</code> and <code>doAnother()</code> functions have closure over the inner scope of the module “instance” (arrived at by actually invoking <code>CoolModule()</code>). When we transport those functions outside of the lexical scope, by way of property references on the object we return, we have now set up a condition by which closure can be observed and exercised.</p>
<p>To state it more simply, there are two “requirements” for the module pattern to be exercised:</p>
<ol>
<li><p>There must be an outer enclosing function, and it must be invoked at least once (each time creates a new module instance).</p>
</li>
<li><p>The enclosing function must return back at least one inner function, so that this inner function has closure over the private scope, and can access and/or modify that private state.</p>
</li>
</ol>
<p>An object with a function property on it alone is not <em>really</em> a module. An object which is returned from a function invocation which only has data properties on it and no closured functions is not <em>really</em> a module, in the observable sense.</p>
<p>The code snippet above shows a standalone module creator called <code>CoolModule()</code> which can be invoked any number of times, each time creating a new module instance. A slight variation on this pattern is when you only care to have one instance, a “singleton” of sorts:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">	<span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( something );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( another.join( <span class="string">" ! "</span> ) );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		doSomething: doSomething,</span><br><span class="line">		doAnother: doAnother</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>Here, we turned our module function into an IIFE (see Chapter 3), and we <em>immediately</em> invoked it and assigned its return value directly to our single module instance identifier <code>foo</code>.</p>
<p>Modules are just functions, so they can receive parameters:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( id );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		identify: identify</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = CoolModule( <span class="string">"foo 1"</span> );</span><br><span class="line"><span class="keyword">var</span> foo2 = CoolModule( <span class="string">"foo 2"</span> );</span><br><span class="line"></span><br><span class="line">foo1.identify(); <span class="comment">// "foo 1"</span></span><br><span class="line">foo2.identify(); <span class="comment">// "foo 2"</span></span><br></pre></td></tr></table></figure>
<p>Another slight but powerful variation on the module pattern is to name the object you are returning as your public API:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// modifying the public API</span></span><br><span class="line">		publicAPI.identify = identify2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">identify1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( id );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">identify2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( id.toUpperCase() );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> publicAPI = &#123;</span><br><span class="line">		change: change,</span><br><span class="line">		identify: identify1</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> publicAPI;</span><br><span class="line">&#125;)( <span class="string">"foo module"</span> );</span><br><span class="line"></span><br><span class="line">foo.identify(); <span class="comment">// foo module</span></span><br><span class="line">foo.change();</span><br><span class="line">foo.identify(); <span class="comment">// FOO MODULE</span></span><br></pre></td></tr></table></figure>
<p>By retaining an inner reference to the public API object inside your module instance, you can modify that module instance <strong>from the inside</strong>, including adding and removing methods, properties, <em>and</em> changing their values.</p>
<h3 id="Modern-Modules"><a href="#Modern-Modules" class="headerlink" title="Modern Modules"></a>Modern Modules</h3><p>Various module dependency loaders/managers essentially wrap up this pattern of module definition into a friendly API. Rather than examine any one particular library, let me present a <em>very simple</em> proof of concept <strong>for illustration purposes (only)</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyModules = (<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name, deps, impl</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">			deps[i] = modules[deps[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		modules[name] = impl.apply( impl, deps );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> modules[name];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		define: define,</span><br><span class="line">		get: get</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>The key part of this code is <code>modules[name] = impl.apply(impl, deps)</code>. This is invoking the definition wrapper function for a module (passing in any dependencies), and storing the return value, the module’s API, into an internal list of modules tracked by name.</p>
<p>And here’s how I might use it to define some modules:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MyModules.define( <span class="string">"bar"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		hello: hello</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">MyModules.define( <span class="string">"foo"</span>, [<span class="string">"bar"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		awesome: awesome</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = MyModules.get( <span class="string">"bar"</span> );</span><br><span class="line"><span class="keyword">var</span> foo = MyModules.get( <span class="string">"foo"</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	bar.hello( <span class="string">"hippo"</span> )</span><br><span class="line">); <span class="comment">// Let me introduce: hippo</span></span><br><span class="line"></span><br><span class="line">foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>
<p>Both the “foo” and “bar” modules are defined with a function that returns a public API. “foo” even receives the instance of “bar” as a dependency parameter, and can use it accordingly.</p>
<p>Spend some time examining these code snippets to fully understand the power of closures put to use for our own good purposes. The key take-away is that there’s not really any particular “magic” to module managers. They fulfill both characteristics of the module pattern I listed above: invoking a function definition wrapper, and keeping its return value as the API for that module.</p>
<p>In other words, modules are just modules, even if you put a friendly wrapper tool on top of them.</p>
<h3 id="Future-Modules"><a href="#Future-Modules" class="headerlink" title="Future Modules"></a>Future Modules</h3><p>ES6 adds first-class syntax support for the concept of modules. When loaded via the module system, ES6 treats a file as a separate module. Each module can both import other modules or specific API members, as well export their own public API members.</p>
<p><strong>Note:</strong> Function-based modules aren’t a statically recognized pattern (something the compiler knows about), so their API semantics aren’t considered until run-time. That is, you can actually modify a module’s API during the run-time (see earlier <code>publicAPI</code> discussion).</p>
<p>By contrast, ES6 Module APIs are static (the APIs don’t change at run-time). Since the compiler knows <em>that</em>, it can (and does!) check during (file loading and) compilation that a reference to a member of an imported module’s API <em>actually exists</em>. If the API reference doesn’t exist, the compiler throws an “early” error at compile-time, rather than waiting for traditional dynamic run-time resolution (and errors, if any).</p>
<p>ES6 modules <strong>do not</strong> have an “inline” format, they must be defined in separate files (one per module). The browsers/engines have a default “module loader” (which is overridable, but that’s well-beyond our discussion here) which synchronously loads a module file when it’s imported.</p>
<p>Consider:</p>
<p><strong>bar.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Let me introduce: "</span> + who;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> hello;</span><br></pre></td></tr></table></figure></p>
<p><strong>foo.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import only `hello()` from the "bar" module</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hungry = <span class="string">"hippo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(</span><br><span class="line">		hello( hungry ).toUpperCase()</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> awesome;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import the entire "foo" and "bar" modules</span></span><br><span class="line"><span class="built_in">module</span> foo <span class="keyword">from</span> <span class="string">"foo"</span>;</span><br><span class="line"><span class="built_in">module</span> bar <span class="keyword">from</span> <span class="string">"bar"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">	bar.hello( <span class="string">"rhino"</span> )</span><br><span class="line">); <span class="comment">// Let me introduce: rhino</span></span><br><span class="line"></span><br><span class="line">foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> Separate files <strong>“foo.js”</strong> and <strong>“bar.js”</strong> would need to be created, with the contents as shown in the first two snippets, respectively. Then, your program would load/import those modules to use them, as shown in the third snippet.</p>
<p><code>import</code> imports one or more members from a module’s API into the current scope, each to a bound variable (<code>hello</code> in our case). <code>module</code> imports an entire module API to a bound variable (<code>foo</code>, <code>bar</code> in our case). <code>export</code> exports an identifier (variable, function) to the public API for the current module. These operators can be used as many times in a module’s definition as is necessary.</p>
<p>The contents inside the <em>module file</em> are treated as if enclosed in a scope closure, just like with the function-closure modules seen earlier.</p>
<h2 id="Review-TL-DR-4"><a href="#Review-TL-DR-4" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><p>Closure seems to the un-enlightened like a mystical world set apart inside of JavaScript which only the few bravest souls can reach. But it’s actually just a standard and almost obvious fact of how we write code in a lexically scoped environment, where functions are values and can be passed around at will.</p>
<p><strong>Closure is when a function can remember and access its lexical scope even when it’s invoked outside its lexical scope.</strong></p>
<p>Closures can trip us up, for instance with loops, if we’re not careful to recognize them and how they work. But they are also an immensely powerful tool, enabling patterns like <em>modules</em> in their various forms.</p>
<p>Modules require two key characteristics: 1) an outer wrapping function being invoked, to create the enclosing scope 2) the return value of the wrapping function must include reference to at least one inner function that then has closure over the private inner scope of the wrapper.</p>
<p>Now we can see closures all around our existing code, and we have the ability to recognize and leverage them to our own benefit!</p>
<h1 id="Appendix-A-Dynamic-Scope"><a href="#Appendix-A-Dynamic-Scope" class="headerlink" title="Appendix A: Dynamic Scope"></a>Appendix A: Dynamic Scope</h1><p>In Chapter 2, we talked about “Dynamic Scope” as a contrast to the “Lexical Scope” model, which is how scope works in JavaScript (and in fact, most other languages).</p>
<p>We will briefly examine dynamic scope, to hammer home the contrast. But, more importantly, dynamic scope actually is a near cousin to another mechanism (<code>this</code>) in JavaScript, which we covered in the “<em>this &amp; Object Prototypes</em>“ title of this book series.</p>
<p>As we saw in Chapter 2, lexical scope is the set of rules about how the <em>Engine</em> can look-up a variable and where it will find it. The key characteristic of lexical scope is that it is defined at author-time, when the code is written (assuming you don’t cheat with <code>eval()</code> or <code>with</code>).</p>
<p>Dynamic scope seems to imply, and for good reason, that there’s a model whereby scope can be determined dynamically at runtime, rather than statically at author-time. That is in fact the case. Let’s illustrate via code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>Lexical scope holds that the RHS reference to <code>a</code> in <code>foo()</code> will be resolved to the global variable <code>a</code>, which will result in value <code>2</code> being output.</p>
<p>Dynamic scope, by contrast, doesn’t concern itself with how and where functions and scopes are declared, but rather <strong>where they are called from</strong>. In other words, the scope chain is based on the call-stack, not the nesting of scopes in code.</p>
<p>So, if JavaScript had dynamic scope, when <code>foo()</code> is executed, <strong>theoretically</strong> the code below would instead result in <code>3</code> as the output.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 3  (not 2!)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>How can this be? Because when <code>foo()</code> cannot resolve the variable reference for <code>a</code>, instead of stepping up the nested (lexical) scope chain, it walks up the call-stack, to find where <code>foo()</code> was <em>called from</em>. Since <code>foo()</code> was called from <code>bar()</code>, it checks the variables in scope for <code>bar()</code>, and finds an <code>a</code> there with value <code>3</code>.</p>
<p>Strange? You’re probably thinking so, at the moment.</p>
<p>But that’s just because you’ve probably only ever worked on (or at least deeply considered) code which is lexically scoped. So dynamic scoping seems foreign. If you had only ever written code in a dynamically scoped language, it would seem natural, and lexical scope would be the odd-ball.</p>
<p>To be clear, JavaScript <strong>does not, in fact, have dynamic scope</strong>. It has lexical scope. Plain and simple. But the <code>this</code> mechanism is kind of like dynamic scope.</p>
<p>The key contrast: <strong>lexical scope is write-time, whereas dynamic scope (and <code>this</code>!) are runtime</strong>. Lexical scope cares <em>where a function was declared</em>, but dynamic scope cares where a function was <em>called from</em>.</p>
<p>Finally: <code>this</code> cares <em>how a function was called</em>, which shows how closely related the <code>this</code> mechanism is to the idea of dynamic scoping. To dig more into <code>this</code>, read the title “<em>this &amp; Object Prototypes</em>“.</p>
<h1 id="Appendix-B-Polyfilling-Block-Scope"><a href="#Appendix-B-Polyfilling-Block-Scope" class="headerlink" title="Appendix B: Polyfilling Block Scope"></a>Appendix B: Polyfilling Block Scope</h1><p>In Chapter 3, we explored Block Scope. We saw that <code>with</code> and the <code>catch</code> clause are both tiny examples of block scope that have existed in JavaScript since at least the introduction of ES3.</p>
<p>But it’s ES6’s introduction of <code>let</code> that finally gives full, unfettered block-scoping capability to our code. There are many exciting things, both functionally and code-stylistically, that block scope will enable.</p>
<p>But what if we wanted to use block scope in pre-ES6 environments?</p>
<p>Consider this code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>This will work great in ES6 environments. But can we do so pre-ES6? <code>catch</code> is the answer.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">2</span>&#125;<span class="keyword">catch</span>(a)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>Whoa! That’s some ugly, weird looking code. We see a <code>try/catch</code> that appears to forcibly throw an error, but the “error” it throws is just a value <code>2</code>, and then the variable declaration that receives it is in the <code>catch(a)</code> clause. Mind: blown.</p>
<p>That’s right, the <code>catch</code> clause has block-scoping to it, which means it can be used as a polyfill for block scope in pre-ES6 environments.</p>
<p>“But…”, you say. “…no one wants to write ugly code like that!” That’s true. No one writes (some of) the code output by the CoffeeScript compiler, either. That’s not the point.</p>
<p>The point is that tools can transpile ES6 code to work in pre-ES6 environments. You can write code using block-scoping, and benefit from such functionality, and let a build-step tool take care of producing code that will actually <em>work</em> when deployed.</p>
<p>This is actually the preferred migration path for all (ahem, most) of ES6: to use a code transpiler to take ES6 code and produce ES5-compatible code during the transition from pre-ES6 to ES6.</p>
<h2 id="Traceur"><a href="#Traceur" class="headerlink" title="Traceur"></a>Traceur</h2><p>Google maintains a project called “Traceur” [^note-traceur], which is exactly tasked with transpiling ES6 features into pre-ES6 (mostly ES5, but not all!) for general usage. The TC39 committee relies on this tool (and others) to test out the semantics of the features they specify.</p>
<p>What does Traceur produce from our snippet? You guessed it!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="literal">undefined</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (a) &#123;</span><br><span class="line">		a = <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">console</span>.log( a );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>
<p>So, with the use of such tools, we can start taking advantage of block scope regardless of if we are targeting ES6 or not, because <code>try/catch</code> has been around (and worked this way) from ES3 days.</p>
<h2 id="Implicit-vs-Explicit-Blocks"><a href="#Implicit-vs-Explicit-Blocks" class="headerlink" title="Implicit vs. Explicit Blocks"></a>Implicit vs. Explicit Blocks</h2><p>In Chapter 3, we identified some potential pitfalls to code maintainability/refactorability when we introduce block-scoping. Is there another way to take advantage of block scope but to reduce this downside?</p>
<p>Consider this alternate form of <code>let</code>, called the “let block” or “let statement” (contrasted with “let declarations” from before).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (a = <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>Instead of implicitly hijacking an existing block, the let-statement creates an explicit block for its scope binding. Not only does the explicit block stand out more, and perhaps fare more robustly in code refactoring, it produces somewhat cleaner code by, grammatically, forcing all the declarations to the top of the block. This makes it easier to look at any block and know what’s scoped to it and not.</p>
<p>As a pattern, it mirrors the approach many people take in function-scoping when they manually move/hoist all their <code>var</code> declarations to the top of the function. The let-statement puts them there at the top of the block by intent, and if you don’t use <code>let</code> declarations strewn throughout, your block-scoping declarations are somewhat easier to identify and maintain.</p>
<p>But, there’s a problem. The let-statement form is not included in ES6. Neither does the official Traceur compiler accept that form of code.</p>
<p>We have two options. We can format using ES6-valid syntax and a little sprinkle of code discipline:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*let*/</span> &#123; <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>But, tools are meant to solve our problems. So the other option is to write explicit let statement blocks, and let a tool convert them to valid, working code.</p>
<p>So, I built a tool called “let-er” [^note-let_er] to address just this issue. <em>let-er</em> is a build-step code transpiler, but its only task is to find let-statement forms and transpile them. It will leave alone any of the rest of your code, including any let-declarations. You can safely use <em>let-er</em> as the first ES6 transpiler step, and then pass your code through something like Traceur if necessary.</p>
<p>Moreover, <em>let-er</em> has a configuration flag <code>--es6</code>, which when turned on (off by default), changes the kind of code produced. Instead of the <code>try/catch</code> ES3 polyfill hack, <em>let-er</em> would take our snippet and produce the fully ES6-compliant, non-hacky:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>So, you can start using <em>let-er</em> right away, and target all pre-ES6 environments, and when you only care about ES6, you can add the flag and instantly target only ES6.</p>
<p>And most importantly, <strong>you can use the more preferable and more explicit let-statement form</strong> even though it is not an official part of any ES version (yet).</p>
<h2 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h2><p>Let me add one last quick note on the performance of <code>try/catch</code>, and/or to address the question, “why not just use an IIFE to create the scope?”</p>
<p>Firstly, the performance of <code>try/catch</code> <em>is</em> slower, but there’s no reasonable assumption that it <em>has</em> to be that way, or even that it <em>always will be</em> that way. Since the official TC39-approved ES6 transpiler uses <code>try/catch</code>, the Traceur team has asked Chrome to improve the performance of <code>try/catch</code>, and they are obviously motivated to do so.</p>
<p>Secondly, IIFE is not a fair apples-to-apples comparison with <code>try/catch</code>, because a function wrapped around any arbitrary code changes the meaning, inside of that code, of <code>this</code>, <code>return</code>, <code>break</code>, and <code>continue</code>. IIFE is not a suitable general substitute. It could only be used manually in certain cases.</p>
<p>The question really becomes: do you want block-scoping, or not. If you do, these tools provide you that option. If not, keep using <code>var</code> and go on about your coding!</p>
<p>[^note-traceur]: <a href="http://traceur-compiler.googlecode.com/git/demo/repl.html" target="_blank" rel="noopener">Google Traceur</a></p>
<p>[^note-let_er]\: <a href="https://github.com/getify/let-er" target="_blank" rel="noopener">let-er</a></p>
<h1 id="Appendix-C-Lexical-this"><a href="#Appendix-C-Lexical-this" class="headerlink" title="Appendix C: Lexical-this"></a>Appendix C: Lexical-this</h1><p>Though this title does not address the <code>this</code> mechanism in any detail, there’s one ES6 topic which relates <code>this</code> to lexical scope in an important way, which we will quickly examine.</p>
<p>ES6 adds a special syntactic form of function declaration called the “arrow function”. It looks like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log( a );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>The so-called “fat arrow” is often mentioned as a short-hand for the <em>tediously verbose</em> (sarcasm) <code>function</code> keyword.</p>
<p>But there’s something much more important going on with arrow-functions that has nothing to do with saving keystrokes in your declaration.</p>
<p>Briefly, this code suffers a problem:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	id: <span class="string">"awesome"</span>,</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.id );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span>;</span><br><span class="line"></span><br><span class="line">obj.cool(); <span class="comment">// awesome</span></span><br><span class="line"></span><br><span class="line">setTimeout( obj.cool, <span class="number">100</span> ); <span class="comment">// not awesome</span></span><br></pre></td></tr></table></figure>
<p>The problem is the loss of <code>this</code> binding on the <code>cool()</code> function. There are various ways to address that problem, but one often-repeated solution is <code>var self = this;</code>.</p>
<p>That might look like:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	count: <span class="number">0</span>,</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				self.count++;</span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</span><br><span class="line">			&#125;, <span class="number">100</span> );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.cool(); <span class="comment">// awesome?</span></span><br></pre></td></tr></table></figure>
<p>Without getting too much into the weeds here, the <code>var self = this</code> “solution” just dispenses with the whole problem of understanding and properly using <code>this</code> binding, and instead falls back to something we’re perhaps more comfortable with: lexical scope. <code>self</code> becomes just an identifier that can be resolved via lexical scope and closure, and cares not what happened to the <code>this</code> binding along the way.</p>
<p>People don’t like writing verbose stuff, especially when they do it over and over again. So, a motivation of ES6 is to help alleviate these scenarios, and indeed, <em>fix</em> common idiom problems, such as this one.</p>
<p>The ES6 solution, the arrow-function, introduces a behavior called “lexical this”.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	count: <span class="number">0</span>,</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// arrow-function ftw?</span></span><br><span class="line">				<span class="keyword">this</span>.count++;</span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">"awesome?"</span> );</span><br><span class="line">			&#125;, <span class="number">100</span> );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.cool(); <span class="comment">// awesome?</span></span><br></pre></td></tr></table></figure>
<p>The short explanation is that arrow-functions do not behave at all like normal functions when it comes to their <code>this</code> binding. They discard all the normal rules for <code>this</code> binding, and instead take on the <code>this</code> value of their immediate lexical enclosing scope, whatever it is.</p>
<p>So, in that snippet, the arrow-function doesn’t get its <code>this</code> unbound in some unpredictable way, it just “inherits” the <code>this</code> binding of the <code>cool()</code> function (which is correct if we invoke it as shown!).</p>
<p>While this makes for shorter code, my perspective is that arrow-functions are really just codifying into the language syntax a common <em>mistake</em> of developers, which is to confuse and conflate “this binding” rules with “lexical scope” rules.</p>
<p>Put another way: why go to the trouble and verbosity of using the <code>this</code> style coding paradigm, only to cut it off at the knees by mixing it with lexical references. It seems natural to embrace one approach or the other for any given piece of code, and not mix them in the same piece of code.</p>
<p><strong>Note:</strong> one other detraction from arrow-functions is that they are anonymous, not named. See Chapter 3 for the reasons why anonymous functions are less desirable than named functions.</p>
<p>A more appropriate approach, in my perspective, to this “problem”, is to use and embrace the <code>this</code> mechanism correctly.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	count: <span class="number">0</span>,</span><br><span class="line">	cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.count++; <span class="comment">// `this` is safe because of `bind(..)`</span></span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">"more awesome"</span> );</span><br><span class="line">			&#125;.bind( <span class="keyword">this</span> ), <span class="number">100</span> ); <span class="comment">// look, `bind()`!</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.cool(); <span class="comment">// more awesome</span></span><br></pre></td></tr></table></figure>
<p>Whether you prefer the new lexical-this behavior of arrow-functions, or you prefer the tried-and-true <code>bind()</code>, it’s important to note that arrow-functions are <strong>not</strong> just about less typing of “function”.</p>
<p>They have an <em>intentional behavioral difference</em> that we should learn and understand, and if we so choose, leverage.</p>
<p>Now that we fully understand lexical scoping (and closure!), understanding lexical-this should be a breeze!</p>
<h1 id="Appendix-D-Acknowledgments"><a href="#Appendix-D-Acknowledgments" class="headerlink" title="Appendix D: Acknowledgments"></a>Appendix D: Acknowledgments</h1><p>I have many people to thank for making this book title and the overall series happen.</p>
<p>First, I must thank my wife Christen Simpson, and my two kids Ethan and Emily, for putting up with Dad always pecking away at the computer. Even when not writing books, my obsession with JavaScript glues my eyes to the screen far more than it should. That time I borrow from my family is the reason these books can so deeply and completely explain JavaScript to you, the reader. I owe my family everything.</p>
<p>I’d like to thank my editors at O’Reilly, namely Simon St.Laurent and Brian MacDonald, as well as the rest of the editorial and marketing staff. They are fantastic to work with, and have been especially accommodating during this experiment into “open source” book writing, editing, and production.</p>
<p>Thank you to the many folks who have participated in making this book series better by providing editorial suggestions and corrections, including Shelley Powers, Tim Ferro, Evan Borden, Forrest L. Norvell, Jennifer Davis, Jesse Harlin, and many others. A big thank you to Shane Hudson for writing the Foreword for this title.</p>
<p>Thank you to the countless folks in the community, including members of the TC39 committee, who have shared so much knowledge with the rest of us, and especially tolerated my incessant questions and explorations with patience and detail. John-David Dalton, Juriy “kangax” Zaytsev, Mathias Bynens, Axel Rauschmayer, Nicholas Zakas, Angus Croll, Reginald Braithwaite, Dave Herman, Brendan Eich, Allen Wirfs-Brock, Bradley Meck, Domenic Denicola, David Walsh, Tim Disney, Peter van der Zee, Andrea Giammarchi, Kit Cambridge, Eric Elliott, and so many others, I can’t even scratch the surface.</p>
<p>The <em>You Don’t Know JS</em> book series was born on Kickstarter, so I also wish to thank all my (nearly) 500 generous backers, without whom this book series could not have happened:</p>
<blockquote>
<p>Jan Szpila, nokiko, Murali Krishnamoorthy, Ryan Joy, Craig Patchett, pdqtrader, Dale Fukami, ray hatfield, R0drigo Perez [Mx], Dan Petitt, Jack Franklin, Andrew Berry, Brian Grinstead, Rob Sutherland, Sergi Meseguer, Phillip Gourley, Mark Watson, Jeff Carouth, Alfredo Sumaran, Martin Sachse, Marcio Barrios, Dan, AimelyneM, Matt Sullivan, Delnatte Pierre-Antoine, Jake Smith, Eugen Tudorancea, Iris, David Trinh, simonstl, Ray Daly, Uros Gruber, Justin Myers, Shai Zonis, Mom &amp; Dad, Devin Clark, Dennis Palmer, Brian Panahi Johnson, Josh Marshall, Marshall, Dennis Kerr, Matt Steele, Erik Slagter, Sacah, Justin Rainbow, Christian Nilsson, Delapouite, D.Pereira, Nicolas Hoizey, George V. Reilly, Dan Reeves, Bruno Laturner, Chad Jennings, Shane King, Jeremiah Lee Cohick, od3n, Stan Yamane, Marko Vucinic, Jim B, Stephen Collins, Ægir Þorsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, Alexandre ELISÉ, Chris Peterson, Rik Watson, Luke Matthews, Justin Lowery, Morten Nielsen, Vernon Kesner, Chetan Shenoy, Paul Tregoing, Marc Grabanski, Dion Almaer, Andrew Sullivan, Keith Elsass, Tom Burke, Brian Ashenfelter, David Stuart, Karl Swedberg, Graeme, Brandon Hays, John Christopher, Gior, manoj reddy, Chad Smith, Jared Harbour, Minoru TODA, Chris Wigley, Daniel Mee, Mike, Handyface, Alex Jahraus, Carl Furrow, Rob Foulkrod, Max Shishkin, Leigh Penny Jr., Robert Ferguson, Mike van Hoenselaar, Hasse Schougaard, rajan venkataguru, Jeff Adams, Trae Robbins, Rolf Langenhuijzen, Jorge Antunes, Alex Koloskov, Hugh Greenish, Tim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish Muvva, Barkóczi Dávid, Kitt Hodsden, Paul McGraw, Sascha Goldhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt Jared, Juanfran, Georgie Kirschner, Kenny Lee, Ted Zhang, Amit Pahwa, Inbal Sinai, Dan Raine, Schabse Laks, Michael Tervoort, Alexandre Abreu, Alan Joseph Williams, NicolasD, Cindy Wong, Reg Braithwaite, LocalPCGuy, Jon Friskics, Chris Merriman, John Pena, Jacob Katz, Sue Lockwood, Magnus Johansson, Jeremy Crapsey, Grzegorz Pawłowski, nico nuzzaci, Christine Wilks, Hans Bergren, charles montgomery, Ariel בר-לבב Fogel, Ivan Kolev, Daniel Campos, Hugh Wood, Christian Bradford, Frédéric Harper, Ionuţ Dan Popa, Jeff Trimble, Rupert Wood, Trey Carrico, Pancho Lopez, Joël kuijten, Tom A Marra, Jeff Jewiss, Jacob Rios, Paolo Di Stefano, Soledad Penades, Chris Gerber, Andrey Dolganov, Wil Moore III, Thomas Martineau, Kareem, Ben Thouret, Udi Nir, Morgan Laupies, jory carson-burson, Nathan L Smith, Eric Damon Walters, Derry Lozano-Hoyland, Geoffrey Wiseman, mkeehner, KatieK, Scott MacFarlane, Brian LaShomb, Adrien Mas, christopher ross, Ian Littman, Dan Atkinson, Elliot Jobe, Nick Dozier, Peter Wooley, John Hoover, dan, Martin A. Jackson, Héctor Fernando Hurtado, andy ennamorato, Paul Seltmann, Melissa Gore, Dave Pollard, Jack Smith, Philip Da Silva, Guy Israeli, @megalithic, Damian Crawford, Felix Gliesche, April Carter Grant, Heidi, jim tierney, Andrea Giammarchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john gibbon, David J. Groom, BBox, Yu ‘Dilys’ Sun, Nate Steiner, Brandon Satrom, Brian Wyant, Wesley Hales, Ian Pouncey, Timothy Kevin Oxley, George Terezakis, sanjay raj, Jordan Harband, Marko McLion, Wolfgang Kaufmann, Pascal Peuckert, Dave Nugent, Markus Liebelt, Welling Guzman, Nick Cooley, Daniel Mesquita, Robert Syvarth, Chris Coyier, Rémy Bach, Adam Dougal, Alistair Duggin, David Loidolt, Ed Richer, Brian Chenault, GoldFire Studios, Carles Andrés, Carlos Cabo, Yuya Saito, roberto ricardo, Barnett Klane, Mike Moore, Kevin Marx, Justin Love, Joe Taylor, Paul Dijou, Michael Kohler, Rob Cassie, Mike Tierney, Cody Leroy Lindley, tofuji, Shimon Schwartz, Raymond, Luc De Brouwer, David Hayes, Rhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - Level Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael Corral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph C., SwiftOne, Jan Hohner, Derick Bailey, getify, Daniel Cousineau, Chris Charlton, Eric Turner, David Turner, Joël Galeran, Dharma Vagabond, adam, Dirk van Bergen, dave ♥♫★ furf, Vedran Zakanj, Ryan McAllen, Natalie Patrice Tucker, Eric J. Bivona, Adam Spooner, Aaron Cavano, Kelly Packer, Eric J, Martin Drenovac, Emilis, Michael Pelikan, Scott F. Walter, Josh Freeman, Brandon Hudgeons, vijay chennupati, Bill Glennon, Robin R., Troy Forster, otaku_coder, Brad, Scott, Frederick Ostrander, Adam Brill, Seb Flippence, Michael Anderson, Jacob, Adam Randlett, Standard, Joshua Clanton, Sebastian Kouba, Chris Deck, SwordFire, Hannes Papenberg, Richard Woeber, hnzz, Rob Crowther, Jedidiah Broadbent, Sergey Chernyshev, Jay-Ar Jamon, Ben Combee, luciano bonachela, Mark Tomlinson, Kit Cambridge, Michael Melgares, Jacob Adams, Adrian Bruinhout, Bev Wieber, Scott Puleo, Thomas Herzog, April Leone, Daniel Mizieliński, Kees van Ginkel, Jon Abrams, Erwin Heiser, Avi Laviad, David newell, Jean-Francois Turcot, Niko Roberts, Erik Dana, Charles Neill, Aaron Holmes, Grzegorz Ziółkowski, Nathan Youngman, Timothy, Jacob Mather, Michael Allan, Mohit Seth, Ryan Ewing, Benjamin Van Treese, Marcelo Santos, Denis Wolf, Phil Keys, Chris Yung, Timo Tijhof, Martin Lekvall, Agendine, Greg Whitworth, Helen Humphrey, Dougal Campbell, Johannes Harth, Bruno Girin, Brian Hough, Darren Newton, Craig McPheat, Olivier Tille, Dennis Roethig, Mathias Bynens, Brendan Stromberger, sundeep, John Meyer, Ron Male, John F Croston III, gigante, Carl Bergenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry Suitor, afeliz, Tom Kiefer, Darragh Duffy, Kevin Vanderbeken, Andy Pearson, Simon Mac Donald, Abid Din, Chris Joel, Tomas Theunissen, David Dick, Paul Grock, Brandon Wood, John Weis, dgrebb, Nick Jenkins, Chuck Lane, Johnny Megahan, marzsman, Tatu Tamminen, Geoffrey Knauth, Alexander Tarmolov, Jeremy Tymes, Chad Auld, Sean Parmelee, Rob Staenke, Dan Bender, Yannick derwa, Joshua Jones, Geert Plaisier, Tom LeZotte, Christen Simpson, Stefan Bruvik, Justin Falcone, Carlos Santana, Michael Weiss, Pablo Villoslada, Peter deHaan, Dimitris Iliopoulos, seyDoggy, Adam Jordens, Noah Kantrowitz, Amol M, Matthew Winnard, Dirk Ginader, Phinam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael George, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, Robert Kowalski, David I. Teixeira (@ditma), Charles Carpenter, Justin Yost, Sam S, Denis Ciccale, Kevin Sheurs, Yannick Croissant, Pau Fracés, Stephen McGowan, Shawn Searcy, Chris Ruppel, Kevin Lamping, Jessica Campbell, Christopher Schmitt, Sablons, Jonathan Reisdorf, Bunni Gek, Teddy Huff, Michael Mullany, Michael Fürstenberg, Carl Henderson, Rick Yoesting, Scott Nichols, Hernán Ciudad, Andrew Maier, Mike Stapp, Jesse Shawl, Sérgio Lopes, jsulak, Shawn Price, Joel Clermont, Chris Ridmann, Sean Timm, Jason Finch, Aiden Montgomery, Elijah Manor, Derek Gathright, Jesse Harlin, Dillon Curry, Courtney Myers, Diego Cadenas, Arne de Bree, João Paulo Dubas, James Taylor, Philipp Kraeutli, Mihai Păun, Sam Gharegozlou, joshjs, Matt Murchison, Eric Windham, Timo Behrmann, Andrew Hall, joshua price, Théophile Villard</p>
</blockquote>
<p>This book series is being produced in an open source fashion, including editing and production. We owe GitHub a debt of gratitude for making that sort of thing possible for the community!</p>
<p>Thank you again to all the countless folks I didn’t name but who I nonetheless owe thanks. May this book series be “owned” by all of us and serve to contribute to increasing awareness and understanding of the JavaScript language, to the benefit of all current and future community contributors.</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/03/01/scope-closures/">scope &amp; closures</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">LAOJIA</a></p>
        <p><span>发布时间:</span>2018-03-01, 11:34:20</p>
        <p><span>最后更新:</span>2018-03-04, 12:58:27</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/03/01/scope-closures/" title="scope &amp; closures">https://jiamh2005.github.io/2018/03/01/scope-closures/</a>
            <span class="copy-path" data-clipboard-text="原文: https://jiamh2005.github.io/2018/03/01/scope-closures/　　作者: LAOJIA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/03/01/两次全球大危机的比较研究/">
                    两次全球大危机的比较研究
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/02/27/Async-Performence/">
                    Async&amp;Performence
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-What-is-Scope"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1: What is Scope?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Compiler-Theory"><span class="toc-number">1.1.</span> <span class="toc-text">Compiler Theory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Understanding-Scope"><span class="toc-number">1.2.</span> <span class="toc-text">Understanding Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Cast"><span class="toc-number">1.2.1.</span> <span class="toc-text">The Cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Back-amp-Forth"><span class="toc-number">1.2.2.</span> <span class="toc-text">Back &amp; Forth</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compiler-Speak"><span class="toc-number">1.2.3.</span> <span class="toc-text">Compiler Speak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Engine-Scope-Conversation"><span class="toc-number">1.2.4.</span> <span class="toc-text">Engine/Scope Conversation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quiz"><span class="toc-number">1.2.5.</span> <span class="toc-text">Quiz</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nested-Scope"><span class="toc-number">1.3.</span> <span class="toc-text">Nested Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Building-on-Metaphors"><span class="toc-number">1.3.1.</span> <span class="toc-text">Building on Metaphors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Errors"><span class="toc-number">1.4.</span> <span class="toc-text">Errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-TL-DR"><span class="toc-number">1.5.</span> <span class="toc-text">Review (TL;DR)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Quiz-Answers"><span class="toc-number">1.5.1.</span> <span class="toc-text">Quiz Answers</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Lexical-Scope"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2: Lexical Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lex-time"><span class="toc-number">2.1.</span> <span class="toc-text">Lex-time</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Look-ups"><span class="toc-number">2.1.1.</span> <span class="toc-text">Look-ups</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cheating-Lexical"><span class="toc-number">2.2.</span> <span class="toc-text">Cheating Lexical</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#eval"><span class="toc-number">2.2.1.</span> <span class="toc-text">eval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with"><span class="toc-number">2.2.2.</span> <span class="toc-text">with</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Performance"><span class="toc-number">2.2.3.</span> <span class="toc-text">Performance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-TL-DR-1"><span class="toc-number">2.3.</span> <span class="toc-text">Review (TL;DR)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Function-vs-Block-Scope"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3: Function vs. Block Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scope-From-Functions"><span class="toc-number">3.1.</span> <span class="toc-text">Scope From Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hiding-In-Plain-Scope"><span class="toc-number">3.2.</span> <span class="toc-text">Hiding In Plain Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collision-Avoidance"><span class="toc-number">3.2.1.</span> <span class="toc-text">Collision Avoidance</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Global-“Namespaces”"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">Global “Namespaces”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Module-Management"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">Module Management</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-As-Scopes"><span class="toc-number">3.3.</span> <span class="toc-text">Functions As Scopes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Anonymous-vs-Named"><span class="toc-number">3.3.1.</span> <span class="toc-text">Anonymous vs. Named</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invoking-Function-Expressions-Immediately"><span class="toc-number">3.3.2.</span> <span class="toc-text">Invoking Function Expressions Immediately</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Blocks-As-Scopes"><span class="toc-number">3.4.</span> <span class="toc-text">Blocks As Scopes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#with-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">with</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch"><span class="toc-number">3.4.2.</span> <span class="toc-text">try/catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-number">3.4.3.</span> <span class="toc-text">let</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Garbage-Collection"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">Garbage Collection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let-Loops"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">let Loops</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">3.4.4.</span> <span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-TL-DR-2"><span class="toc-number">3.5.</span> <span class="toc-text">Review (TL;DR)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-Hoisting"><span class="toc-number">4.</span> <span class="toc-text">Chapter 4: Hoisting</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chicken-Or-The-Egg"><span class="toc-number">4.1.</span> <span class="toc-text">Chicken Or The Egg?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Compiler-Strikes-Again"><span class="toc-number">4.2.</span> <span class="toc-text">The Compiler Strikes Again</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-First"><span class="toc-number">4.3.</span> <span class="toc-text">Functions First</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-TL-DR-3"><span class="toc-number">4.4.</span> <span class="toc-text">Review (TL;DR)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-Scope-Closure"><span class="toc-number">5.</span> <span class="toc-text">Chapter 5: Scope Closure</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Enlightenment"><span class="toc-number">5.1.</span> <span class="toc-text">Enlightenment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nitty-Gritty"><span class="toc-number">5.2.</span> <span class="toc-text">Nitty Gritty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Now-I-Can-See"><span class="toc-number">5.3.</span> <span class="toc-text">Now I Can See</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loops-Closure"><span class="toc-number">5.4.</span> <span class="toc-text">Loops + Closure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Block-Scoping-Revisited"><span class="toc-number">5.4.1.</span> <span class="toc-text">Block Scoping Revisited</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Modules"><span class="toc-number">5.5.</span> <span class="toc-text">Modules</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Modern-Modules"><span class="toc-number">5.5.1.</span> <span class="toc-text">Modern Modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-Modules"><span class="toc-number">5.5.2.</span> <span class="toc-text">Future Modules</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-TL-DR-4"><span class="toc-number">5.6.</span> <span class="toc-text">Review (TL;DR)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-A-Dynamic-Scope"><span class="toc-number">6.</span> <span class="toc-text">Appendix A: Dynamic Scope</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-B-Polyfilling-Block-Scope"><span class="toc-number">7.</span> <span class="toc-text">Appendix B: Polyfilling Block Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Traceur"><span class="toc-number">7.1.</span> <span class="toc-text">Traceur</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implicit-vs-Explicit-Blocks"><span class="toc-number">7.2.</span> <span class="toc-text">Implicit vs. Explicit Blocks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Performance-1"><span class="toc-number">7.3.</span> <span class="toc-text">Performance</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-C-Lexical-this"><span class="toc-number">8.</span> <span class="toc-text">Appendix C: Lexical-this</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Appendix-D-Acknowledgments"><span class="toc-number">9.</span> <span class="toc-text">Appendix D: Acknowledgments</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    

    
</div>




    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/03/01/两次全球大危机的比较研究/" title="上一篇: 两次全球大危机的比较研究">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/02/27/Async-Performence/" title="下一篇: Async&amp;Performence">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/公司法/">公司法-2018年</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/15/关于中风的及时治疗/">关于中风的及时治疗</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/18/那些证书相关的玩意儿/">那些证书相关的玩意儿</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/Stay-Hungry-Stay-Foolish/">Stay Hungry, Stay Foolish</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/01/两次全球大危机的比较研究/">两次全球大危机的比较研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/01/scope-closures/">scope & closures</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/Async-Performence/">Async&Performence</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/充分利用青春期大脑的学习潜力/">充分利用青春期大脑的学习潜力</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/2007年的访谈/">2007年的访谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/27/又一篇BLOG/">又一篇BLOG</a></li></ul>




    <script>
        
    </script>
</div>
      <nav id="mobile-nav">
  <div class="intrude-less">
      <header id="header" class="inner">
          <a href="/" class="profilepic">
              <img src="/img/avatar.png" class="animated zoomIn">
          </a>
          <hgroup>
            <h1 class="header-author"><a href="/" title="回到主页">LAOJIA</a></h1>
          </hgroup>
          
          <nav class="header-menu">
              <ul>
              
                  <li><a href="/">主页</a></li>
              
                  <li><a href="/tags/">标签云</a></li>
              
                  <li><a href="/about/">关于我</a></li>
              
              <div class="clearfix"></div>
              </ul>
          </nav>
          <nav class="header-nav">
                      <ul class="social">
                          
                              <a class="fa Email" target="_blank" href="mailto:jia@jiamh.top" title="Email"></a>
                          
                              <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                          
                              <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                          
                      </ul>
          </nav>
      </header>
  </div>
  <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>

      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
          
              <div class="visit">
                  
                      <span id="busuanzi_container_site_pv" style='display:none'>
                          <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                          </span>
                      </span>
                  
                  
                      <span>| </span>
                  
                  
                      <span id="busuanzi_container_page_pv" style='display:none'>
                          <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                          </span>
                      </span>
                  
              </div>
          
          <div class="footer-left">
              <i class="fa fa-copyright"></i>
              2018 LAOJIA
          </div>
          <div class="footer-right">
              <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
          </div>
        </div>
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
